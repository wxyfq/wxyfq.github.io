<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ffplay源码解析（六）：解码线程</title>
      <link href="/2022/12/02/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E8%A7%A3%E7%A0%81%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/12/02/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E8%A7%A3%E7%A0%81%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>ffplay的音频流、视频流和字幕流的解码工作通过三个解码线程完成，解码线程通过decoder_start函数开启，分别调用audio_thread,video_thread,subtitle_thread三个函数，接下来我们逐个分析。</p><p>首先是音频解码函数audio_thread，去除滤镜处理的相关代码，函数代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">audio_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  VideoState *is = arg;</span><br><span class="line">  AVFrame *frame = av_frame_alloc();</span><br><span class="line">  Frame *af;</span><br><span class="line">  <span class="type">int</span> got_frame = <span class="number">0</span>;</span><br><span class="line">  AVRational tb;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!frame)</span><br><span class="line">    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((got_frame = decoder_decode_frame(&amp;is-&gt;auddec, frame, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> the_end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (got_frame) &#123;</span><br><span class="line">      tb = (AVRational)&#123;<span class="number">1</span>, frame-&gt;sample_rate&#125;;</span><br><span class="line">       <span class="keyword">if</span> (!(af = frame_queue_peek_writable(&amp;is-&gt;sampq)))</span><br><span class="line">          <span class="keyword">goto</span> the_end;</span><br><span class="line"></span><br><span class="line">        af-&gt;pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);</span><br><span class="line">        af-&gt;pos = frame-&gt;pkt_pos;</span><br><span class="line">        af-&gt;serial = is-&gt;auddec.pkt_serial;</span><br><span class="line">        af-&gt;duration = av_q2d((AVRational)&#123;frame-&gt;nb_samples, frame-&gt;sample_rate&#125;);</span><br><span class="line"></span><br><span class="line">        av_frame_move_ref(af-&gt;frame, frame);</span><br><span class="line">        frame_queue_push(&amp;is-&gt;sampq);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (ret &gt;= <span class="number">0</span> || ret == AVERROR(EAGAIN) || ret == AVERROR_EOF);</span><br><span class="line">  the_end:</span><br><span class="line">  av_frame_free(&amp;frame);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑十分直观，在一个do-while循环中调用decocer_decode_frame()活的解码后的数据，存入一个AVFrame中，然后从FrameQueue中获取一个指向可写位置的指针af，将AVFrame中的数据写入af对应的字段，最后调用frame_queue_push移动FrameQueue的写指针。由于我们屏蔽掉了滤镜相关的函数，所以while的循环条件看起来有点奇怪，不过效果是一样的，在没有配置滤镜功能时就是一个简单的无线循环。</p><p>我们再来看一下视频解码线程video_thread，精简掉滤镜相关的代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">video_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  VideoState *is = arg;</span><br><span class="line">  AVFrame *frame = av_frame_alloc();</span><br><span class="line">  <span class="type">double</span> pts;</span><br><span class="line">  <span class="type">double</span> duration;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  AVRational tb = is-&gt;video_st-&gt;time_base;</span><br><span class="line">  AVRational frame_rate = av_guess_frame_rate(is-&gt;ic, is-&gt;video_st, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (!frame)</span><br><span class="line">    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    ret = get_video_frame(is, frame);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> the_end;</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      duration = (frame_rate.num &amp;&amp; frame_rate.den ? av_q2d((AVRational)&#123;frame_rate.den, frame_rate.num&#125;) : <span class="number">0</span>);</span><br><span class="line">      pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);</span><br><span class="line">      ret = queue_picture(is, frame, pts, duration, frame-&gt;pkt_pos, is-&gt;viddec.pkt_serial);</span><br><span class="line">      av_frame_unref(frame);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> the_end;</span><br><span class="line">  &#125;</span><br><span class="line">  the_end:</span><br><span class="line">  av_frame_free(&amp;frame);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与音频不同，视频解码线程的处理函数将解码视频帧和将视频帧放入队列这两个步骤封装在了get_video_frame和</p><p>queue_picture两个函数中。我们先来看get_video_fream的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_video_frame</span><span class="params">(VideoState *is, AVFrame *frame)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> got_picture;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((got_picture = decoder_decode_frame(&amp;is-&gt;viddec, frame, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (got_picture) &#123;</span><br><span class="line">    <span class="type">double</span> dpts = NAN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE)</span><br><span class="line">      dpts = av_q2d(is-&gt;video_st-&gt;time_base) * frame-&gt;pts;</span><br><span class="line"></span><br><span class="line">    frame-&gt;sample_aspect_ratio = av_guess_sample_aspect_ratio(is-&gt;ic, is-&gt;video_st, frame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (framedrop&gt;<span class="number">0</span> || (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">        <span class="type">double</span> diff = dpts - get_master_clock(is);</span><br><span class="line">        <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD &amp;&amp;</span><br><span class="line">            diff - is-&gt;frame_last_filter_delay &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            is-&gt;viddec.pkt_serial == is-&gt;vidclk.serial &amp;&amp;</span><br><span class="line">            is-&gt;videoq.nb_packets) &#123;</span><br><span class="line">          is-&gt;frame_drops_early++;</span><br><span class="line">          av_frame_unref(frame);</span><br><span class="line">          got_picture = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> got_picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到获取到解码后的帧数据后，video_thread还额外加入了一个丢帧逻辑。framedrop如果用户不设置，那么默认值就是-1，用户设置后会有0和1两种情况。所以上面的条件的意思是当用户设置可以丢帧或者用户没设置这个参数但是当前的同步逻辑不是音频同步视频，就可以丢帧。ffplay的时间同步逻辑有三个选项：视频同步音频（AV_SYNC_AUDIO_MASTER），音频同步视频（AV_SYNC_VIDEO_MASTER），音视频同步外部时钟（AV_SYNC_EXTERNAL_CLOCK）。那么当程序允许丢帧时，什么时候才可以丢弃当前帧呢？程序首先计算了当前帧的显示时间点和主时钟的时间差diff，如果这个时间差还在可同步范围内，也就是小于AV_NOSYNC_THRESHOLD才进行接下来的判断。接下来判断diff是否小于上一帧的延时，frame_last_filter_delay，上一帧如果经过滤镜处理，会消耗额外的时间，这个时间计算出来被存入frame_last_filter_delay，如果diff小于这个值，说明当延时时间结束后，当前帧的显示时间点就已经过了，此时判断如果包序列号与时钟序列号是否相同，这里是为了保证在内容连续时才可丢帧；最后判断视频流包队列中如果还有包，则表示后续还有可显示的内容，那么当前帧就可以丢弃。所有条件满足后，丢帧数加一，释放当前帧的数据，将got_picture设置为0返回。这里是在解码成功放入FrameQueue之前丢帧的，所以对frame_drops_early增加一个计数，后面我们还会看到显示画面时的丢帧，那种情况是对frame_drops_late增加计数。</p><p>queue_picture函数的作用就是将数据放入FrameQueue，这里就不上代码了，单独抽离成一个函数可能只是因为需要设置的参数比较多，为了代码好看一点吧：）。</p><p>字幕流的解码线程subtitle_thread的实现更加简单，就是在一个无限循环中读取帧，然后将数据放入FrameQueue的合适位置；</p><p>到现在为止，还有有一个关键的函数我们还没有展开分析，就是decoder_decode_frame，这个函数用于从PacketQueue中读取包然后解码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">decoder_decode_frame</span><span class="params">(Decoder *d, AVFrame *frame, AVSubtitle *sub)</span> &#123;</span><br><span class="line">  <span class="type">int</span> ret = AVERROR(EAGAIN);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">//音视频流解码</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//从PacketQueue中读包</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//字幕流解码</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中有一个无限循环，循环中的代码按照任务划分可以分为三部分：1.音视频流解码；2.从PacketQueue中读包；3.字幕流解码。</p><p>音视频流的解码和字幕流的解码没有放在一起，是因为字幕流的解码方式与音视频流不同。我们先看音视频流的解码流程:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//音视频流解码</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;serial == d-&gt;pkt_serial) &#123;<span class="comment">//当前包的序列号与解码器中注册的包队列序列号一致时（内容连续）才进行解码</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;abort_request)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (d-&gt;avctx-&gt;codec_type) &#123;</span><br><span class="line">          <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">            ret = avcodec_receive_frame(d-&gt;avctx, frame);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (decoder_reorder_pts == <span class="number">-1</span>) &#123;<span class="comment">//解码器对pts重新排序，0表示关，1表示开，-1表示自动</span></span><br><span class="line">                frame-&gt;pts = frame-&gt;best_effort_timestamp;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!decoder_reorder_pts) &#123;</span><br><span class="line">                frame-&gt;pts = frame-&gt;pkt_dts;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">            ret = avcodec_receive_frame(d-&gt;avctx, frame);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              AVRational tb = (AVRational)&#123;<span class="number">1</span>, frame-&gt;sample_rate&#125;;<span class="comment">//计算音频流的time_base</span></span><br><span class="line">              <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE)</span><br><span class="line">                frame-&gt;pts = av_rescale_q(frame-&gt;pts, d-&gt;avctx-&gt;pkt_timebase, tb);</span><br><span class="line">              <span class="comment">//转换time_base,按照播放时time_base重新计算pts</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (d-&gt;next_pts != AV_NOPTS_VALUE)</span><br><span class="line">                frame-&gt;pts = av_rescale_q(d-&gt;next_pts, d-&gt;next_pts_tb, tb);</span><br><span class="line">              <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">                d-&gt;next_pts = frame-&gt;pts + frame-&gt;nb_samples;</span><br><span class="line">                d-&gt;next_pts_tb = tb;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret == AVERROR_EOF) &#123;</span><br><span class="line">          d-&gt;finished = d-&gt;pkt_serial;</span><br><span class="line">          avcodec_flush_buffers(d-&gt;avctx);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">while</span> (ret != AVERROR(EAGAIN));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ffmpeg的解码库用于音视频解码的函数是avcodec_send_packet()和avcodec_receive_frame(),前者用户向解码器发送一个AVPacket数据用于解码，后者从解码器中读取解码后生成的AVFrame数据。了解了音视频流解码的原理后，我们再结合注释看代码，就很好理解了，音视频流解码成功后都对帧的pts进行了设置。音频流的pts设置比较有意思，转换了一个时基，相当于时间单位，算出一个新的pts。在pts设置成功后，会计算下一帧的pts：next_pts，这个值用于当解析到的frame中不含pts时充当备份，每一帧对应的next_pts都是在解析上一帧的时候计算出来的。</p><p>剩下的代码是用来判断是否在此处退出函数的。第一种情况是已经解析到流末尾了，将当前包序列号赋值给finished然后清空解码器缓存。第二种情况是ret&gt;&#x3D;0，当成功解析一帧数据时，ret值会被设置等于0。</p><p>接下来分析第二部分读取包的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">do</span> &#123;<span class="comment">//从PacketQueue中读取新的包</span></span><br><span class="line">  <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;nb_packets == <span class="number">0</span>)</span><br><span class="line">    SDL_CondSignal(d-&gt;empty_queue_cond);<span class="comment">//如果包队列空了，通知等待的读线程可以继续读了</span></span><br><span class="line">  <span class="keyword">if</span> (d-&gt;packet_pending) &#123;<span class="comment">//有未决的包，所以本次循环不用再读新的包了</span></span><br><span class="line">    d-&gt;packet_pending = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> old_serial = d-&gt;pkt_serial;</span><br><span class="line">    <span class="keyword">if</span> (packet_queue_get(d-&gt;<span class="built_in">queue</span>, d-&gt;pkt, <span class="number">1</span>, &amp;d-&gt;pkt_serial) &lt; <span class="number">0</span>)<span class="comment">//从队列中读一个包</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (old_serial != d-&gt;pkt_serial) &#123;<span class="comment">//新读到的包跟之前解析的包不是连续的内容？</span></span><br><span class="line">      avcodec_flush_buffers(d-&gt;avctx);<span class="comment">//刷新解码器缓存</span></span><br><span class="line">      d-&gt;finished = <span class="number">0</span>;<span class="comment">//解码还没结束</span></span><br><span class="line">      d-&gt;next_pts = d-&gt;start_pts;<span class="comment">//更新用于备份的next_pts和next_pts_tb</span></span><br><span class="line">      d-&gt;next_pts_tb = d-&gt;start_pts_tb;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;serial == d-&gt;pkt_serial)<span class="comment">//再校验一次内容的连续性</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  av_packet_unref(d-&gt;pkt);<span class="comment">//如果读到的包序列号与解码器关联的队列序列号不一致，丢弃包内容，下个循环继续读</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>最后分析字幕流解码代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (d-&gt;avctx-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) &#123;<span class="comment">//字幕流解码</span></span><br><span class="line">      <span class="type">int</span> got_frame = <span class="number">0</span>;</span><br><span class="line">      ret = avcodec_decode_subtitle2(d-&gt;avctx, sub, &amp;got_frame, d-&gt;pkt);<span class="comment">//解析字幕流AVPacket</span></span><br><span class="line">      <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = AVERROR(EAGAIN);<span class="comment">//读取失败，下次循环重读</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (got_frame &amp;&amp; !d-&gt;pkt-&gt;data) &#123;</span><br><span class="line">          d-&gt;packet_pending = <span class="number">1</span>;<span class="comment">//拿到数据了，data空了，为了防止有未读出的数据，下次循环还用这个空包去刷新解码器，直到got_frame==0</span></span><br><span class="line">        &#125;</span><br><span class="line">        ret = got_frame ? <span class="number">0</span> : (d-&gt;pkt-&gt;data ? AVERROR(EAGAIN) : AVERROR_EOF);<span class="comment">//拿到数据，ret=0，下次循环函数就返回；如果没拿到数据，但是包的data不为空，下次循环不退出，重新读；//如果又没拿到数据，data也空了，说明到达流末尾了</span></span><br><span class="line">      &#125;</span><br><span class="line">      av_packet_unref(d-&gt;pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是其他流，就将AVPacket发送给解码器</span></span><br><span class="line">      <span class="keyword">if</span> (avcodec_send_packet(d-&gt;avctx, d-&gt;pkt) == AVERROR(EAGAIN)) &#123;</span><br><span class="line">        av_log(d-&gt;avctx, AV_LOG_ERROR, <span class="string">&quot;Receive_frame and send_packet both returned EAGAIN, which is an API violation.\n&quot;</span>);</span><br><span class="line">        d-&gt;packet_pending = <span class="number">1</span>;<span class="comment">//解码器里的数据还未被读出，下次循环不用再发送新包了</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        av_packet_unref(d-&gt;pkt);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>字幕流的解析通过avcodec_decode_subtitle2()函数完成，如果成功解析到数据，数据会被存放到第二个参数sub，第三个参数got_frame会被设置为非零值。某些解码器并不能实时输出所有解码后的数据，此时需要不停发送一个pkt-&gt;data为NULL的包去刷新。</p><p>由于音视频解码器和字幕解码器都可能存在解码器中的数据未读取完暂时不能接受新的AVPacket的情况，所以需要通过packet_pending这个标志位告诉程序下次循环用不用给解码器发送新的AVPacket。</p><p>到此decoder_decode_frame全部分析完毕，解码线程的所有逻辑也分析结束。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（五）：读线程</title>
      <link href="/2022/12/01/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%AF%BB%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/12/01/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%AF%BB%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>在分析main函数的时候我们已经提到过stream_open函数，本章我们开始对其进行分析。stream_open函数的源码结构一目了然，主要做了如下几件事：</p><p>1.创建一个VideoState结构体指针变量is，为其分配内存并以0初始化；</p><p>2.为创建好的结构体变量的成员赋初值，stream_open函数接受两个参数，第一个参数是文件名，第二个参数是用户指定的文件格式，也在这一步赋给相应的结构体成员；</p><p>3.初始化结构体变量中对应视频流，音频流，字幕流的三个FrameQueue，其中视频流和音频流的keep_last值被设置为1，这个值的具体作用我们上一章已经介绍过；</p><p>4.初始化结构体变量中对应视频流，音频流，字幕流的三个PacketQueue；</p><p>5.创建continue_read_thread这个用于读写同步的条件变量；</p><p>6.初始化三个流对应的clock时钟结构体；</p><p>7.设置音量；</p><p>8.打开read_thread线程。</p><p>可以看到stream_open函数主要做的事情就是创建并初始化VideoState结构体变量，初始化完成后打开read_thread线程，然后函数就退出了。从代码中看除了调用相应的函数初始化FrameQueue和PacketQueue以外，函数初始化了三个时钟结构体，分别对应三个流。ffplay为每个流分配了一个Clock结构体类型的变量，其中包含了时间，偏移量，时钟速度等等一些成员，所有成员类型都是double或int。时钟的作用在后面我们分析到音视频同步的时候会详细介绍，现在只需要知道stream_open函数中完成了三个流对应时钟的初始化即可。</p><p>接下来我们看一下read_thread主要做了哪些事。根据任务类型我们可以将read_thread的代码氛围三部分：打开文件，打开流，主循环读流。</p><p>首先我们看一下打开文件部分的代码，我精简掉了一些变量声明，错误检查，打印信息的代码，只保留了重要部分以方便阅读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> st_index[AVMEDIA_TYPE_NB];<span class="comment">//存储各个类型的流对应的序号</span></span><br><span class="line"> <span class="built_in">memset</span>(st_index, <span class="number">-1</span>, <span class="keyword">sizeof</span>(st_index));</span><br><span class="line"> pkt = av_packet_alloc();<span class="comment">//创建一个默认初始化的AVPacket</span></span><br><span class="line"> ic = avformat_alloc_context();<span class="comment">//创建一个默认初始化的AVFormatContext</span></span><br><span class="line"> ic-&gt;interrupt_callback.callback = decode_interrupt_cb;<span class="comment">//中断回调函数，当ffmpeg的io库在执行阻塞操作时，这个函数会被间歇性的调用，当函数的返回值为1时，io库会终止阻塞操作</span></span><br><span class="line"> ic-&gt;interrupt_callback.opaque = is;</span><br><span class="line"> <span class="keyword">if</span> (!av_dict_get(format_opts, <span class="string">&quot;scan_all_pmts&quot;</span>, <span class="literal">NULL</span>, AV_DICT_MATCH_CASE)) &#123;<span class="comment">//设置mpegts的scan_all_pmts选项，该选项的含义是扫描并组合所有ts流的Program Map Table</span></span><br><span class="line">   av_dict_set(&amp;format_opts, <span class="string">&quot;scan_all_pmts&quot;</span>, <span class="string">&quot;1&quot;</span>, AV_DICT_DONT_OVERWRITE);<span class="comment">//所以这里是针对mpegts封装单独设置的选项</span></span><br><span class="line">   scan_all_pmts_set = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> err = avformat_open_input(&amp;ic, is-&gt;filename, is-&gt;iformat, &amp;format_opts);<span class="comment">//打开文件，传入AVFormatContext变量，文件名和格式，以及保存选项信息的字典format_opts,文件打开后，format_opts会被擦除并且写入未被发现的选项</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (scan_all_pmts_set)</span><br><span class="line">   av_dict_set(&amp;format_opts, <span class="string">&quot;scan_all_pmts&quot;</span>, <span class="literal">NULL</span>, AV_DICT_MATCH_CASE);<span class="comment">//打开文件后将scan_all_pmts选项重置</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> ((t = av_dict_get(format_opts, <span class="string">&quot;&quot;</span>, <span class="literal">NULL</span>, AV_DICT_IGNORE_SUFFIX))) &#123;<span class="comment">//如果t不为NULL，说明打开文件时设置的选项中有不被支持的选项</span></span><br><span class="line">   av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Option %s not found.\n&quot;</span>, t-&gt;key);</span><br><span class="line">   ret = AVERROR_OPTION_NOT_FOUND;</span><br><span class="line">   <span class="keyword">goto</span> fail;</span><br><span class="line"> &#125;</span><br><span class="line"> is-&gt;ic = ic;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (genpts)</span><br><span class="line">   ic-&gt;flags |= AVFMT_FLAG_GENPTS;</span><br><span class="line"></span><br><span class="line"> av_format_inject_global_side_data(ic);<span class="comment">//将全局的side data注入到每个流的下一个AVPacket中</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (find_stream_info) &#123;<span class="comment">//校验用户指定的codec选项是否支持</span></span><br><span class="line">   AVDictionary **opts = setup_find_stream_info_opts(ic, codec_opts);</span><br><span class="line">   <span class="type">int</span> orig_nb_streams = ic-&gt;nb_streams;</span><br><span class="line"></span><br><span class="line">   err = avformat_find_stream_info(ic, opts);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; orig_nb_streams; i++)</span><br><span class="line">     av_dict_free(&amp;opts[i]);</span><br><span class="line">   av_freep(&amp;opts);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     av_log(<span class="literal">NULL</span>, AV_LOG_WARNING,</span><br><span class="line">            <span class="string">&quot;%s: could not find codec parameters\n&quot;</span>, is-&gt;filename);</span><br><span class="line">     ret = <span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">goto</span> fail;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (ic-&gt;pb)</span><br><span class="line">   ic-&gt;pb-&gt;eof_reached = <span class="number">0</span>; <span class="comment">// FIXME hack, ffplay maybe should not use avio_feof() to test for the end</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (seek_by_bytes &lt; <span class="number">0</span>)<span class="comment">//当封装格式允许时间戳不连续且不是ogg格式时，以byte查找，否则以时间查找</span></span><br><span class="line">   seek_by_bytes = !!(ic-&gt;iformat-&gt;flags &amp; AVFMT_TS_DISCONT) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;ogg&quot;</span>, ic-&gt;iformat-&gt;name);</span><br><span class="line"></span><br><span class="line"> is-&gt;max_frame_duration = (ic-&gt;iformat-&gt;flags &amp; AVFMT_TS_DISCONT) ? <span class="number">10.0</span> : <span class="number">3600.0</span>;<span class="comment">//每一帧最长时序时间，如果封装格式允许时间戳不连续时，为10秒，否则为3600秒。</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!window_title &amp;&amp; (t = av_dict_get(ic-&gt;metadata, <span class="string">&quot;title&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>)))</span><br><span class="line">   window_title = av_asprintf(<span class="string">&quot;%s - %s&quot;</span>, t-&gt;value, input_filename);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* if seeking requested, we execute it */</span></span><br><span class="line"> <span class="keyword">if</span> (start_time != AV_NOPTS_VALUE) &#123;</span><br><span class="line">   <span class="type">int64_t</span> timestamp;</span><br><span class="line"></span><br><span class="line">   timestamp = start_time;</span><br><span class="line">   <span class="comment">/* add the stream start time */</span></span><br><span class="line">   <span class="keyword">if</span> (ic-&gt;start_time != AV_NOPTS_VALUE)</span><br><span class="line">     timestamp += ic-&gt;start_time;</span><br><span class="line">   ret = avformat_seek_file(ic, <span class="number">-1</span>, INT64_MIN, timestamp, INT64_MAX, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;%s: could not seek to position %0.3f\n&quot;</span>,</span><br><span class="line">            is-&gt;filename, (<span class="type">double</span>)timestamp / AV_TIME_BASE);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> is-&gt;realtime = is_realtime(ic);<span class="comment">//是否是实时流</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (show_status)</span><br><span class="line">   av_dump_format(ic, <span class="number">0</span>, is-&gt;filename, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;<span class="comment">//判断用户指定的流是否可用，如果可用将流的序号设置到数组st_index相应的成员中</span></span><br><span class="line">   AVStream *st = ic-&gt;streams[i];</span><br><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">AVMediaType</span> <span class="title">type</span> =</span> st-&gt;codecpar-&gt;codec_type;</span><br><span class="line">   st-&gt;discard = AVDISCARD_ALL;</span><br><span class="line">   <span class="keyword">if</span> (type &gt;= <span class="number">0</span> &amp;&amp; wanted_stream_spec[type] &amp;&amp; st_index[type] == <span class="number">-1</span>)</span><br><span class="line">     <span class="keyword">if</span> (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) &gt; <span class="number">0</span>)</span><br><span class="line">       st_index[type] = i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; AVMEDIA_TYPE_NB; i++) &#123;</span><br><span class="line">   <span class="keyword">if</span> (wanted_stream_spec[i] &amp;&amp; st_index[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">     av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Stream specifier %s does not match any %s stream\n&quot;</span>, wanted_stream_spec[i], av_get_media_type_string(i));</span><br><span class="line">     st_index[i] = INT_MAX;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//结合用户指定的流查找出最好的流最为最终解析的流</span></span><br><span class="line"> <span class="keyword">if</span> (!video_disable)</span><br><span class="line">   st_index[AVMEDIA_TYPE_VIDEO] =</span><br><span class="line">       av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,</span><br><span class="line">                           st_index[AVMEDIA_TYPE_VIDEO], <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (!audio_disable)</span><br><span class="line">   st_index[AVMEDIA_TYPE_AUDIO] =</span><br><span class="line">       av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,</span><br><span class="line">                           st_index[AVMEDIA_TYPE_AUDIO],</span><br><span class="line">                           st_index[AVMEDIA_TYPE_VIDEO],</span><br><span class="line">                           <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (!video_disable &amp;&amp; !subtitle_disable)</span><br><span class="line">   st_index[AVMEDIA_TYPE_SUBTITLE] =</span><br><span class="line">       av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,</span><br><span class="line">                           st_index[AVMEDIA_TYPE_SUBTITLE],</span><br><span class="line">                           (st_index[AVMEDIA_TYPE_AUDIO] &gt;= <span class="number">0</span> ?</span><br><span class="line">                            st_index[AVMEDIA_TYPE_AUDIO] :</span><br><span class="line">                            st_index[AVMEDIA_TYPE_VIDEO]),</span><br><span class="line">                           <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> is-&gt;show_mode = show_mode;</span><br><span class="line"> <span class="keyword">if</span> (st_index[AVMEDIA_TYPE_VIDEO] &gt;= <span class="number">0</span>) &#123;<span class="comment">//从视频流中获取画面宽高，依次设置默认窗口大小</span></span><br><span class="line">   AVStream *st = ic-&gt;streams[st_index[AVMEDIA_TYPE_VIDEO]];</span><br><span class="line">   AVCodecParameters *codecpar = st-&gt;codecpar;</span><br><span class="line">   AVRational sar = av_guess_sample_aspect_ratio(ic, st, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">if</span> (codecpar-&gt;width)</span><br><span class="line">     set_default_window_size(codecpar-&gt;width, codecpar-&gt;height, sar);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注释已经说明了大部分代码的用途，这部分代码做的事主要是打开文件，获取流信息，结合用户指定的流说明符选取最优的流用于接下来的步骤。打开文件和获取流信息都是通过ffmpeg库函数实现的，没有复杂的逻辑，结合相关函数的注释很好理解。占用篇幅最大也是最不好理解的部分就是选取最优的流的相关操作。</p><p>首先定义了一个的数组:int st_index[AVMEDIA_TYPE_NB],这里涉及到一个枚举类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AVMediaType</span> &#123;</span></span><br><span class="line">    AVMEDIA_TYPE_UNKNOWN = <span class="number">-1</span>,  <span class="comment">///&lt; Usually treated as AVMEDIA_TYPE_DATA</span></span><br><span class="line">    AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    AVMEDIA_TYPE_AUDIO,</span><br><span class="line">    AVMEDIA_TYPE_DATA,          <span class="comment">///&lt; Opaque data information usually continuous</span></span><br><span class="line">    AVMEDIA_TYPE_SUBTITLE,</span><br><span class="line">    AVMEDIA_TYPE_ATTACHMENT,    <span class="comment">///&lt; Opaque data information usually sparse</span></span><br><span class="line">    AVMEDIA_TYPE_NB</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用媒体类型作为数组索引，数组元素为int，数组元素是如何被赋值的呢？看下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;<span class="comment">//判断用户指定的流是否可用，如果可用将流的序号设置到数组st_index相应的成员中</span></span><br><span class="line">  AVStream *st = ic-&gt;streams[i];</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">AVMediaType</span> <span class="title">type</span> =</span> st-&gt;codecpar-&gt;codec_type;</span><br><span class="line">  st-&gt;discard = AVDISCARD_ALL;</span><br><span class="line">  <span class="keyword">if</span> (type &gt;= <span class="number">0</span> &amp;&amp; wanted_stream_spec[type] &amp;&amp; st_index[type] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) &gt; <span class="number">0</span>)</span><br><span class="line">      st_index[type] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; AVMEDIA_TYPE_NB; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (wanted_stream_spec[i] &amp;&amp; st_index[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Stream specifier %s does not match any %s stream\n&quot;</span>, wanted_stream_spec[i], av_get_media_type_string(i));</span><br><span class="line">    st_index[i] = INT_MAX;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中有一个特殊的数组wanted_stream_spec[],从数组的定义上我们会发现，这个数组的大小也是AVMEDIA_TYPE_NB，数组元素类型是const char*。这个数组中存储的是用户指定的流说明符，如wanted_stream_spec[AVMEDIA_TYPE_AUDIO]的值为”1“表示用户指定使用第二个音频流，wanted_stream_spec[AVMEDIA_TYPE_VIDEO]的值为”2“表示用户指定使用第三个视频流等。使用avformat_match_stream_specifier函数进行匹配，如果程序解析出的流与用户指定的流匹配，那么就将st_index[type]设置为这个流的序号，例如通过-vst 1指定第二个视频流，而文件解析出的第二个视频流对应的序号i为3，那么st_index[AVMEDIA_TYPE_VIDEO]的值就会被设置为3，如果没有匹配到，比如文件中只有一个视频流的时候，相应的值就不会被设置。还有一个逻辑就是st_index[type]一旦被设置过就不会再对同类型的流进行比对了。</p><p>接下来会将wanted_stream_spec和st_index进行比对，如果相同索引位置前者有值，而后者的值还是默认值-1，则表示用户指定的流没有被匹配到，随后后者的值会被设置为INT_MAX。</p><p>通过以上步骤，有可能某一类型的流未被指定，例如上面说到的，用户使用-vst 1指定第二个视频流，但是文件中却只含有一个视频流，这种情况下st_index[AVMEDIA_TYPE_VIDEO]会被设置为INT_MAX。所以就需要将合适的流序号赋给他，ffplay使用的方式是调用av_find_best_stream函数来找到最佳匹配，它会根据传入的参数选择一个最接近用户期望的流。</p><p>至此，st_index[]中已经保存了最优的流的序号，接下来就是打开这些流开始读取数据了。打开流的代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (st_index[AVMEDIA_TYPE_AUDIO] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ret = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (st_index[AVMEDIA_TYPE_VIDEO] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (is-&gt;show_mode == SHOW_MODE_NONE)</span><br><span class="line">    is-&gt;show_mode = ret &gt;= <span class="number">0</span> ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (st_index[AVMEDIA_TYPE_SUBTITLE] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>stream_component_open函数的返回值0表示成功，负数表示打开失败，在打开视频流的时候对返回值进行了一下判断，并且设置相应的显示模式。除此之外，所有流的打开都是通过stream_component_open函数完成的。我们接下来分析stream_component_open函数都做了什么工作。</p><p>首先stream_component_open根据传进来的流序号从AVFormatContext中获取到对应的信息，并用这些信息结合用户指定的参数完成了解码器的创建。关键代码注释如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">avctx = avcodec_alloc_context3(<span class="literal">NULL</span>);<span class="comment">//以默认值创建一个AVCodecContext</span></span><br><span class="line">...</span><br><span class="line"> ret = avcodec_parameters_to_context(avctx, ic-&gt;streams[stream_index]-&gt;codecpar);<span class="comment">//将AVFormatContext中读取到的codec相关的参数复制给AVCodecContext对应的成员</span></span><br><span class="line"> ...</span><br><span class="line"> codec = avcodec_find_decoder(avctx-&gt;codec_id);<span class="comment">//根据codec_id查找解码器，codec_id是通过之前的avcodec_parameters_to_context函数从流的codecpar中获取到的</span></span><br><span class="line">...  </span><br><span class="line"> <span class="keyword">if</span> (forced_codec_name)<span class="comment">//如果用户指定了解码器名称，根据名称搜索解码器</span></span><br><span class="line">   codec = avcodec_find_decoder_by_name(forced_codec_name);</span><br><span class="line">...</span><br><span class="line"> avctx-&gt;codec_id = codec-&gt;id;<span class="comment">//更新最终获取到的解码器id</span></span><br><span class="line">...</span><br><span class="line"> <span class="keyword">if</span> ((ret = avcodec_open2(avctx, codec, &amp;opts)) &lt; <span class="number">0</span>) &#123;<span class="comment">//设置好解码器选项后打开解码器</span></span><br><span class="line">   <span class="keyword">goto</span> fail;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打开解码器后针对不同的流类型做不同的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (avctx-&gt;codec_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">      sample_rate    = avctx-&gt;sample_rate;</span><br><span class="line">        nb_channels    = avctx-&gt;channels;</span><br><span class="line">        channel_layout = avctx-&gt;channel_layout;</span><br><span class="line">      <span class="comment">/* prepare audio output */</span></span><br><span class="line">      <span class="keyword">if</span> ((ret = audio_open(is, channel_layout, nb_channels, sample_rate, &amp;is-&gt;audio_tgt)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">      is-&gt;audio_hw_buf_size = ret;</span><br><span class="line">      is-&gt;audio_src = is-&gt;audio_tgt;</span><br><span class="line">      is-&gt;audio_buf_size  = <span class="number">0</span>;</span><br><span class="line">      is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* init averaging filter */</span></span><br><span class="line">      is-&gt;audio_diff_avg_coef  = <span class="built_in">exp</span>(<span class="built_in">log</span>(<span class="number">0.01</span>) / AUDIO_DIFF_AVG_NB);</span><br><span class="line">      is-&gt;audio_diff_avg_count = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">/* since we do not have a precise anough audio FIFO fullness,</span></span><br><span class="line"><span class="comment">         we correct audio sync only if larger than this threshold */</span></span><br><span class="line">      is-&gt;audio_diff_threshold = (<span class="type">double</span>)(is-&gt;audio_hw_buf_size) / is-&gt;audio_tgt.bytes_per_sec;</span><br><span class="line"></span><br><span class="line">      is-&gt;audio_stream = stream_index;</span><br><span class="line">      is-&gt;audio_st = ic-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_init(&amp;is-&gt;auddec, avctx, &amp;is-&gt;audioq, is-&gt;continue_read_thread)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">      <span class="keyword">if</span> ((is-&gt;ic-&gt;iformat-&gt;flags &amp; (AVFMT_NOBINSEARCH | AVFMT_NOGENSEARCH | AVFMT_NO_BYTE_SEEK)) &amp;&amp; !is-&gt;ic-&gt;iformat-&gt;read_seek) &#123;</span><br><span class="line">        is-&gt;auddec.start_pts = is-&gt;audio_st-&gt;start_time;</span><br><span class="line">        is-&gt;auddec.start_pts_tb = is-&gt;audio_st-&gt;time_base;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_start(&amp;is-&gt;auddec, audio_thread, <span class="string">&quot;audio_decoder&quot;</span>, is)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      SDL_PauseAudioDevice(audio_dev, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">      is-&gt;video_stream = stream_index;</span><br><span class="line">      is-&gt;video_st = ic-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_init(&amp;is-&gt;viddec, avctx, &amp;is-&gt;videoq, is-&gt;continue_read_thread)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_start(&amp;is-&gt;viddec, video_thread, <span class="string">&quot;video_decoder&quot;</span>, is)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      is-&gt;queue_attachments_req = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_SUBTITLE:</span><br><span class="line">      is-&gt;subtitle_stream = stream_index;</span><br><span class="line">      is-&gt;subtitle_st = ic-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_init(&amp;is-&gt;subdec, avctx, &amp;is-&gt;subtitleq, is-&gt;continue_read_thread)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_start(&amp;is-&gt;subdec, subtitle_thread, <span class="string">&quot;subtitle_decoder&quot;</span>, is)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里我删除了音频滤镜的代码，因为滤镜只是改变了相关参数的值，在分析代码逻辑的时候暂时注释掉这部分代码比较不容易混淆。</p><p>从代码中我们很容易发现视频流和字幕流的处理逻辑是完全一致的，都是初始化一个Decoder然后开启解码线程，音频则要复杂的多，所以我们先从视频流和字幕流的处理开始分析，最后再分析音频流的处理。</p><p>我们暂时不需要关心Decoder的工作原理，只需要知道decoder_init函数用于初始化一个Decoder结构体变量，而Decoder是对AVCodecContext的封装，加入了一些其他参数。而decoder_start所做的工作就是开启流对应的PacketQueue，表示已经可以向队列中写入数据了。然后开启对应的解码线程，如视频流是video_thread，字幕流是subtitle_thread。各个流对应的解码线程执行的具体工作我们会在后面的章节中详细分析。</p><p>接着是音频流的处理，从代码中我们可以发现，音频流的处理与视频流和字幕流最大的不同是在执行decoder_init之前，先是调用了一个名为audio_open的函数，然后设置了VideoState中很多相应的音频参数。我们先来看audio_open函数做了什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">audio_open</span><span class="params">(<span class="type">void</span> *opaque, <span class="type">int64_t</span> wanted_channel_layout, <span class="type">int</span> wanted_nb_channels, <span class="type">int</span> wanted_sample_rate, <span class="keyword">struct</span> AudioParams *audio_hw_params)</span></span><br><span class="line">&#123;</span><br><span class="line">  SDL_AudioSpec wanted_spec, spec;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *env;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> next_nb_channels[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> next_sample_rates[] = &#123;<span class="number">0</span>, <span class="number">44100</span>, <span class="number">48000</span>, <span class="number">96000</span>, <span class="number">192000</span>&#125;;</span><br><span class="line">  <span class="type">int</span> next_sample_rate_idx = FF_ARRAY_ELEMS(next_sample_rates) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  env = SDL_getenv(<span class="string">&quot;SDL_AUDIO_CHANNELS&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (env) &#123;</span><br><span class="line">    wanted_nb_channels = atoi(env);</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!wanted_channel_layout || wanted_nb_channels != av_get_channel_layout_nb_channels(wanted_channel_layout)) &#123;</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);</span><br><span class="line">    wanted_channel_layout &amp;= ~AV_CH_LAYOUT_STEREO_DOWNMIX;</span><br><span class="line">  &#125;</span><br><span class="line">  wanted_nb_channels = av_get_channel_layout_nb_channels(wanted_channel_layout);</span><br><span class="line">  wanted_spec.channels = wanted_nb_channels;</span><br><span class="line">  wanted_spec.freq = wanted_sample_rate;</span><br><span class="line">  <span class="keyword">if</span> (wanted_spec.freq &lt;= <span class="number">0</span> || wanted_spec.channels &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Invalid sample rate or channel count!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (next_sample_rate_idx &amp;&amp; next_sample_rates[next_sample_rate_idx] &gt;= wanted_spec.freq)</span><br><span class="line">    next_sample_rate_idx--;</span><br><span class="line">  wanted_spec.format = AUDIO_S16SYS;</span><br><span class="line">  wanted_spec.silence = <span class="number">0</span>;</span><br><span class="line">  wanted_spec.samples = FFMAX(SDL_AUDIO_MIN_BUFFER_SIZE, <span class="number">2</span> &lt;&lt; av_log2(wanted_spec.freq / SDL_AUDIO_MAX_CALLBACKS_PER_SEC));</span><br><span class="line">  wanted_spec.callback = sdl_audio_callback;</span><br><span class="line">  wanted_spec.userdata = opaque;</span><br><span class="line">  <span class="keyword">while</span> (!(audio_dev = SDL_OpenAudioDevice(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;wanted_spec, &amp;spec, SDL_AUDIO_ALLOW_FREQUENCY_CHANGE | SDL_AUDIO_ALLOW_CHANNELS_CHANGE))) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;SDL_OpenAudio (%d channels, %d Hz): %s\n&quot;</span>,</span><br><span class="line">           wanted_spec.channels, wanted_spec.freq, SDL_GetError());</span><br><span class="line">    wanted_spec.channels = next_nb_channels[FFMIN(<span class="number">7</span>, wanted_spec.channels)];</span><br><span class="line">    <span class="keyword">if</span> (!wanted_spec.channels) &#123;</span><br><span class="line">      wanted_spec.freq = next_sample_rates[next_sample_rate_idx--];</span><br><span class="line">      wanted_spec.channels = wanted_nb_channels;</span><br><span class="line">      <span class="keyword">if</span> (!wanted_spec.freq) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">&quot;No more combinations to try, audio open failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(wanted_spec.channels);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (spec.format != AUDIO_S16SYS) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">           <span class="string">&quot;SDL advised audio format %d is not supported!\n&quot;</span>, spec.format);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (spec.channels != wanted_spec.channels) &#123;</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(spec.channels);</span><br><span class="line">    <span class="keyword">if</span> (!wanted_channel_layout) &#123;</span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">             <span class="string">&quot;SDL advised channel count %d is not supported!\n&quot;</span>, spec.channels);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  audio_hw_params-&gt;fmt = AV_SAMPLE_FMT_S16;</span><br><span class="line">  audio_hw_params-&gt;freq = spec.freq;</span><br><span class="line">  audio_hw_params-&gt;channel_layout = wanted_channel_layout;</span><br><span class="line">  audio_hw_params-&gt;channels =  spec.channels;</span><br><span class="line">  audio_hw_params-&gt;frame_size = av_samples_get_buffer_size(<span class="literal">NULL</span>, audio_hw_params-&gt;channels, <span class="number">1</span>, audio_hw_params-&gt;fmt, <span class="number">1</span>);</span><br><span class="line">  audio_hw_params-&gt;bytes_per_sec = av_samples_get_buffer_size(<span class="literal">NULL</span>, audio_hw_params-&gt;channels, audio_hw_params-&gt;freq, audio_hw_params-&gt;fmt, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (audio_hw_params-&gt;bytes_per_sec &lt;= <span class="number">0</span> || audio_hw_params-&gt;frame_size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;av_samples_get_buffer_size failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> spec.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先从入参开始看，channel_layout, nb_channels, sample_rate都是从解码器对应的AVCodecContext中获取的，分别代表音频的通道布局，通道数和采样率，&amp;is-&gt;audio_tgt是一个AudioParams结构体变量的地址，该变量用于存储硬件支持的音频参数。</p><p>函数一开始先对传入的通道布局和通道数进行匹配，结合环境变量计算出合适的通道布局和通道数，然后根据传入的采样率算出一个不大于它的符合标准的采样率。</p><p>接下来使用SDL库函数SDL_OpenAudioDevice()打开音频设备。这里简单说一下这个函数的原理，函数的第一个参数类型为const char*，用来指定设备ID，这里设置为NULL,表示自动选择，第二个函数类型为int，为0时表示打开设备用于播放，非零时表示打开设备用于录音，第三个参数类型是 const SDL_AudioSpec*，存储用户指定的音频参数，第四个参数类型是SDL_AudioSpec*，存储函数执行成功后实际设置的音频参数，最后一个参数是标志位，用于指定那些参数可以被修改，这里我们设置的是允许修改频率和通道数。该函数返回0表示失败，大于0表示成功并且返回值为音频设备id。如果打开设备不成功，函数会修改通道数和采样率并尝试重新打开设备，当经过计算后的采样率为0时，函数返回-1。打开设备成功后，相应的音频参数会被赋给audio_tgt相应的字段，然后函数返回音频缓冲区的大小值。还有一个我们不能忽视的函数，作为第三个参数SDL_AudioSpec中callback成员传入的sdl_audio_callback函数。sdl音频输出的工作原理是这样的，当成功打开音频设备时，音频输出是暂停的，需要手动调用SDL_PauseAudioDevice()函数让音频设备开始工作，当音频设备开始工作的时候会间歇的调用SDL_AudioSpec中的callback函数来”拉取“音频数据写入音频设备，所以callback函数的作用就是提供音频数据。我们看一下ffplay的sdl_audio_callback函数是怎么写的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sdl_audio_callback</span><span class="params">(<span class="type">void</span> *opaque, Uint8 *stream, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  VideoState *is = opaque;</span><br><span class="line">  <span class="type">int</span> audio_size, len1;</span><br><span class="line"></span><br><span class="line">  audio_callback_time = av_gettime_relative();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;<span class="comment">//如果程序当前缓冲区中没有数据，就解析一帧数据</span></span><br><span class="line">      audio_size = audio_decode_frame(is);</span><br><span class="line">      <span class="keyword">if</span> (audio_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* if error, just output silence */</span></span><br><span class="line">        is-&gt;audio_buf = <span class="literal">NULL</span>;</span><br><span class="line">        is-&gt;audio_buf_size = SDL_AUDIO_MIN_BUFFER_SIZE / is-&gt;audio_tgt.frame_size * is-&gt;audio_tgt.frame_size;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;show_mode != SHOW_MODE_VIDEO)<span class="comment">//如果当前的显示模式不是视频模式，将音频数据进行图形化显示</span></span><br><span class="line">          update_sample_display(is, (<span class="type">int16_t</span> *)is-&gt;audio_buf, audio_size);</span><br><span class="line">        is-&gt;audio_buf_size = audio_size;</span><br><span class="line">      &#125;</span><br><span class="line">      is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<span class="comment">//计算写入数据的长度</span></span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len)</span><br><span class="line">      len1 = len;</span><br><span class="line">    <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf &amp;&amp; is-&gt;audio_volume == SDL_MIX_MAXVOLUME)<span class="comment">//当不静音且audio_buf有效时才输出数据，如果音量为SDL_MIX_MAXVOLUME，直接输出数据</span></span><br><span class="line">      <span class="built_in">memcpy</span>(stream, (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">memset</span>(stream, <span class="number">0</span>, len1);</span><br><span class="line">      <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf)<span class="comment">//否则混合音频数据以AUDIO_S16SYS格式输出</span></span><br><span class="line">        SDL_MixAudioFormat(stream, (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, AUDIO_S16SYS, len1, is-&gt;audio_volume);</span><br><span class="line">    &#125;</span><br><span class="line">    len -= len1;</span><br><span class="line">    stream += len1;</span><br><span class="line">    is-&gt;audio_buf_index += len1;</span><br><span class="line">  &#125;</span><br><span class="line">  is-&gt;audio_write_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">  <span class="comment">/* Let&#x27;s assume the audio driver that is used by SDL has two periods. */</span></span><br><span class="line">  <span class="keyword">if</span> (!isnan(is-&gt;audio_clock)) &#123;<span class="comment">//更新时钟</span></span><br><span class="line">    set_clock_at(&amp;is-&gt;audclk, is-&gt;audio_clock - (<span class="type">double</span>)(<span class="number">2</span> * is-&gt;audio_hw_buf_size + is-&gt;audio_write_buf_size) / is-&gt;audio_tgt.bytes_per_sec, is-&gt;audio_clock_serial, audio_callback_time / <span class="number">1000000.0</span>);</span><br><span class="line">    sync_clock_to_slave(&amp;is-&gt;extclk, &amp;is-&gt;audclk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>callback的函数签名是统一的，opaque是用户数据，本程序中我们设置的是VideoState，stream表示音频数据缓冲区，len表示缓冲区大小。从代码中我们可以看到由于sdl音频这种通过回调函数”拉取“数据的方式，程序需要在callback中提供音频数据，所以音频数据从FrameQueue中的读取从此时就开始了，这一点跟视频流和字幕流都不一样，后两者是在主循环中需要显示画面的时候才从FrameQueue中读取的，而且是在主线程中操作。</p><p>还有一个关键函数audio_decode_frame(),作用是从FrameQueue中读取一帧数据然后解析成音频数据。因为其中涉及到音视频同步，所以我准备在后面分析音视频同步的时候详细分析这部分代码，目前就只需要知道这个函数的功能就可以了。</p><p>audio_open分析完了，我们再来看音频流处理剩下的代码，之前我们提到过，SDL打开音频设备后，设备默认是暂停的，需要手动取消暂停设备才会开始通过callback函数获取数据播放音频。这样做的目的是为了打开音频设备后让程序有时间做一些数据的初始化工作的。接下来的代码就是做一些播放前的准备操作，包括一些参数的赋值或初始化以及开启音频解码线程。在做完这些操作后，调用SDL_PauseAudioDevice(audio_dev, 0)解除音频设备的静音状态，其中audio_dev是SDL_OpenAudioDevice函数的返回值。</p><p>stream_component_open函数到此就分析完了，read_thread剩下的代码是一个无限循环，主要工作就是使用av_read_frame()从流读取包再放入PacketQueue。我们看一下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*针对网络流的开启或关闭操作*/</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;seek_req) &#123;<span class="comment">//seek到指定位置，此操作会刷新PacketQueue，导致serial+1，并且如果是暂停状态下seek，seek完成后会更新一帧画面</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;queue_attachments_req) &#123;<span class="comment">//如果视频流保存的是附加数据，如专辑封面等，读取数据后放入队列，然后放入空包以此告诉解码器已经到达当前流结尾</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果队列已满，暂时不要读取更多数据，等待最长10ms，就开始下一个循环 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*播放完后判断是直接退出还是循环播放*/</span></span><br><span class="line">    ... </span><br><span class="line">    ret = av_read_frame(ic, pkt);<span class="comment">//读取一个AVPacket</span></span><br><span class="line">  <span class="comment">/*如果读取失败，判断是到达了文件结尾还是io错误，如果到达了文件结尾，就往队列里放空包并设置标志位</span></span><br><span class="line"><span class="comment">  如果是io错误，则选择退出程序或结束线程，否则就等待最长10ms，继续下一次循环*/</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 判断数据是否在用户指定的播放时间范围内，如果不在就丢弃 */</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;audio_stream &amp;&amp; pkt_in_play_range) &#123;</span><br><span class="line">      packet_queue_put(&amp;is-&gt;audioq, pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;video_stream &amp;&amp; pkt_in_play_range</span><br><span class="line">        &amp;&amp; !(is-&gt;video_st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC)) &#123;</span><br><span class="line">      packet_queue_put(&amp;is-&gt;videoq, pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;subtitle_stream &amp;&amp; pkt_in_play_range) &#123;</span><br><span class="line">      packet_queue_put(&amp;is-&gt;subtitleq, pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      av_packet_unref(pkt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码经过精简，精简掉的代码功能已经通过注释写明，这里比较难理解的是判断数据是否在播放范围的判断条件，我们详细分析一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stream_start_time = ic-&gt;streams[pkt-&gt;stream_index]-&gt;start_time;</span><br><span class="line">    pkt_ts = pkt-&gt;pts == AV_NOPTS_VALUE ? pkt-&gt;dts : pkt-&gt;pts;</span><br><span class="line">    pkt_in_play_range = duration == AV_NOPTS_VALUE ||</span><br><span class="line">        (pkt_ts - (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : <span class="number">0</span>)) *</span><br><span class="line">            av_q2d(ic-&gt;streams[pkt-&gt;stream_index]-&gt;time_base) -</span><br><span class="line">            (<span class="type">double</span>)(start_time != AV_NOPTS_VALUE ? start_time : <span class="number">0</span>) / <span class="number">1000000</span></span><br><span class="line">            &lt;= ((<span class="type">double</span>)duration / <span class="number">1000000</span>);</span><br></pre></td></tr></table></figure><p>首先获取stream的开始时间stream_start_time，然后拿到该数据包的展示时间pkt_ts，如果pts不存在，就用解码时间dts代替。判断是否在播放范围是一个或操作，第一个条件很好理解，duration未定义时，一律认定在播放范围。第二个条件我们分开看，首先是展示时间pkt_ts减去流开始时间stream_start_time，这样我们可以认为我们获得了以stream_start_time为零点的一个时间点，我们用这个值减去start_time（start_time是用户设置的开始时间，这个时间也是一个以stream_start_time为零点的一个时间点）得到的结果是一个时间段，如果这个时间段的值小于duration，说明该数据展示的时间点早于start_time+duration得到的时间点，那么这个数据就在播放范围内，否则说明该数据展示的时间点晚于start_time+duration得到的时间点，我们并不需要播放这段数据，所以这段数据就被丢弃。那么有没有可能pkt_ts小于start_time呢？这样也能满足上述条件，但是这个数据也不在播放范围内。答案是不可能，因为这种情况发生的情况只会是发生了seek，seek操作的处理在读取数据之前已经完成，所以seek时间点之前的数据是不可能被读到的。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（四）：FrameQueue</title>
      <link href="/2022/11/30/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AFrameQueue/"/>
      <url>/2022/11/30/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AFrameQueue/</url>
      
        <content type="html"><![CDATA[<p>FrameQueue是用于保存AVFrame数据的队列，同样的为了能够增加额外的参数，AVFrame与其他额外参数被封装成一个新的结构体Frame，FrameQueue中保存的就是Frame类型的数据。Frame和FrameQueue结构体代码注释如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Frame</span> &#123;</span></span><br><span class="line">  AVFrame *frame;<span class="comment">//指向帧结构体变量的指针</span></span><br><span class="line">  AVSubtitle sub;<span class="comment">//字幕结构体变量</span></span><br><span class="line">  <span class="type">int</span> serial;<span class="comment">//序列号</span></span><br><span class="line">  <span class="type">double</span> pts;<span class="comment">//这一帧展示的时间点</span></span><br><span class="line">  <span class="type">double</span> duration;<span class="comment">//这一帧内容的持续时间</span></span><br><span class="line">  <span class="type">int64_t</span> pos;<span class="comment">//这一帧在输入文件中的位置</span></span><br><span class="line">  <span class="type">int</span> width;<span class="comment">//画面的宽度</span></span><br><span class="line">  <span class="type">int</span> height;<span class="comment">//画面的高度</span></span><br><span class="line">  <span class="type">int</span> format;<span class="comment">//格式</span></span><br><span class="line">  AVRational sar;<span class="comment">//横向像素点与纵向像素点数量的比值</span></span><br><span class="line">  <span class="type">int</span> uploaded;<span class="comment">//是否已经渲染到输出设备</span></span><br><span class="line">  <span class="type">int</span> flip_v;<span class="comment">//垂直翻转</span></span><br><span class="line">&#125; Frame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FrameQueue</span> &#123;</span></span><br><span class="line">  Frame <span class="built_in">queue</span>[FRAME_QUEUE_SIZE];<span class="comment">//保存Frame格式数据的数组</span></span><br><span class="line">  <span class="type">int</span> rindex;<span class="comment">//读指针</span></span><br><span class="line">  <span class="type">int</span> windex;<span class="comment">//写指针</span></span><br><span class="line">  <span class="type">int</span> size;<span class="comment">//未读帧数</span></span><br><span class="line">  <span class="type">int</span> max_size;<span class="comment">//队列中能保存的最大帧数</span></span><br><span class="line">  <span class="type">int</span> keep_last;<span class="comment">//是否保留上一帧</span></span><br><span class="line">  <span class="type">int</span> rindex_shown;<span class="comment">//用于标识保留帧</span></span><br><span class="line">  SDL_mutex *mutex;<span class="comment">//互斥量</span></span><br><span class="line">  SDL_cond *cond;<span class="comment">//用于读写同步的条件变量</span></span><br><span class="line">  PacketQueue *pktq;<span class="comment">//包队列指针</span></span><br><span class="line">&#125; FrameQueue;</span><br></pre></td></tr></table></figure><p>FrameQueue通过一个固定长度的数组以及两个读写指针实现了一个循环队列，当需要从队列中读取数据或向队列中写入数据时，队列会返回一个指向可读或可写位置的指针，然后调用者可以通过指针进行读写操作。</p><p>FrameQueue的操作函数有如下几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">frame_queue_unref_item</span><span class="params">(Frame *vp)</span></span><br><span class="line">&#123;</span><br><span class="line">  av_frame_unref(vp-&gt;frame);<span class="comment">//释放所有跟frame关联的buffer并重置frame中所有字段的值</span></span><br><span class="line">  avsubtitle_free(&amp;vp-&gt;sub);<span class="comment">//释放sub中分配的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数用于释放Frame结构体变量中的AVFrame和AVSubtitle成员变量关联的数据，注意只是释放关联的数据，而不是销毁结构体变量，这一步的作用是重置Frame。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">frame_queue_init</span><span class="params">(FrameQueue *f, PacketQueue *pktq, <span class="type">int</span> max_size, <span class="type">int</span> keep_last)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(FrameQueue));</span><br><span class="line">  <span class="keyword">if</span> (!(f-&gt;mutex = SDL_CreateMutex())) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;SDL_CreateMutex(): %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(f-&gt;cond = SDL_CreateCond())) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;SDL_CreateCond(): %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">  &#125;</span><br><span class="line">  f-&gt;pktq = pktq;<span class="comment">//关联PacketQueue</span></span><br><span class="line">  f-&gt;max_size = FFMIN(max_size, FRAME_QUEUE_SIZE);</span><br><span class="line">  f-&gt;keep_last = !!keep_last;<span class="comment">//keep_last的值为0或1</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; f-&gt;max_size; i++)<span class="comment">//初始化队列数据</span></span><br><span class="line">    <span class="keyword">if</span> (!(f-&gt;<span class="built_in">queue</span>[i].frame = av_frame_alloc()))</span><br><span class="line">      <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列的初始化函数，与PacketQueue一样，也是使用memset()将所有内置类型的变量初始化为0。然后创建用于线程同步的互斥量以及条件变量，关联PacketQueue，设置队列最大成员数量，keep_last通过一个小技巧将输入值转换为0或1，保证所有非零输入都被转换为1保存，最后使用av_frame_alloc()初始化所有数组成员，该函数会创建一个AVFrame并设置默认值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">frame_queue_destory</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; f-&gt;max_size; i++) &#123;</span><br><span class="line">    Frame *vp = &amp;f-&gt;<span class="built_in">queue</span>[i];</span><br><span class="line">    frame_queue_unref_item(vp);</span><br><span class="line">    av_frame_free(&amp;vp-&gt;frame);</span><br><span class="line">  &#125;</span><br><span class="line">  SDL_DestroyMutex(f-&gt;mutex);</span><br><span class="line">  SDL_DestroyCond(f-&gt;cond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销毁函数，销毁队列中所有数据，针对每个数组成员，先调用frame_queue_unref_item销毁关联数据，再调用av_frame_free销毁AVFrame本身，AVSubtitle由于分配在栈上，所以不需要手动销毁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">frame_queue_signal</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  SDL_CondSignal(f-&gt;cond);</span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送同步信号，唤醒等待条件变量的线程。</p><p>接下来是重头戏，队列的读写函数，我们先分析逻辑较为简单的写操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Frame *<span class="title function_">frame_queue_peek_writable</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* wait until we have space to put a new frame */</span></span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  <span class="keyword">while</span> (f-&gt;size &gt;= f-&gt;max_size &amp;&amp;</span><br><span class="line">      !f-&gt;pktq-&gt;abort_request) &#123;</span><br><span class="line">    SDL_CondWait(f-&gt;cond, f-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;pktq-&gt;abort_request)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;f-&gt;<span class="built_in">queue</span>[f-&gt;windex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">frame_queue_push</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (++f-&gt;windex == f-&gt;max_size)</span><br><span class="line">    f-&gt;windex = <span class="number">0</span>;</span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  f-&gt;size++;</span><br><span class="line">  SDL_CondSignal(f-&gt;cond);</span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>frame_queue_peek_writable返回写指针指向的数组成员，在返回之前函数会先检查队列是否已满，由于是循环队列，队列已满的意思就是队列中所有成员都已被写入数据切这些数据都还未被读取，如果此时未经检查直接写入新的数据，那么当前数组中最早被写入的数据就会被覆盖。检查的手段也很简单，只需要检查size是否大于或等于max_size即可。当队列中有可写空间时，返回写指针指向的数据成员。写入成功后需要将写指针向前移动一位，如果移动后的索引值超过了最大索引值，就将写指针的索引设为0，从而实现对数组的循环写入。接下来将size加1,并发送通知唤醒等待条件变量的线程，由于size值在读写线程中都会被修改，所以需要在加锁的情况下更新。</p><p>写操作的逻辑简单总结就是，找到可写位置，写入数据，更新未读节点数量，然后发送通知唤醒还在等待的线程。</p><p>相比写操作，读操作的逻辑相对复杂，主要是因为涉及到保留上一帧这一操作，我们看一下具体代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Frame *<span class="title function_">frame_queue_peek</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;f-&gt;<span class="built_in">queue</span>[(f-&gt;rindex + f-&gt;rindex_shown) % f-&gt;max_size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Frame *<span class="title function_">frame_queue_peek_next</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;f-&gt;<span class="built_in">queue</span>[(f-&gt;rindex + f-&gt;rindex_shown + <span class="number">1</span>) % f-&gt;max_size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Frame *<span class="title function_">frame_queue_peek_last</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;f-&gt;<span class="built_in">queue</span>[f-&gt;rindex];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> Frame *<span class="title function_">frame_queue_peek_readable</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* wait until we have a readable a new frame */</span></span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  <span class="keyword">while</span> (f-&gt;size - f-&gt;rindex_shown &lt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">      !f-&gt;pktq-&gt;abort_request) &#123;</span><br><span class="line">    SDL_CondWait(f-&gt;cond, f-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;pktq-&gt;abort_request)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;f-&gt;<span class="built_in">queue</span>[(f-&gt;rindex + f-&gt;rindex_shown) % f-&gt;max_size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是读取函数，三个简单的读取函数分别用来读取当前结点，读取下一个节点以及读取上一个节点，还有一个实现更复杂的读取可读节点，该函数与普通的读取当前节点的函数的不同点在于frame_queue_peek_readable是读取还未读取的节点，而frame_queue_peek则只是读取当前节点而不检查当前节点是否已经被读取过。读取未读节点需要满足两个条件：1、队列中存在未读节点；2、关联的PacketQueue没有终止。如果条件1未被满足，函数会阻塞直到被条件变量的通知唤醒；如果条件2未被满足，函数返回NULL；如果两者都被满足，则返回当前节点，使用与普通读取函数相同的操作。</p><p>我们注意到，计算当前节点索引的方式有些特别，是用rindex+rindex_shown的和对max_size取模，所以严格来说rindex并不是读指针的索引值，rindex+rindex_shown才是。那么rindex_shown又是什么值呢？我们先看下面的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">frame_queue_next</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;keep_last &amp;&amp; !f-&gt;rindex_shown) &#123;</span><br><span class="line">    f-&gt;rindex_shown = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  frame_queue_unref_item(&amp;f-&gt;<span class="built_in">queue</span>[f-&gt;rindex]);</span><br><span class="line">  <span class="keyword">if</span> (++f-&gt;rindex == f-&gt;max_size)</span><br><span class="line">    f-&gt;rindex = <span class="number">0</span>;</span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  f-&gt;size--;</span><br><span class="line">  SDL_CondSignal(f-&gt;cond);</span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与写操作写入数据成功后直接更新写指针以及size值不同，读操作在更新读指针以及size值之前需要对已读节点的数据进行释放，也就是调用frame_queue_unref_item函数。在此之前，函数先判断keep_last的值，当程序要求保留上一帧时，即keep_last的值为1时，如果rindex_shown此时的值为0，它将被设置为1。</p><p>我们再回过头去看几个读函数的操作，用rindex+rindex_shown作为真正的读指针，而更新读指针销毁数据时却使用rindex，如果rindex_shown为零也就是不需要保留上一帧时，rindex等于rindex_shown，程序执行的操作就是读完一帧然后销毁刚读完的这一帧。而当rindex_shown为1时，真正的读指针是指向rindex的下一个节点的数据，那么相对于读操作来讲，刚读完一帧数据并且移动读指针时，销毁的其实是刚读的这一帧的上一帧数据，刚读过的这一帧数据得以保留。</p><p>我们再来看一下frame_queue_peek_readable函数中判断当前队列中是否存在未读结点使用的判断条件是</p><p><code>f-&gt;size - f-&gt;rindex_shown &lt;= 0</code></p><p>我们再来带入一下两种情况，当rindex_shown等于0即不需要保留上一帧数据时，判断条件相当于size&lt;&#x3D;0，这很好理解。当rindex_shown等于1即需要保留上一帧数据是，判断条件相当于size&lt;&#x3D;1,这是因为size表示的是未读结点的数量，而当rindex_shown等于1时，上一帧的数据是已读未擦除状态，所以在这种情况下当size等于1时，剩下的这一帧数据已经被读过了。</p><p>剩下两个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">frame_queue_nb_remaining</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> f-&gt;size - f-&gt;rindex_shown;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int64_t</span> <span class="title function_">frame_queue_last_pos</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  Frame *fp = &amp;f-&gt;<span class="built_in">queue</span>[f-&gt;rindex];</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;rindex_shown &amp;&amp; fp-&gt;serial == f-&gt;pktq-&gt;serial)</span><br><span class="line">    <span class="keyword">return</span> fp-&gt;pos;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>frame_queue_nb_remaining返回队列中未被读取的值，为什么用size-rindex_shown，因为如果有保留帧，那么跟rindex同步更新的size值一定会比实际的未读取的节点数量值大1。</p><p>frame_queue_last_pos返回上一帧的位置，只有队列有保留帧的时候该函数才会返回上一帧的位置，否则返回-1。</p><p>ffplay中需要保留上一帧的流有视频流和音频流。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（三）：PacketQueue</title>
      <link href="/2022/11/29/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9APacketQueue/"/>
      <url>/2022/11/29/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9APacketQueue/</url>
      
        <content type="html"><![CDATA[<p>ffmpeg库解析音视频数据的顺序是先解封装（demuxing）再解码（decoding），其中解封装是从原始数据中分离出不同的数据流，如音频流，视频流等。解码是将从音视频流中读取的压缩数据解析成音视频输出设备可以识别的数据格式，音频如PCM，视频如YUV420P等。ffmpeg相关库的实现中，负责保存压缩数据的数据结构为struct AVPacket，负责保存解码后数据的数据结构为struct AVFrame。ffplay为存放这两种类型的数据创建了两个队列，存放AVPacket的队列就是本章介绍的PacketQueue，存放AVFrame的队列是我们下一章要介绍的FrameQueue；</p><p>先来看一下PacketQueue相关的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyAVPacketList</span> &#123;</span></span><br><span class="line">  AVPacket *pkt;<span class="comment">//压缩的包数据</span></span><br><span class="line">  <span class="type">int</span> serial;<span class="comment">//包序列号，跟所在的包序列的序列号一致</span></span><br><span class="line">&#125; MyAVPacketList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PacketQueue</span> &#123;</span></span><br><span class="line">  AVFifoBuffer *pkt_list;<span class="comment">//先进先出队列</span></span><br><span class="line">  <span class="type">int</span> nb_packets;<span class="comment">//队列中包的数量</span></span><br><span class="line">  <span class="type">int</span> size;<span class="comment">//队列大小</span></span><br><span class="line">  <span class="type">int64_t</span> duration;<span class="comment">//队列中数据的播放持续时间</span></span><br><span class="line">  <span class="type">int</span> abort_request;<span class="comment">//结束请求</span></span><br><span class="line">  <span class="type">int</span> serial;<span class="comment">//序列号，用于标识一段连续数据</span></span><br><span class="line">  SDL_mutex *mutex;<span class="comment">//线程互斥量</span></span><br><span class="line">  SDL_cond *cond;<span class="comment">//线程条件变量</span></span><br><span class="line">&#125; PacketQueue;</span><br></pre></td></tr></table></figure><p>PacketQueue结构体中各个参数的含义已经在注释中写明，PacketQueue的操作函数有以下几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_put_private</span><span class="params">(PacketQueue *q, AVPacket *pkt)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_put</span><span class="params">(PacketQueue *q, AVPacket *pkt)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_put_nullpacket</span><span class="params">(PacketQueue *q, AVPacket *pkt, <span class="type">int</span> stream_index)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_init</span><span class="params">(PacketQueue *q)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">packet_queue_flush</span><span class="params">(PacketQueue *q)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">packet_queue_destroy</span><span class="params">(PacketQueue *q)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">packet_queue_abort</span><span class="params">(PacketQueue *q)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">packet_queue_start</span><span class="params">(PacketQueue *q)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_get</span><span class="params">(PacketQueue *q, AVPacket *pkt, <span class="type">int</span> block, <span class="type">int</span> *serial)</span>;</span><br></pre></td></tr></table></figure><p>packet_queue_init用memset函数将结构体所在内存以0初始化，这样可以将结构体中int类型的值初始化为0。然后创建一个fifo队列和用于线程同步的互斥量以及条件变量，最后将abort_request设置为1表示队列当前状态不可用；</p><p>packet_queue_flush函数将队列中数据清空，serial值加1，这些操作都在上锁状态下执行，相同的serial值表明这些数据是一段连续的内容，flush操作清空并丢弃了队列中还未被读取的数据，所以通过serial加1来表示接下来的数据跟之前的数据表示的已经不是连续的内容了；</p><p>packet_queue_destory调用flush函数清空数据，然后销毁fifo队列，以及互斥量和条件变量；</p><p>packet_queue_abort在上锁状态下将abort_request设置为1，并调用SDL_ConSignal()函数通知条件变量；</p><p>packet_queue_start函数在上锁状态下将abort_request设置为0，serial加1；</p><p>packet_queue_get是唯一的读取函数接受四个参数，第一个参数q指定PacketQueue，第二个参数pkt是一个指向AVPacket的指针，用于存储从q中读出的数据，第三个参数表示是否为阻塞模式，如果为0，那么当队列中没有数据时，函数会立即返回，否则将会调用SDL_CondWait()等待直到队列中有数据。第四个参数是一个传入的int变量地址，从fifo队列中读取的MyAVPacketList类型数据包含AVPacket类型的数据和一个序列号，这个序列号会被传给第四个参数指定的int变量。</p><p>packet_queue_put_private函数负责将参数pkt指向的AVPacket类型的数据连同队列q的序列号一起包装成一个MyAVPacketList类型数据写入fifo队列，然后将nb_packets加1，size加上MyAVPacketList的大小和其指向的AVPacket的大小，duration加上AVPacket的duration。写入成功后调用SDL_CondSignal()通知条件变量。该函数是执行具体写入动作的函数，只是供packet_queue_put函数调用，所以函数中没有上锁。</p><p>packet_queue_put检查参数pkt指定的数据是否为null，不为null时才在上锁状态下调用packet_queue_put_private执行真正的写入。</p><p>packet_queue_put_nullpacket用于向队列中写入一个没有数据的AVPecket包，设置了pkg的stream_index后直接调用packet_queue_put。该函数存在的意义是一个空包可以作为一个刷新包通知解码器已经到达流结束的位置了，解码器读到刷新包后会将缓存的帧数据返回。</p><p>分析完所有函数的功能，我们做一个简短的总结。PacketQueue中维护了一个fifo队列，队列中存储MyAVPacketList类型数据而不直接存储AVPacket类型数据的原因是需要为每个包添加一个序列号，这个序列号在包被放入队列时会被设置为队列的序列号，序列号用于标识一段连续的内容，如果两个包的序列号不同，说明他们所表示的内容时间上不连续。需要互斥量和条件变量的原因是队列的读写操作分别在不同线程，需要线程同步。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（二）：VideoState结构体</title>
      <link href="/2022/11/29/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AVideoState%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2022/11/29/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AVideoState%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p>VideoState结构体是ffplay源码里最重要也是最庞大的一个结构体，可以说是“包罗万象”，整个源码读下来给人的感觉就是只要是需要在函数间传递的参数，都会被放进这个结构体，然后相关的函数之间传VideoState的指针就好。这样做的好处是不用费力为每个函数想不同的参数名，后期增删参数时只需要修改VideoState结构体以及使用到该参数的某几行代码而不用修改所有相关函数的调用。坏处就是代码的耦合度太高了，不过对于单个源文件写完所有功能的ffplay来说，这并不算是什么大问题。</p><p>VideoState结构体的注释如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VideoState</span> &#123;</span><br><span class="line">  SDL_Thread *read_tid;<span class="comment">//读线程id</span></span><br><span class="line">  <span class="type">const</span> AVInputFormat *iformat;<span class="comment">//输入文件格式</span></span><br><span class="line">  <span class="type">int</span> abort_request;<span class="comment">//为1时，读线程退出</span></span><br><span class="line">  <span class="type">int</span> force_refresh;<span class="comment">//强制刷新标志位</span></span><br><span class="line">  <span class="type">int</span> paused;<span class="comment">//播放暂停标志位</span></span><br><span class="line">  <span class="type">int</span> last_paused;<span class="comment">//上一次设置的paused标志位</span></span><br><span class="line">  <span class="type">int</span> queue_attachments_req;<span class="comment">//请求流中的附加信息（如封面图片）的标志位</span></span><br><span class="line">  <span class="type">int</span> seek_req;<span class="comment">//查找请求</span></span><br><span class="line">  <span class="type">int</span> seek_flags;<span class="comment">//指定查找行为的标志位</span></span><br><span class="line">  <span class="type">int64_t</span> seek_pos;<span class="comment">//查找位置</span></span><br><span class="line">  <span class="type">int64_t</span> seek_rel;<span class="comment">//查找粒度</span></span><br><span class="line">  <span class="type">int</span> read_pause_return;<span class="comment">//保存av_read_pause()函数的返回值</span></span><br><span class="line">  AVFormatContext *ic;</span><br><span class="line">  <span class="type">int</span> realtime;<span class="comment">//是否是实时流</span></span><br><span class="line"></span><br><span class="line">  Clock audclk;<span class="comment">//音频流时钟</span></span><br><span class="line">  Clock vidclk;<span class="comment">//视频流时钟</span></span><br><span class="line">  Clock extclk;<span class="comment">//外部时钟</span></span><br><span class="line"></span><br><span class="line">  FrameQueue pictq;<span class="comment">//视频流的帧队列</span></span><br><span class="line">  FrameQueue subpq;<span class="comment">//字幕流的帧队列</span></span><br><span class="line">  FrameQueue sampq;<span class="comment">//音频流的帧队列</span></span><br><span class="line"></span><br><span class="line">  Decoder auddec;<span class="comment">//音频解码器</span></span><br><span class="line">  Decoder viddec;<span class="comment">//视频解码器</span></span><br><span class="line">  Decoder subdec;<span class="comment">//字幕解码器</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> audio_stream;<span class="comment">//音频流序号</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> av_sync_type;<span class="comment">//音视频同步模式</span></span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> audio_clock;<span class="comment">//音频时钟数值</span></span><br><span class="line">  <span class="type">int</span> audio_clock_serial;<span class="comment">//音频时钟序列号</span></span><br><span class="line">  <span class="type">double</span> audio_diff_cum; <span class="comment">/* used for AV difference average computation */</span></span><br><span class="line">  <span class="type">double</span> audio_diff_avg_coef;</span><br><span class="line">  <span class="type">double</span> audio_diff_threshold;</span><br><span class="line">  <span class="type">int</span> audio_diff_avg_count;<span class="comment">//以上几个值用于计算音频重采样的样本数</span></span><br><span class="line">  AVStream *audio_st;<span class="comment">//指向音频流的指针</span></span><br><span class="line">  PacketQueue audioq;<span class="comment">//音频流的包队列</span></span><br><span class="line">  <span class="type">int</span> audio_hw_buf_size;<span class="comment">//硬件支持的音频缓冲区大小</span></span><br><span class="line">  <span class="type">uint8_t</span> *audio_buf;<span class="comment">//指向储存音频数据的缓冲区</span></span><br><span class="line">  <span class="type">uint8_t</span> *audio_buf1;<span class="comment">//指向储存音频数据的缓冲区</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> audio_buf_size; <span class="comment">/* in bytes */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> audio_buf1_size;<span class="comment">//缓冲区大小</span></span><br><span class="line">  <span class="type">int</span> audio_buf_index; <span class="comment">/* 音频缓冲区读取位置 in bytes */</span></span><br><span class="line">  <span class="type">int</span> audio_write_buf_size;<span class="comment">//音频缓冲区中可写区域的大小</span></span><br><span class="line">  <span class="type">int</span> audio_volume;<span class="comment">//音量值</span></span><br><span class="line">  <span class="type">int</span> muted;<span class="comment">//是否静音</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">AudioParams</span> audio_src;<span class="comment">//音频参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_AVFILTER</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">AudioParams</span> audio_filter_src;<span class="comment">//滤镜处理后的音频参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">AudioParams</span> audio_tgt;<span class="comment">//硬件支持的音频参数</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">SwrContext</span> *swr_ctx;<span class="comment">//音频重采样上下文</span></span><br><span class="line">  <span class="type">int</span> frame_drops_early;<span class="comment">//解码过程中的丢帧数</span></span><br><span class="line">  <span class="type">int</span> frame_drops_late;<span class="comment">//渲染过程中的丢帧数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">ShowMode</span> &#123;</span><br><span class="line">    SHOW_MODE_NONE = <span class="number">-1</span>, SHOW_MODE_VIDEO = <span class="number">0</span>, SHOW_MODE_WAVES, SHOW_MODE_RDFT, SHOW_MODE_NB</span><br><span class="line">  &#125; show_mode;<span class="comment">//显示模式，分为视频模式，波形图模式以及频谱图</span></span><br><span class="line">  <span class="type">int16_t</span> sample_array[SAMPLE_ARRAY_SIZE];<span class="comment">//音频样本数组</span></span><br><span class="line">  <span class="type">int</span> sample_array_index;<span class="comment">//样本数组的读取位置</span></span><br><span class="line">  <span class="type">int</span> last_i_start;</span><br><span class="line">  RDFTContext *rdft;<span class="comment">//实时傅里叶变换上下文</span></span><br><span class="line">  <span class="type">int</span> rdft_bits;</span><br><span class="line">  FFTSample *rdft_data;</span><br><span class="line">  <span class="type">int</span> xpos;</span><br><span class="line">  <span class="type">double</span> last_vis_time;</span><br><span class="line">  SDL_Texture *vis_texture;<span class="comment">//用于渲染音频图像的纹理结构体指针</span></span><br><span class="line">  SDL_Texture *sub_texture;<span class="comment">//用于渲染字幕的纹理结构体指针</span></span><br><span class="line">  SDL_Texture *vid_texture;<span class="comment">//用于渲染视频的纹理结构体指针</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> subtitle_stream;<span class="comment">//字幕流序号</span></span><br><span class="line">  AVStream *subtitle_st;<span class="comment">//指向字幕流的指针</span></span><br><span class="line">  PacketQueue subtitleq;<span class="comment">//字幕流的包队列</span></span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> frame_timer;<span class="comment">//帧计时器</span></span><br><span class="line">  <span class="type">double</span> frame_last_returned_time;</span><br><span class="line">  <span class="type">double</span> frame_last_filter_delay;</span><br><span class="line">  <span class="type">int</span> video_stream;<span class="comment">//视频流序号</span></span><br><span class="line">  AVStream *video_st;<span class="comment">//视频流指针</span></span><br><span class="line">  PacketQueue videoq;<span class="comment">//视频流包队列</span></span><br><span class="line">  <span class="type">double</span> max_frame_duration; <span class="comment">//单个帧最大的持续时间   // maximum duration of a frame - above this, we consider the jump a timestamp discontinuity</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">SwsContext</span> *img_convert_ctx;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">SwsContext</span> *sub_convert_ctx;</span><br><span class="line">  <span class="type">int</span> eof;<span class="comment">//文件结束标志位</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *filename;<span class="comment">//文件名</span></span><br><span class="line">  <span class="type">int</span> width, height, xleft, ytop;<span class="comment">//窗口的位置和大小</span></span><br><span class="line">  <span class="type">int</span> step;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_AVFILTER</span></span><br><span class="line">  <span class="type">int</span> vfilter_idx;</span><br><span class="line">  AVFilterContext *in_video_filter;   <span class="comment">// the first filter in the video chain</span></span><br><span class="line">  AVFilterContext *out_video_filter;  <span class="comment">// the last filter in the video chain</span></span><br><span class="line">  AVFilterContext *in_audio_filter;   <span class="comment">// the first filter in the audio chain</span></span><br><span class="line">  AVFilterContext *out_audio_filter;  <span class="comment">// the last filter in the audio chain</span></span><br><span class="line">  AVFilterGraph *agraph;              <span class="comment">// audio filter graph</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> last_video_stream, last_audio_stream, last_subtitle_stream;<span class="comment">//上一次使用的流，用于循环播放</span></span><br><span class="line"></span><br><span class="line">  SDL_cond *continue_read_thread;<span class="comment">//控制读线程是否继续读的条件变量</span></span><br><span class="line">&#125; VideoState;</span><br></pre></td></tr></table></figure><p>结构体中某些参数单从注释上很难理解其具体含义，所以在之后的源码分析中我们会反复回来看这个结构体的内容。</p><p>在分析具体代码逻辑之前，我们需要知道ffplay中用到的两个队列的用法：PacketQueue，FrameQueue。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（一）：main函数</title>
      <link href="/2022/11/27/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Amain%E5%87%BD%E6%95%B0/"/>
      <url>/2022/11/27/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Amain%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>ffplay源码的main函数逻辑较为简单，根据任务划分主要做了如下几件事：</p><p>1、解析参数</p><p>2、初始化相关库</p><p>3、创建SDL窗口及其对应的渲染器</p><p>4、打开流</p><p>5、开启主循环</p><p>其中解析参数这一步调用的函数是根据ffmpeg的参数规则专门编写的，具体实现在cmdutils.c中。这部分实现是ffmpeg，ffplay和ffplay三个项目共用的。当我们单独分析ffplay源码时，我们不需要知道具体的实现细节，只需要知道这一步是修改ffplay.c源文件开头定义的用于表示用户行为的静态变量就可以了，具体的变量可以在后面分析源码的时候遇到了再回头看对应的参数。</p><p>用户可以定义的静态变量有以下这些：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">static const AVInputFormat *file_iformat;//对应-f参数指定的文件格式，默认是自动判断不需要手动指定</span><br><span class="line">static const char *input_filename;//输入文件名</span><br><span class="line">static const char *window_title;//主窗口标题</span><br><span class="line">static int default_width  = 640;//主窗口默认宽度</span><br><span class="line">static int default_height = 480;//主窗口默认高度</span><br><span class="line">static int screen_width  = 0;</span><br><span class="line">static int screen_height = 0;//屏幕默认宽高，没有对应参数</span><br><span class="line">static int screen_left = SDL_WINDOWPOS_CENTERED;//设置窗口左方的的x坐标，默认居中，对应参数-left</span><br><span class="line">static int screen_top = SDL_WINDOWPOS_CENTERED;//设置窗口上方的y坐标，默认居中，对应参数-top</span><br><span class="line">static int audio_disable;//关闭音频，对应参数-an</span><br><span class="line">static int video_disable;//关闭视频，对应参数-vn</span><br><span class="line">static int subtitle_disable;//关闭字幕，对应参数-sn</span><br><span class="line">static const char* wanted_stream_spec[AVMEDIA_TYPE_NB] = &#123;0&#125;;//用户设置的期望使用的流，对应参数-ast,-vst,-sst</span><br><span class="line">static int seek_by_bytes = -1;//按字节seek，对应参数-bytes</span><br><span class="line">static float seek_interval = 10;//查找间隔(步长)，对应参数-seek_interval</span><br><span class="line">static int display_disable;//关闭显示，对应参数-nodisp</span><br><span class="line">static int borderless;//窗口无边框，对应参数-noborder</span><br><span class="line">static int alwaysontop;//窗口置顶，对应参数-alwaysontop</span><br><span class="line">static int startup_volume = 100;//初始音量，对应参数-volume</span><br><span class="line">static int show_status = -1;//是否打印状态信息，对应参数-stats</span><br><span class="line">static int av_sync_type = AV_SYNC_AUDIO_MASTER;//音视频同步模式，对应参数-sync</span><br><span class="line">static int64_t start_time = AV_NOPTS_VALUE;//开始时间，对应参数-ss</span><br><span class="line">static int64_t duration = AV_NOPTS_VALUE;//持续时长，对应参数-t，这两个参数用于播放指定时间段的内容</span><br><span class="line">static int fast = 0;//允许使用非标准的加速解码手段，对应参数-fast</span><br><span class="line">static int genpts = 0;//生成时间戳，对应参数-genpts</span><br><span class="line">static int lowres = 0;//低分辨率解码</span><br><span class="line">static int decoder_reorder_pts = -1;//让解码器对pts重新排序，对应参数-drp</span><br><span class="line">static int autoexit;//播放结束自动退出，对应参数-autoexit</span><br><span class="line">static int exit_on_keydown;//按键退出播放，对应参数-exitonkeydown</span><br><span class="line">static int exit_on_mousedown;//按下鼠标退出播放，对应参数-exitonmousedown</span><br><span class="line">static int loop = 1;//循环播放，对应参数-loop</span><br><span class="line">static int framedrop = -1;//是否允许cpu性能达不到要求时丢帧，对应参数-framedrop</span><br><span class="line">static int infinite_buffer = -1;//是否限制输入缓冲区大小，对应参数-infbuf</span><br><span class="line">static enum ShowMode show_mode = SHOW_MODE_NONE;//显示模式</span><br><span class="line">static const char *audio_codec_name;//音频解码器名称，对应参数-acodec</span><br><span class="line">static const char *subtitle_codec_name;//字幕解码器名称，对应参数-scodec</span><br><span class="line">static const char *video_codec_name;//视频解码器名称，对应参数-vcodec</span><br><span class="line">double rdftspeed = 0.02;//rdft速度，对应参数-rdftspeed</span><br><span class="line">static int64_t cursor_last_shown;</span><br><span class="line">static int cursor_hidden = 0;</span><br><span class="line">#if CONFIG_AVFILTER</span><br><span class="line">static const char **vfilters_list = NULL;</span><br><span class="line">static int nb_vfilters = 0;</span><br><span class="line">static char *afilters = NULL;</span><br><span class="line">#endif</span><br><span class="line">static int autorotate = 1;//自动旋转视频，对应参数-autorotate</span><br><span class="line">static int find_stream_info = 1;//查询流信息，对应参数-find_stream_info</span><br><span class="line">static int filter_nbthreads = 0;//filter线程数，对应参数-filter_threads</span><br><span class="line"></span><br><span class="line">/* current context */</span><br><span class="line">static int is_full_screen;//是否全屏，对应参数-fs</span><br></pre></td></tr></table></figure><p>带注释的完整main函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flags;<span class="comment">//用于创建SDL窗口时指定flag</span></span><br><span class="line">  VideoState *is;</span><br><span class="line"></span><br><span class="line">  init_dynload();<span class="comment">//当前只做一件事，在win32平台将当前工作目录从DLL搜索路径中移除</span></span><br><span class="line"></span><br><span class="line">  av_log_set_flags(AV_LOG_SKIP_REPEATED);<span class="comment">//折叠重复日志</span></span><br><span class="line">  parse_loglevel(argc, argv, options);<span class="comment">//解析loglevel</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* register all codecs, demux and protocols */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_AVDEVICE</span></span><br><span class="line">  avdevice_register_all();<span class="comment">//初始化libavdeivce库并且注册所有输入输出设备</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  avformat_network_init();<span class="comment">//初始化网络库</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//指定SIGINT和SIGTERM两个信号的处理函数</span></span><br><span class="line">  signal(SIGINT , sigterm_handler); <span class="comment">/* Interrupt (ANSI).    */</span></span><br><span class="line">  signal(SIGTERM, sigterm_handler); <span class="comment">/* Termination (ANSI).  */</span></span><br><span class="line"></span><br><span class="line">  show_banner(argc, argv, options);<span class="comment">//打印程序和库的信息</span></span><br><span class="line"></span><br><span class="line">  parse_options(<span class="literal">NULL</span>, argc, argv, options, opt_input_file);<span class="comment">//解析参数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*必须有输入文件，否则退出*/</span></span><br><span class="line">  <span class="keyword">if</span> (!input_filename) &#123;</span><br><span class="line">    show_usage();</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;An input file must be specified\n&quot;</span>);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL,</span><br><span class="line">           <span class="string">&quot;Use -h to get full help or, even better, run &#x27;man %s&#x27;\n&quot;</span>, program_name);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*判断是否显示画面*/</span></span><br><span class="line">  <span class="keyword">if</span> (display_disable) &#123;<span class="comment">//display_disable通过命令行参数-nodisp设置</span></span><br><span class="line">    video_disable = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  flags = SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER;<span class="comment">//默认加载SDL的video、audio和timer子系统</span></span><br><span class="line">  <span class="keyword">if</span> (audio_disable)<span class="comment">//audio_disable通过命令行参数-an设置</span></span><br><span class="line">    flags &amp;= ~SDL_INIT_AUDIO;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Try to work around an occasional ALSA buffer underflow issue when the</span></span><br><span class="line"><span class="comment">     * period size is NPOT due to ALSA resampling by forcing the buffer size. */</span></span><br><span class="line">    <span class="keyword">if</span> (!SDL_getenv(<span class="string">&quot;SDL_AUDIO_ALSA_SET_BUFFER_SIZE&quot;</span>))</span><br><span class="line">      SDL_setenv(<span class="string">&quot;SDL_AUDIO_ALSA_SET_BUFFER_SIZE&quot;</span>,<span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (display_disable)</span><br><span class="line">    flags &amp;= ~SDL_INIT_VIDEO;</span><br><span class="line">  <span class="keyword">if</span> (SDL_Init (flags)) &#123;<span class="comment">//用配置好的flags初始化SDL</span></span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Could not initialize SDL - %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;(Did you set the DISPLAY variable?)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//忽略事件</span></span><br><span class="line">  SDL_EventState(SDL_SYSWMEVENT, SDL_IGNORE);</span><br><span class="line">  SDL_EventState(SDL_USEREVENT, SDL_IGNORE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!display_disable) &#123;</span><br><span class="line">    <span class="type">int</span> flags = SDL_WINDOW_HIDDEN;<span class="comment">//配置SDL创建窗口的标志位</span></span><br><span class="line">    <span class="keyword">if</span> (alwaysontop)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SDL_VERSION_ATLEAST(2,0,5)</span></span><br><span class="line">      flags |= SDL_WINDOW_ALWAYS_ON_TOP;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;Your SDL version doesn&#x27;t support SDL_WINDOW_ALWAYS_ON_TOP. Feature will be inactive.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (borderless)</span><br><span class="line">      flags |= SDL_WINDOW_BORDERLESS;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      flags |= SDL_WINDOW_RESIZABLE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR</span></span><br><span class="line">    SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, <span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    window = SDL_CreateWindow(program_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, default_width, default_height, flags);<span class="comment">//创建SDL窗口</span></span><br><span class="line">    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, <span class="string">&quot;linear&quot;</span>);<span class="comment">//设置默认的图片缩放质量为线性</span></span><br><span class="line">    <span class="keyword">if</span> (window) &#123;</span><br><span class="line">      renderer = SDL_CreateRenderer(window, <span class="number">-1</span>, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);<span class="comment">//从窗口创建渲染器</span></span><br><span class="line">      <span class="keyword">if</span> (!renderer) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;Failed to initialize a hardware accelerated renderer: %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">        renderer = SDL_CreateRenderer(window, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (renderer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!SDL_GetRendererInfo(renderer, &amp;renderer_info))<span class="comment">//打印渲染器信息</span></span><br><span class="line">          av_log(<span class="literal">NULL</span>, AV_LOG_VERBOSE, <span class="string">&quot;Initialized %s renderer.\n&quot;</span>, renderer_info.name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!window || !renderer || !renderer_info.num_texture_formats) &#123;<span class="comment">//打印失败信息</span></span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Failed to create window or renderer: %s&quot;</span>, SDL_GetError());</span><br><span class="line">      do_exit(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  is = stream_open(input_filename, file_iformat);<span class="comment">//打开视频/音频/字幕流</span></span><br><span class="line">  <span class="keyword">if</span> (!is) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Failed to initialize VideoState!\n&quot;</span>);</span><br><span class="line">    do_exit(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  event_loop(is);<span class="comment">//开启SDL事件循环</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* never returns */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码篇幅上看，main函数中绝大多数代码是用来配置SDL_init()和SDL_CreateWindow()这两个函数的标志位flags的。</p><p>其中SDL_Init()函数是用来初始化SDL库的，在使用任何SDL库函数之前必须先调用这个函数。SDL_Init接受一个Uint32类型的flags参数用来初始化SDL子系统，如SDL_INIT_AUDIO表示音频子系统，SDL_INIT_VIDEO表示视频子系统等，可以通过位或操作组合多个标志位来初始化多个子系统的目的，如SDL_INIT_AUDIO|SDL_INIT_VIDEO表示初始化音频子系统和视频子系统。SDL_Init()可用的标志位及其含义如下：</p><p>SDL_INIT_TIMER: timer subsystem<br>SDL_INIT_AUDIO: audio subsystem<br>SDL_INIT_VIDEO: video subsystem; automatically initializes the events subsystem<br>SDL_INIT_JOYSTICK: joystick subsystem; automatically initializes the events subsystem<br>SDL_INIT_HAPTIC: haptic (force feedback) subsystem<br>SDL_INIT_GAMECONTROLLER: controller subsystem; automatically initializes the joystick subsystem<br>SDL_INIT_EVENTS: events subsystem<br>SDL_INIT_EVERYTHING: all of the above subsystems<br>SDL_INIT_NOPARACHUTE: compatibility; this flag is ignored</p><p>完成SDL库的初始化后，接着开始创建主窗口以及对应的渲染器，主要使用SDL_CreateWindow()和SDL_CreateRenderer()这两个函数，创建成功以及打印完相关信息后，main函数中的可以归属为”初始化任务”的代码就结束了。</p><p>接下来的代码更简单直接，只是调用了stream_open()和event_loop()这两个函数。从函数名推断stream_open()用来打开流，event_loop()用来处理事件循环。事实也正是如此，不过有亿点不同的是：stream_open()不仅完成了打开流的工作，还完成了所有流的读取以及音频流向音频设备的输出；event_loop()除了处理SDL的事件循环，还负责视频流以及字幕流向显示设备的输出。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
