<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux网络编程(六)：epoll</title>
      <link href="/2022/12/29/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E5%85%AD)%EF%BC%9Aepoll/"/>
      <url>/2022/12/29/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E5%85%AD)%EF%BC%9Aepoll/</url>
      
        <content type="html"><![CDATA[<p>epoll是poll的一个变种，支持水平触发和边缘触发，select和poll则只支持水平触发。epoll只存在于linux内核，移植性不如select和poll，但是当需要监视大量处于空闲状态的描述符时（偶尔有少量描述符就绪），性能远远强于前两者。</p><p>epoll提供了三个系统调用：epoll_create()用于创建一个epoll实例，返回一个代表该实例的文件描述符；epoll_ctl用于操作同epoll实例相关联的兴趣列表；epoll_wait返回与epoll实例相关联的就绪列表中的成员。下面我们对这三个api进行详细的介绍。</p><p>epoll和poll的API在使用上的最大不同就是epoll需要创建一个epoll实例，epoll_create()会完成这项任务并返回一个代表epoll实例的文件描述符，这个文件描述符会作为epoll_ctl()和epoll_wait()的第一个参数。需要注意的是，epoll实例实际是在内核空间创建的，epoll_ctl()和epoll_wait()对代表epoll实例的文件描述符的操作也会转化成为对内核空间上的epoll实例的操作。使用这种方式避免了用户空间和内核空间之间的数据交换，解约了用于拷贝数据的CPU时间，所以在处理大量文件描述符时，epoll对比poll可以节省大量的CPU时间从而提升了性能。epoll_create()函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_create1(int flags);</span><br><span class="line">//执行成功返回代表epoll实例的文件描述符，失败则返回-1，相应的errno被设置</span><br></pre></td></tr></table></figure><p>可以看到系统提供了一个额外的函数epoll_create1()，两者的区别是，epoll_create()接收一个size参数，这个参数在原始的设计中用于告诉内核一个默认值，这个值代表了调用者期望的该epoll实例需要处理的文件描述符的数量，但是内核依旧可能会根据实际情况选择更大的值。所以在更新的版本中，内核已经不需要这个默认值了，但是为了兼容旧版本内核，新的程序中如果使用了epoll_create()，需要对其设置一个大于0的参数。epoll_create1()舍弃了size，使用一个标志位集合flags作为参数，目前该值只支持了EPOLL_CLOEXEC，用于为epoll实例的文件描述符设置FD_CLOEXEC标志位，该标志位的效果与open()函数的O_CLOEXEC一样，表示当执行程序执行exec函数时，在新开的进程当中关闭该描述符，默认情况下，在新开的进程中原来的父进程的描述符依旧处于打开状态。当epoll_create1()的参数设置为0的时候，效果与epoll_create()一样。epoll_create()和epoll_create1()创建的实例在使用结束后要对其描述符调用close()以通知内核销毁实例并释放资源。</p><p>创建完epoll实例后需要设置兴趣列表，使用epoll_ctl()系统调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br></pre></td></tr></table></figure><p>epfd是epoll_create()或epoll_create1()返回的代表epoll实例的文件描述符；op代表操作类型，有三个值：EPOLL_CTL_ADD：将描述符fd注册到epoll实例的兴趣列表中并将event中的事件关联到fd</p><p>EPOLL_CTL_MOD：修改关联到描述符fd的事件</p><p>EPOLL_CTL_DEL：从epoll实例中删除描述符fd</p><p>fd指明哪个文件描述符会被修改；event是一个结构体指针，其指向的值用于存储将要应用于fd的具体的设置。struct epoll_event的结构体定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef union epoll_data &#123;</span><br><span class="line">    void        *ptr;</span><br><span class="line">    int          fd;</span><br><span class="line">    uint32_t     u32;</span><br><span class="line">    uint64_t     u64;</span><br><span class="line">&#125; epoll_data_t;</span><br><span class="line"></span><br><span class="line">struct epoll_event &#123;</span><br><span class="line">    uint32_t     events;      /* Epoll events */</span><br><span class="line">    epoll_data_t data;        /* User data variable */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>stuct epoll_event中的events字段是一个位掩码，指定了描述符fd上感兴趣的事件集合。epoll支持的事件如下所示：</p><table><thead><tr><th align="left">位掩码</th><th align="center">作为epoll_ctl()的输入？</th><th align="center">由epoll_wait()返回？</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">EPOLLIN</td><td align="center">*</td><td align="center">*</td><td align="left">可读取非高优先级的数据</td></tr><tr><td align="left">EPOLLPRI</td><td align="center">*</td><td align="center">*</td><td align="left">可读取高优先级数据</td></tr><tr><td align="left">EPOLLRDHUP</td><td align="center">*</td><td align="center">*</td><td align="left">套接字对端关闭</td></tr><tr><td align="left">EPOLLOUT</td><td align="center">*</td><td align="center">*</td><td align="left">普通数据可写</td></tr><tr><td align="left">EPOLLET</td><td align="center">*</td><td align="center"></td><td align="left">采用边缘触发事件通知</td></tr><tr><td align="left">EPOLLONESHOT</td><td align="center">*</td><td align="center"></td><td align="left">在完成事件通知后禁用检查</td></tr><tr><td align="left">EPOLLERR</td><td align="center"></td><td align="center">*</td><td align="left">有错误发生</td></tr><tr><td align="left">EPOLLHUP</td><td align="center"></td><td align="center">*</td><td align="left">出现挂断</td></tr></tbody></table><p>系统调用epoll_wait返回epoll实例中处于就绪状态的文件描述符信息，单个epoll_wait()调用能返回多个就绪文件描述符的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);</span><br><span class="line">//调用成功则返回就绪文件描述符的数量，超时返回0，失败返回-1</span><br></pre></td></tr></table></figure><p>参数epfd是代表epoll实例的文件描述符；events指向一个结构体数组，用于存储返回的就绪文件描述符的信息，该结构体数组的内存需要调用者负责申请和释放，数组中的元素数量跟maxevents相等，maxevents设置了一个上限，最多maxevents个就绪文件描述符会被epoll_wait返回；timeout用于指定超时时间，单位是毫秒，设置为0时epoll_wait()立即返回，即便没有文件描述符变成就绪状态，设置为-1时epoll_wait()会阻塞直到有文件描述符变成就绪状态。</p><p>使用epoll重写上一章的客户端程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#define MAX_EVENTS 2</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    struct sockaddr_in addr;</span><br><span class="line">    struct epoll_event ev,events[MAX_EVENTS];</span><br><span class="line">    string line;</span><br><span class="line">    char buf[1024]=&#123;0&#125;;</span><br><span class="line">    int connect_fd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(9000);</span><br><span class="line">    inet_pton(AF_INET,&quot;10.211.55.2&quot;,&amp;addr.sin_addr);</span><br><span class="line">    if(connect(connect_fd,(struct sockaddr*)&amp;addr,sizeof(addr))&lt;0)&#123;</span><br><span class="line">        std::cout&lt;&lt;&quot;connect failed&quot;&lt;&lt;std::endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //int epoll_fd = epoll_create(1);</span><br><span class="line">    int epoll_fd = epoll_create1(0);</span><br><span class="line">    ev.data.fd = STDIN_FILENO;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    epoll_ctl(epoll_fd,EPOLL_CTL_ADD,STDIN_FILENO,&amp;ev);</span><br><span class="line">    ev.data.fd = connect_fd;</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    epoll_ctl(epoll_fd,EPOLL_CTL_ADD,connect_fd,&amp;ev);</span><br><span class="line">    for(;;)&#123;</span><br><span class="line">        int nfds = epoll_wait(epoll_fd,events,MAX_EVENTS,-1);</span><br><span class="line">        for(int i=0;i&lt;nfds;++i)&#123;</span><br><span class="line">            if(events[i].data.fd == STDIN_FILENO)&#123;</span><br><span class="line">                //处理标准输入</span><br><span class="line">                getline(std::cin,line);</span><br><span class="line">                write(connect_fd,line.c_str(),line.length());</span><br><span class="line">            &#125;else if(events[i].data.fd == connect_fd&amp;&amp;events[i].events&amp;EPOLLIN)&#123;</span><br><span class="line">                //处理套接字描述符</span><br><span class="line">                memset(buf,0,1024);</span><br><span class="line">                if(read(connect_fd,buf,1024)==0)&#123;</span><br><span class="line">                    std::cout&lt;&lt;&quot;EOF&quot;&lt;&lt;std::endl;</span><br><span class="line">                    goto close;</span><br><span class="line">                &#125;</span><br><span class="line">                std::cout&lt;&lt;buf&lt;&lt;std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close:</span><br><span class="line">    close(epoll_fd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后介绍一下水平触发和边缘触发。水平触发是指当文件描述符上可以非阻塞的执行IO系统调用，此时认为它已经就绪；边缘触发是指如果文件描述符自上次状态检查以来有了新的IO活动才触发通知。举一个简单的例子，假设有一个管道，在管道写的一端写入10kb数据，在读的一端使用epoll_wait()等待文件描述符读就绪，如果设置了水平触发，当文件描述符可读时，程序从中读取5kb数据后停止读取，然后进行下一次epoll_wait()，那么下一次epoll_wait()返回的就绪列表中，依然会包含该文件描述符，因为管道中还有未读取的数据；如果设置了边缘触发，读取5kb数据后下一次epoll_wait()的就绪列表中将不包含该文件描述符，因为虽然管道中还有未读取的数据，但是从上次检查开始管道中并没有发生新的IO活动（例如新的输入），如果epoll_wait()只检查这一个文件描述符，那么第二次epoll_wait()将会阻塞。</p><p>所以当我们应用水平触发时，我们可以在任意时刻重复检查IO状态，也就没有必要每次文件描述符就绪后尽可能多的执行IO；相反，当采用边缘触发时，只有当IO事件发生时我们才会收到通知，所以就需要在收到一个IO事件后尽可能多的执行IO操作。为了避免在进行尽可能多的IO操作是造成阻塞，所以采用边缘触发时，每个被检查的描述符都应该设置为非阻塞模式，在得到IO事件通知后重复执行IO操作，知道相应的系统调用返回错误码EAGAIN。</p><p>假设我们采用边缘触发通知监视多个文件描述符，其中一个处于就绪态的文件描述符 上有着大量的输入存在(可能是一个不间断的输入流)。如果在检测到该文件描述符处于 就绪态后，我们将尝试通过非阻塞式的读操作将所有的输入都读取，那么此时就会有使其 他的文件描述符处于饥饿状态的风险存在(即，在我们再次检查这些文件描述符是否处于 就绪态并执行 I&#x2F;O 操作前会有很长的一段处理时间)。该问题的一种解决方案是让应用程序 维护一个列表，列表中存放着已经被通知为就绪态的文件描述符。通过一个循环按照如下 方式不断处理。</p><ol><li>调用 epoll_wait()监视文件描述符，并将处于就绪态的描述符添加到应用程序维护的 列表中。如果这个文件描述符已经注册到应用程序维护的列表中了，那么这次监视 操作的超时时间应该设为较小的值或者是 0。这样如果没有新的文件描述符成为就 绪态，应用程序就可以迅速进行到下一步，去处理那些已经处于就绪态的文件描述 符了。</li><li>在应用程序维护的列表中，只在那些已经注册为就绪态的文件描述符上进行一定限度 的 I&#x2F;O 操作(可能是以轮转调度(round-robin)方式循环处理，而不是每次 epoll_wait() 调用后都从列表头开始处理)。当相关的非阻塞 I&#x2F;O 系统调用出现 EAGAIN 或 EWOULDBLOCK 错误时，文件描述符就可以从应用程序维护的列表中移除了。</li></ol><p>参考书目：《UNIX环境高级编程》、《Linux&#x2F;UNIX系统编程手册》</p>]]></content>
      
      
      <categories>
          
          <category> Linux网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络编程(五)：IO多路复用</title>
      <link href="/2022/12/17/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%BA%94)%EF%BC%9AIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
      <url>/2022/12/17/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%BA%94)%EF%BC%9AIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>我们先来看一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  std::string line;</span><br><span class="line">  struct sockaddr_in addr;</span><br><span class="line">  char buf[1024]=&#123;0&#125;;</span><br><span class="line">  addr.sin_family=AF_INET;</span><br><span class="line">  addr.sin_port= htons(9000);</span><br><span class="line">  inet_pton(AF_INET,&quot;127.0.0.1&quot;,&amp;addr.sin_addr);</span><br><span class="line">  int fd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">  connect(fd,(const struct sockaddr*)&amp;addr,sizeof(addr));</span><br><span class="line">  while(getline(std::cin,line))&#123;</span><br><span class="line">  if(line.empty())continue;</span><br><span class="line">    write(fd,line.c_str(),line.length());</span><br><span class="line">    memset(buf,0,1024);</span><br><span class="line">    if(read(fd,buf,1024)==0)&#123;</span><br><span class="line">      std::cout&lt;&lt;&quot;EOF&quot;&lt;&lt;std::endl;</span><br><span class="line">      break;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      std::cout&lt;&lt;buf&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，实现的功能是连接服务器，成功后等待标准输入，然后将输入的内容写入套接字描述符，发给服务器，然后从套接字描述符中读取服务器发回的信息并显示在标准输出上，如果读到了文件结束符，就退出循环。为了简洁，我没有写错误处理的代码：）。我们使用上一章我们完成的服务端代码。程序按照预想成功运行了，在客户端输入一行信息发送给服务端后，会收到服务端的回信。此时如果我们杀死服务端的程序，会发现，客户端程序依旧在运行，我们再输入一行数据后发现客户端程序打印EOF后退出。好像没什么问题，那如果我想让每次循环中多做些事呢？比如，发送多条信息，而且这多条信息还不是使用同一个TCP分组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while(getline(std::cin,line))&#123;</span><br><span class="line">  if(line.empty())continue;</span><br><span class="line">  write(fd,line.c_str(),line.length());</span><br><span class="line">  std::this_thread::sleep_for(std::chrono::seconds(1));//这里睡眠1秒钟，是为了让两条信息不被合成一条</span><br><span class="line">  write(fd,line.c_str(),line.length());</span><br><span class="line">  memset(buf,0,1024);</span><br><span class="line">  if(read(fd,buf,1024)==0)&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;EOF&quot;&lt;&lt;std::endl;</span><br><span class="line">    break;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    std::cout&lt;&lt;buf&lt;&lt;std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用相同的测试方法后发现，修改后的客户端程序因为信号SIGPIPE被终止了!只是因为每次循环多发了一条消息吗？是的！在分析原因之前，我们先要了解一个TCP的机制，如果TCP一端向对端发送FIN分节，对端TCP回复ACK后，发送FIN这一端到对端的数据流就关闭了，如果对端向这一端发送数据，这一端会发送一个RST分节作为回应，如果对端在接收到RST分解后再次向TCP连接中发送数据，就会导致内核向进程发送一个SIGPIPE信号。</p><p>现在再来分析上面的代码，会发现代码阻塞在getline函数等待用户输入，服务器程序被杀死后，TCP会发送FIN给客户端TCP，由于客户端阻塞在标准输入上，所以无法及时从TCP中读取到EOF并做出相应的处理。这就导致下一次用户输入后，程序向一个已经收到FIN的TCP连接套接字写入两次数据，第一次write引发RST，第二次write产生SIGPIPE。导致这一切的罪魁祸首就是我们使用了阻塞式IO,在等待用户输入的时候，没办法再进行其他IO操作。IO多路复用技术可以帮我们解决这个问题，它可以允许单线程的程序同时处理多个描述符，也就是说使用了IO多路复用技术，我们可以一边处理用户输入，一边处理套接字描述符的读写，而不用阻塞在某一个操作上。</p><p>常用的IO复用技术使用select、poll，这两种方式是从unix系统中传承下来的，linux内核提供了更强大的epoll，本章我们先介绍select和poll的用法，epoll的用法之后会单独介绍。</p><p>select函数签名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/select.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">int select(int maxfd,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout);</span><br></pre></td></tr></table></figure><p>该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经理一段指定的时间后才唤醒它。通过设置读、写和异常三个描述符集，我们告诉内核我们对哪些描述符感兴趣。函数的第一个参数表示等待测试的描述符的个数，它的值等于待测试的最大描述符加1。第2、3、4个参数分别表示读、写和异常描述符集，它们是值-结果参数，在调用select之前，我们将我们感兴趣的描述符写入相应的描述符集，select返回后，如果某个描述符就绪了，它会被写入相应的描述符集。比如我们想要测试描述符5的写条件，我们将其放入writeset，后调用select，select返回后，我们对writeset进行测试，如果其中含有描述符5，那么说明描述符5已经写就绪了。最后一个参数是一个timeval结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sturct timeval&#123;</span><br><span class="line">long tv_set;//秒</span><br><span class="line">long tv_usec;//微秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当该参数设置为空指针时，select会阻塞直到一个描述符IO就绪；当设置了非零的timeval，select等待一段固定的时间；当设置0时，不等待，检查后直接返回。</p><p>select的描述符集通常是一个整数数组，其中每个整数的每一位对应一个描述符。相关的操作由四个宏完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void FD_ZERO(fd_set *fdset);//清空描述符集中的所有位</span><br><span class="line">void FD_SET(int fd,fd_set *fdset);//将fd对应的位置位</span><br><span class="line">void FD_CLR(int fd,fd_set *fdset);//将fd对应的位复位</span><br><span class="line">int FD_ISSET(int fd,fd_set *fdset);//测试fd是否置位</span><br></pre></td></tr></table></figure><p>使用select改写后，我们的客户端代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  std::string line;</span><br><span class="line">  struct sockaddr_in addr;</span><br><span class="line">  char buf[1024]=&#123;0&#125;;</span><br><span class="line">  int maxfd=0;</span><br><span class="line">  addr.sin_family=AF_INET;</span><br><span class="line">  addr.sin_port= htons(9000);</span><br><span class="line">  inet_pton(AF_INET,&quot;127.0.0.1&quot;,&amp;addr.sin_addr);</span><br><span class="line">  int fd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">  connect(fd,(const struct sockaddr*)&amp;addr,sizeof(addr));</span><br><span class="line">  fd_set rset;</span><br><span class="line">  FD_ZERO(&amp;rset);</span><br><span class="line">  for(;;)&#123;</span><br><span class="line">    FD_SET(STDIN_FILENO,&amp;rset);</span><br><span class="line">    FD_SET(fd,&amp;rset);</span><br><span class="line">    maxfd = std::max(STDIN_FILENO,fd)+1;</span><br><span class="line">    select(maxfd,&amp;rset, nullptr, nullptr, nullptr);</span><br><span class="line">    if(FD_ISSET(STDIN_FILENO,&amp;rset))&#123;</span><br><span class="line">      //处理标准输入</span><br><span class="line">      getline(std::cin,line);</span><br><span class="line">      write(fd,line.c_str(),line.length());</span><br><span class="line">    &#125;</span><br><span class="line">    if(FD_ISSET(fd,&amp;rset))&#123;</span><br><span class="line">      //处理套接字描述符</span><br><span class="line">      memset(buf,0,1024);</span><br><span class="line">      if(read(fd,buf,1024)==0)&#123;</span><br><span class="line">        std::cout&lt;&lt;&quot;EOF&quot;&lt;&lt;std::endl;</span><br><span class="line">        return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      std::cout&lt;&lt;buf&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码一如既往的简陋，不过足以演示select的用法了，程序阻塞在select函数，而不是某一个IO操作上。标准输入和TCP套接字任何一个可读时，select返回，后面的代码进行相应的处理。使用新的客户端代码后，服务端程序被杀死时，客户端程序能及时处理EOF。</p><p>我们再来看poll函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">int poll(struct pollfd *fdarray,unsigned long nfds,int timeout);</span><br></pre></td></tr></table></figure><p>第一个参数是指向一个结构数据第一个元素的指针。每个数组元素都是一个pollfd结构，用于指定测试某个给定描述符的条件，nfds指定数组中元素的个数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd&#123;</span><br><span class="line">int fd;</span><br><span class="line">short events;//fd感兴趣的事件</span><br><span class="line">short revents;//fd上发生的事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟select的直结果参数不同，pollfd将输入的时间和返回的时间分别存在两个变量中，events和revents的值如下表所示：</p><table><thead><tr><th align="center">常量</th><th align="center">作为events的值</th><th align="center">作为revents的值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">POLLIN</td><td align="center">*</td><td align="center">*</td><td align="center">普通或优先级带数据可读</td></tr><tr><td align="center">POLLRDNORM</td><td align="center">*</td><td align="center">*</td><td align="center">普通数据可读</td></tr><tr><td align="center">POLLRDBAND</td><td align="center">*</td><td align="center">*</td><td align="center">优先级带数据可读</td></tr><tr><td align="center">POLLPRI</td><td align="center">*</td><td align="center">*</td><td align="center">高优先级数据可读</td></tr><tr><td align="center">POLLOUT</td><td align="center">*</td><td align="center">*</td><td align="center">普通数据可写</td></tr><tr><td align="center">POLLWRNORM</td><td align="center">*</td><td align="center">*</td><td align="center">普通数据可写</td></tr><tr><td align="center">POLLWRBAND</td><td align="center">*</td><td align="center">*</td><td align="center">优先级带数据可写</td></tr><tr><td align="center">POLLERR</td><td align="center"></td><td align="center">*</td><td align="center">发生错误</td></tr><tr><td align="center">POLLHUP</td><td align="center"></td><td align="center">*</td><td align="center">发生挂起</td></tr><tr><td align="center">POLLNVAL</td><td align="center"></td><td align="center">*</td><td align="center">描述符不是一个打开的文件</td></tr></tbody></table><p>timeout的值表示毫秒数，等于0时立即返回，可以设置为常量INFTIM表示永远等待。poll返回就绪描述符的数目，若超时则返回0，出错返回-1。</p><p>使用poll函数实现的客户端代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;poll.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  std::string line;</span><br><span class="line">  struct sockaddr_in addr;</span><br><span class="line">  char buf[1024]=&#123;0&#125;;</span><br><span class="line">  addr.sin_family=AF_INET;</span><br><span class="line">  addr.sin_port= htons(9000);</span><br><span class="line">  inet_pton(AF_INET,&quot;127.0.0.1&quot;,&amp;addr.sin_addr);</span><br><span class="line">  int fd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">  connect(fd,(const struct sockaddr*)&amp;addr,sizeof(addr));</span><br><span class="line">  struct pollfd client[2];</span><br><span class="line">  client[0].fd = STDIN_FILENO;</span><br><span class="line">  client[0].events = POLLIN;</span><br><span class="line">  client[1].fd = fd;</span><br><span class="line">  client[1].events = POLLIN;</span><br><span class="line">  for(;;)&#123;</span><br><span class="line">    poll(client,2,1000);</span><br><span class="line">    if(client[0].revents&amp;POLLIN)&#123;</span><br><span class="line">      //处理标准输入</span><br><span class="line">      getline(std::cin,line);</span><br><span class="line">      write(fd,line.c_str(),line.length());</span><br><span class="line">    &#125;</span><br><span class="line">    if(client[1].revents&amp;POLLIN)&#123;</span><br><span class="line">      //处理套接字描述符</span><br><span class="line">      memset(buf,0,1024);</span><br><span class="line">      if(read(fd,buf,1024)==0)&#123;</span><br><span class="line">        std::cout&lt;&lt;&quot;EOF&quot;&lt;&lt;std::endl;</span><br><span class="line">        return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      std::cout&lt;&lt;buf&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> select()和 poll()是是可移植的、 长期存在且被广泛使用的。但是当检查大量的文件描述符时，这两个 API 都会遇到一些问题：</p><ol><li>每次调用 select()或 poll()，内核都必须检查所有被指定的文件描述符，看它们是否处于就绪态。当检查大量处于密集范围内的文件描述符时，该操作耗费的时间将大大超过接下来的操作。</li><li>select的调用需要设定描述符集，poll需要设置pollfd数组，这些数据结构在函数调用时需要被传输到内核当中，执行完毕后再从内核中返回，当检查大量文件描述符时，从用户空间到内核空间来回拷贝这个数据结构会占用大量的CPU时间，对于poll来说随着文件描述符数量的增加，数组占用会越来越大，所以select来说这个数据结构大小是固定FD_SETSIZE。</li><li>select()或 poll()调用完成后，程序必须检查返回的数据结构中的每个元素，以此查明哪个文件描述符处于就绪态。</li></ol><p>参考书目：《UNIX网络编程》、《UNIX环境高级编程》、《Linux&#x2F;UNIX系统编程手册》</p>]]></content>
      
      
      <categories>
          
          <category> Linux网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络编程(四)：TCP套接字编程-part3</title>
      <link href="/2022/12/17/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E5%9B%9B)%EF%BC%9ATCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B-part3/"/>
      <url>/2022/12/17/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E5%9B%9B)%EF%BC%9ATCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B-part3/</url>
      
        <content type="html"><![CDATA[<p>上一章我们实现了一个服务器小程序，但是那个程序只能处理单个连接，本章我们将对其进行改进，使用fork子线程的方式实现一个并发服务器程序。</p><p>先看一下fork的函数签名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t fork(void)</span><br></pre></td></tr></table></figure><p>fork函数用于创建子线程，其特殊之处在于，它被调用一次，但返回两次：在父进程中，fork函数返回子进程的进程ID，在子进程中返回0，出错则返回-1；所以使用fork创建子进程的代码一般会这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(pid = fork() &lt; 0)&#123;</span><br><span class="line">//错误处理</span><br><span class="line">&#125;else if(pid == 0)&#123;</span><br><span class="line">//子进程接下来的处理</span><br><span class="line">&#125;else&#123;</span><br><span class="line">//父进程接下来的处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本，拥有父进程的数据空间、堆和栈的副本。父进程和子进程共享正文段（正文段是指CPU执行的机器指令部分）。</p><p>根据上面介绍的fork的用法，我们的服务端程序可以进行如下修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">for(;;)&#123;</span><br><span class="line">  connected_fd = accept(listen_fd,(struct sockaddr*)&amp;client_addr,&amp;len);</span><br><span class="line">  if(connected_fd==-1)&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;accept failed :&quot;&lt;&lt;strerror(errno)&lt;&lt;std::endl;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  if((pid=fork())&lt;0) &#123;</span><br><span class="line">    //错误处理</span><br><span class="line">    std::cerr&lt;&lt;&quot;Fail to fork subprocess&quot;&lt;&lt;std::endl;</span><br><span class="line">  &#125;else if(pid==0)&#123;</span><br><span class="line">    //子进程</span><br><span class="line">    close(listen_fd);</span><br><span class="line">    std::cout&lt;&lt;&quot;New connection from:&quot;&lt;&lt;inet_ntop(AF_INET,&amp;client_addr.sin_addr,cli_addr_buf,128)&lt;&lt;&quot;:&quot;</span><br><span class="line">    &lt;&lt;ntohs(client_addr.sin_port)&lt;&lt;std::endl;</span><br><span class="line">    while(read(connected_fd,buf,1024))&#123;</span><br><span class="line">      write(connected_fd,ack_msg_prefix.append(buf).c_str(),ack_msg_prefix.length());</span><br><span class="line">      memset(buf,0,1024);</span><br><span class="line">      ack_msg_prefix = &quot;Receive msg:&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    //父进程</span><br><span class="line">    close(connected_fd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改的范围从调用listen函数以后开始，为了节省篇幅，其他代码省略。这样修改以后，每当有新的客户端连接，服务器都会fork一个子进程，而主进程则继续阻塞在accept函数，等待新的连接。子进程不需要调用accept函数等待新连接，所以调用close将监听套接字listen_fd关闭；同理父进程不需要处理已连接套接字，所以调用close关闭connected_fd。</p><p>在父函数调用close关闭connected_fd并不会关闭子进程中对应的TCP连接，同理子进程中关闭listen_fd也不会关闭父进程的监听套接字。每个文件或套接字都有一个引用计数。引用计数在文件表项中维护，表示当前打开着的引用该文件或套接字的描述符的个数。fork返回后，两个描述符在父子进程之间共享，所以各自的引用计数会变成2。close函数的调用只是将描述符的引用计数减1，如果描述符的引用计数在减1以后仍然大于0，那么该描述符就不会被关闭。</p><p>当子线程终止以后，会向父进程发送一个SIGCHLD信号。该信号默认是被忽略的，所以如果没有特殊设置，子进程终止以后，父进程不会做任何相应的处理，这是子进程就会进入僵死状态。设置僵死状态的目的是维护子进程的信息，以便父进程在以后某个时候获取，这些信息包括子进程的进程ID、终止状态以及资源利用信息如CPU时间、内存用量等等。如果父进程一直不处理子进程的僵死状态，那么当父进程退出后，子进程会变成孤儿进程进而被init进程收养，然后init进程会清理这些子进程，清理的方式是调用wait函数。僵死进程会占用内核的空间，所以父进程应该及时清理僵死的子进程，而不要等待父进程退出后交给init进程处理。上文说到子进程终止以后会给父进程发送一个SIGCHLD信号，所以我们可以添加一个信号处理函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void handler(int sig_num)&#123;</span><br><span class="line">  pid_t pid;</span><br><span class="line">  int stat;</span><br><span class="line">  pid=wait(&amp;stat);</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">signal(SIGCHLD,handler);</span><br></pre></td></tr></table></figure><p>signal()函数为信号SIGCHLD绑定一个处理函数handler，handler由一个int类型的参数，并且没有返回值。当信号发出时，信号的值会被当做参数传给handler函数。在handler函数中调用wait函数可以清除子进程的僵死状态。跟wait函数会处理第一个终止的子进程，另外有一个waitpid函数可以处理指定线程ID的子进程，下面是两个函数的签名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">pid_t wait(int *statloc);</span><br><span class="line">pid_t waitpid(pid_t pid,int *statloc,int options);</span><br></pre></td></tr></table></figure><p>两个函数调用成功会返回进程ID，出错会返回0或-1。statloc是一个值结果参数，用于保存子进程终止状态。options用于设置附加选项，比如WNOHANG告知内核在没有已终止子进程时不要阻塞。wait函数会阻塞直到出现第一个终止的子进程。</p><p>实际应用当中可能会遇到多个子进程同时结束的场景，此时多个SIGCHLD信号同时发送给父进程，而Linux信号一般是不排队的，意思就是信号处理函数在这种情况下只会被调用一次。此时如果在handler中使用wait函数处理子进程，那么就只有一个僵死状态的子进程会被处理，这显然是不符合预期的。那可不可以在一个循环中调用wait函数来处理所有的子进程呢？如果使用这种方式，当所有已终止的子进程都被处理完后，wait函数会阻塞在那里等待下一个僵死的子进程，handler函数将永远不会退出。正确的解决办法是使用waitpid函数，waitpid函数的第一个参数指定了子进程ID，如果设置为-1，函数就会等待第一个终止的子进程，如果没有额外设置，此时waitpid跟wait是等效的，但是waitpid提供了WNOHANG选项，这允许waitpid在没有终止的子进程时不要阻塞，这样就可以在处理完所有僵死状态的子进程后退出信号处理函数了。使用waitpid修改后的信号处理函数如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void handler(int sig_num)&#123;</span><br><span class="line">  pid_t pid;</span><br><span class="line">  int stat;</span><br><span class="line">  while((pid=waitpid(-1,&amp;stat,WNOHANG))&gt;0)</span><br><span class="line">    std::cout&lt;&lt;&quot;child:&quot;&lt;&lt;pid&lt;&lt;&quot; terminated&quot;&lt;&lt;std::endl;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用netcat模拟客户端进行测试，创建两个客户端连接后，使用ps命令查询服务器进程：</p><p><img src="https://raw.githubusercontent.com/wxyfq/blog-pic/master/image-20221217173130489.png" alt="image-20221217173130489"></p><p>可以看到有两个子进程，我们使用kill命令杀掉其中一个观察输出：</p><p><img src="https://raw.githubusercontent.com/wxyfq/blog-pic/master/image-20221217173244770.png" alt="image-20221217173244770"></p><p>接下来我们再使用netcat创建一个客户端连接：</p><p><img src="https://raw.githubusercontent.com/wxyfq/blog-pic/master/image-20221217173348934.png" alt="image-20221217173348934"></p><p>新连接成功创建，这就是使用waitpid的好处，如果我们用wait函数代替，那么当我们杀死一个子线程触发了信号处理函数后，将再也无法创建新的客户端连接了。</p><p>参考书目：《UNIX网络编程》、《UNIX环境高级编程》</p>]]></content>
      
      
      <categories>
          
          <category> Linux网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络编程(三)：TCP套接字编程-part2</title>
      <link href="/2022/12/14/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%89)%EF%BC%9ATCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B-part2/"/>
      <url>/2022/12/14/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%89)%EF%BC%9ATCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B-part2/</url>
      
        <content type="html"><![CDATA[<p>上一章我们使用socket函数和connect函数写了一个简单的连接服务器并发送数据的小程序，本章我们尝试使用bind，listen和accept这三个函数写一个服务端程序，用于接收来自客户端的数据，然后打印到控制台。</p><p>先来看一下bind函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen);//成功返回0，出错返回-1</span><br></pre></td></tr></table></figure><p>bind函数把一个本地协议地址赋予一个套接字。对于网际协议，协议地址是32位的IPv4地址或128位的IPv6地址与16位TCP或UDP端口号的组合。</p><p>函数第一个参数代表套接字描述符，第二个参数是一个通用套接字地址结构的指针，第三个参数是该地址结构的长度。对于TCP，调用bind函数可以指定端口号或地址，也可两者都指定，也可以两者都不指定。</p><p>服务器启动时一般会绑定一个众所周知的端口，例如web服务器的80端口，ftp服务器的21端口。如果不调用bind函数，那么在调用connect或listen函数时，内核会为响应的套接字选择一个临时的端口，对于客户端程序来说，让内核选择临时端口是很常规的行为，但是对于服务器来说确实很罕见的。</p><p>进程也可以把一个特定的IP地址绑定在套接字上，这个IP地址必须属于其所在主机的网络接口之一。对于客户端来说，为套接字绑定一个IP地址就为在该套接字上发送的IP数据报指派了源IP地址；对于服务器来说，就限定该套接字只能接收目的地地址为这个IP地址的客户端的连接。TCP客户端通常不绑定IP地址，让内核根据其所有的外出网络接口选择源IP地址；TCP服务器如果不绑定IP地址，内核就将客户发送的SYN的目的IP地址作为服务器的源IP地址。</p><p>如果指定端口号为0，那么内核在bind被调用时选择一个临时端口号。但是如果指定IP地址为通配地址，内核将等到套接字已连接（TCP）或已在套接字上发送数据报（UDP）时才选择一个本地IP地址。</p><p>IPv4的通配地址使用INADDR_ANY指定，其值一般为0，可以这样使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in addr;</span><br><span class="line">addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br></pre></td></tr></table></figure><p>上述代码直接将0赋给了sin_addr结构体中的s_addr字段，因为其类型是一个32位的无符号整型。</p><p>IPv6的地址存放在一个结构体中，所以使用一个系统预分配的in6addr_any变量为其赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in6 addr;</span><br><span class="line">addr.sin6_addr = in6addr_any;</span><br></pre></td></tr></table></figure><p>TCP服务器调用bind函数绑定过地址和端口后，接下来会调用调用listen函数。当socket函数创建一个套接字时，它被假设为一个主动套接字，也就是说，它是一个将被用于connect发起连接的客户端套接字。listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求，这个套接字也称为监听套接字。调用listen后，套接字状态会从CLOSED转换为LISTEN。listen函数签名如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int listen(int socketfd,int backlog);</span><br></pre></td></tr></table></figure><p>参数backlog用于指定内核应该为相应套接字排队的最大连接个数。内核为任何一个给定的监听套接字维护两个队列：未完成连接队列和已完成连接队列。当服务端TCP收到SYN分节后，TCP在未完成连接队列中创建一个新项目，然后发送ACK给客户端，TCP状态由LISTEN转换成SYN_RCVD，该项会一直保留在未完成队列中直到三路握手完成或者超时；服务器TCP收到来自客户端TCP的ACK分节后，TCP状态由SYN_RCVD转换为ESTABLISHED，三路握手完成，该连接会从未完成连接队列转移到已完成连接队列尾部。调用accept函数会从已完成连接队列头部返回一个TCP连接给进程，如果队列为空，那么进程将会阻塞在调用点直到队列中有新的TCP连接。</p><p>backlog指定的是两个队列总和的最大值。可以通过环境变量设置一个值，即使这个值超过了系统支持的最大值，内核也会对其进行截断的。</p><p>accept函数由TCP服务器调用，用于从已完成连接队列头返回下一个已完成连接，如果已完成连接队列为空，那么进程会阻塞在调用点，这里假定套接字默认为阻塞方式。accept的函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int accept(int sockfd,struct sockaddr *cliaddr,socklen_t *addrlen);</span><br></pre></td></tr></table></figure><p>参数sockfd表示监听套接字的描述符，cliaddr和addrlen是值-结果参数，用来返回已连接的对端进程的协议地址和地址长度。accept成功会返回一个由内核生成的套接字描述符，表示与客户端的TCP连接，失败会返回-1.</p><p>accept返回的套接字描述符是一个已连接套接字描述符。一个服务器通常仅仅创建一个监听套接字，内核会为每个由服务器进程接受的客户连接创建一个已连接套接字。至此，我们可以写一个简单的服务器程序，程序监听9000端口，接收客户端连接请求成功创建已连接套接字后在终端中输出客户端地址，然后从套接字中读取信息（阻塞读），读取到信息后再将信息回写到套接字中，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">  int listen_fd,connected_fd;</span><br><span class="line">  socklen_t len;</span><br><span class="line">  char buf[1024]=&#123;&#125;;</span><br><span class="line">  char cli_addr_buf[128];</span><br><span class="line">  std::string ack_msg_prefix = &quot;Server receive msg:&quot;;</span><br><span class="line">  struct sockaddr_in server_addr,client_addr;</span><br><span class="line">  memset(&amp;server_addr,0,sizeof(server_addr));</span><br><span class="line">  server_addr.sin_family = AF_INET;</span><br><span class="line">  server_addr.sin_port = htons(9000);</span><br><span class="line">  server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">  listen_fd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">  if(bind(listen_fd,(struct sockaddr*)&amp;server_addr,sizeof(server_addr)))&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;bind failed :&quot;&lt;&lt;strerror(errno)&lt;&lt;std::endl;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;;</span><br><span class="line">  if(listen(listen_fd,10))&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;listen failed :&quot;&lt;&lt;strerror(errno)&lt;&lt;std::endl;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  connected_fd = accept(listen_fd,(struct sockaddr*)&amp;client_addr,&amp;len);</span><br><span class="line">  if(connected_fd==-1)&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;accept failed :&quot;&lt;&lt;strerror(errno)&lt;&lt;std::endl;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout&lt;&lt;&quot;Connection from:&quot;&lt;&lt;inet_ntop(AF_INET,&amp;client_addr.sin_addr,cli_addr_buf,128)&lt;&lt;std::endl;</span><br><span class="line">  while(read(connected_fd,buf,1024))&#123;</span><br><span class="line">    write(connected_fd,ack_msg_prefix.append(buf).c_str(),ack_msg_prefix.length());</span><br><span class="line">    memset(buf,0,1024);</span><br><span class="line">    ack_msg_prefix = &quot;Receive msg:&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码编译运行后使用netcat模拟客户端，调用命令：nc 127.0.0.1 9000连接服务器，这里使用127.0.0.1作为地址是因为服务器程序是在本机上运行的。调用命令后，想控制台输入信息，会得到服务器的回应：</p><p><img src="https://raw.githubusercontent.com/wxyfq/blog-pic/master/image-20221215185929553.png?token=ABX7WFTW5KT2WQF7QBJ6PT3DTL7FW" alt="image-20221215185929553"></p><p>上面的服务器程序只调用了一次accept函数，也就是只接受一个连接，当连接终止后，服务器程序就退出了，实际开发中，会有一个无限循环，accept每次返回一个已连接套接字描述符，服务器可以选择fork一个子进程或新建一个线程来负责新连接的通讯，也可以选择IO多路复用技术在当前线程处理。</p><p>参考书目：《UNIX网络编程》</p>]]></content>
      
      
      <categories>
          
          <category> Linux网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络编程(二)：TCP套接字编程-part1</title>
      <link href="/2022/12/14/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%BA%8C)%EF%BC%9ATCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B-part1/"/>
      <url>/2022/12/14/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%BA%8C)%EF%BC%9ATCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B-part1/</url>
      
        <content type="html"><![CDATA[<p>套接字编程的第一步需要调用socket函数获取一个套接字描述符，套接字函数签名如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int socket(int family,int type,int protocol);</span><br></pre></td></tr></table></figure><p>函数的family参数知名协议族，type表示套接字类型，protocol表示协议类型。</p><p>协议族的可选值如下表所示：</p><table><thead><tr><th align="center">family</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">AF_INET</td><td align="center">IPv4协议</td></tr><tr><td align="center">AF_INET6</td><td align="center">IPv6协议</td></tr><tr><td align="center">AF_LOCAL</td><td align="center">Unix域协议</td></tr><tr><td align="center">AF_ROUTE</td><td align="center">路由套接字</td></tr><tr><td align="center">AF_KEY</td><td align="center">密钥套接字</td></tr></tbody></table><p>type可选值如下表所示：</p><table><thead><tr><th align="center">type</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">SOCK_STREAM</td><td align="center">字节流套接字</td></tr><tr><td align="center">SOCK_DGRAM</td><td align="center">数据报套接字</td></tr><tr><td align="center">SOCK_SEQPACKET</td><td align="center">有序分组套接字</td></tr><tr><td align="center">SOCK_RAW</td><td align="center">原始套接字</td></tr></tbody></table><p>protocol可选值如下表所示：</p><table><thead><tr><th align="center">protocol</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">IPPROTO_TCP</td><td align="center">TCP传输协议</td></tr><tr><td align="center">IPPROTO_UDP</td><td align="center">UDP传输协议</td></tr><tr><td align="center">IPPROTO_SCTP</td><td align="center">SCTP传输协议</td></tr></tbody></table><p>在调用socket函数时，可以讲protocol的值设置为0，此时函数会根据family和type的值推断出一个默认值。socket函数成功创建套接字描述符时会返回一个表示该描述符的非负整数，如果创建失败则会返回-1。现在我们来创建一个socket套接字描述符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fd = socket(AF_INET,SOCK_STREAM,0);</span><br></pre></td></tr></table></figure><p>获取socket套接字描述符后，可以直接调用connect函数连接服务器，也可以先调用bind函数绑定本地ip和端口，客户端程序没有特殊需求一般不用调用bind函数，此时内核会为TCP分配本地的IP地址和一个临时端口号。这里我们暂时不管bind，先看一下connect的函数签名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int connect(int sockfd,const struct sockaddr *servaddr,socklen_t addrlen)</span><br></pre></td></tr></table></figure><p>sockfd参数表示socket函数返回的套接字描述符；servaddr是指向通用套接字地址结构的指针，用来表示希望连接的对端的地址，addrlen标志套接字地址结构的大小。connect函数成功会返回0，失败会返回-1。</p><p>我们先看一下套接字地址结构体的定义，IPv4套接字地址结构定义在头文件&lt;netinet&#x2F;in.h&gt;中，其POSIX定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct in_addr&#123;</span><br><span class="line">in_addr_t s_addr;</span><br><span class="line">&#125;</span><br><span class="line">struct sockaddr_in&#123;</span><br><span class="line">uint8_t sin_len;</span><br><span class="line">sa_family_t sin_family;</span><br><span class="line">in_port_tsin_port;</span><br><span class="line">struct in_addrsin_addr;</span><br><span class="line">charsin_zero[8]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POSIX规范只需要这个结构中的3个字段：sin_family、sin_addr和sin_port。长度字段sin_len是为了对OSI的支持后期添加的，POSIX对该字段也没有要求，我们也不需要手动设置该字段，该字段的值一般为16。sin_zero从来没有启用过，但是应该将其设置为0，这可以通过使用memset函数将整个结构置为0完成。</p><p>sin_family表示套接字地址结构的协议族，跟上文中提到的socket协议族取值是一致的；sin_addr表示一个存放地址的结构体in_addr，in_addr结构体中只有一个in_addr_t类型的字段s_addr，用于存储IPv4地址，in_addr_t的数据类型是一个至少32位的无符号整型；sin_port用于存放端口号，其类型in_port_t至少是一个16位的无符号整型。需要注意的是IPv4地址和端口号在套接字地址结构中总是以网络字节序存储，关于字节序我们稍后会说明。</p><p>我们发现sockaddr_in并不是connect函数中要求的sockaddr结构体。当套接字地址结构作为参数传递给任何套接字函数时，总是以指针的形式传递。这种方式就要求套接字函数可以处理来自任何协议族的的套接字地址结构，我们知道C语言是没有函数重载的概念的。ANSI C可以通过传递一个void*通用指针方式解决问题。然而套接字函数的出现早于ANSI C，所以解决方式就是增加一个通用套接字地址结构，特定协议族的套接字地址结构体指针需要强制转换为通用套接字地址结构指针后才能传递给套接字函数。通用套接字地址的结构定义在&lt;sys&#x2F;socket.h&gt;头文件中，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr&#123;</span><br><span class="line">uint8_tsa_len;</span><br><span class="line">sa_family_tsa_family;</span><br><span class="line">charsa_data[14]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IPv6套接字地址的结构以及与之匹配的新的通用套接字sockaddr_storage地址结构在&lt;netinet&#x2F;in.h&gt;头文件中定义，相比于sockaddr有以下两点区别：</p><ol><li>如果系统支持的任何套接字地址结构有对齐需要，那么sockaddr_storage能够满足最苛刻的对齐要求。</li><li>sockaddr_storage足够大，能够容纳系统支持的任何套接字地址结构。</li></ol><p>关于IPv6的内容以后有机会再单独介绍。</p><p>根据上面的介绍，我们知道套接字地址结构中的sin_family，sin_port和sin_addr是需要我们手动设置的，分别对应协议族，端口号和IP地址，协议族我们可以设置，IPv4我们选择AF_INET。端口号不能直接设置，因为上面提到过地址结构中的ip和端口号都是以网络字节序存储的，所以我们需要先了解一下什么是字节序。</p><p>假设有一个16位整数，由2个字节组成。内存中存储这两个字节有两种办法，一种是将低序字节存储在起始地址，这种存储顺序称为小端字节序；另一种方法是将高序字节存储在起始地址，这称为大端字节序。我们可以写一个简单的程序来测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void byteorder() &#123;</span><br><span class="line">union</span><br><span class="line">&#123;</span><br><span class="line">short value;</span><br><span class="line">char union_bytes[sizeof(short)];</span><br><span class="line">&#125;test;</span><br><span class="line">test.value = 0x0102;</span><br><span class="line">if ((test.union_bytes[0] == 1) &amp;&amp; (test.union_bytes[1] == 2)) &#123;</span><br><span class="line">printf(&quot;big endian\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if ((test.union_bytes[0] == 2) &amp;&amp; (test.union_bytes[1] == 1)) &#123;</span><br><span class="line">printf(&quot;little endian\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">printf(&quot;unknow\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“小端”和“大端”表示多个字节值的哪一端存储在该值的起始地址。</p><p>给定系统所使用的字节序称为主机字节序，主机字节序一般为小端字节序，但是不是一定的；网络协议使用大端字节序来传送这些多字节整数，所以大端字节序又叫做网络字节序。在实际操作中我们并不需要关注主机字节序究竟是哪种字节序，只需要调用相应的函数在主机字节序和网络字节序之间相互转换即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">uint16_t htons(uint16_t host16bitvalue);</span><br><span class="line">uint32_t hton1(uint32_t host32bitvalue);//从主机字节序向网络字节序转换</span><br><span class="line">uint16_t ntohs(uint16_t net16bitvalue); </span><br><span class="line">uint32_t ntohl(uint32_t net32bitvalue);//从网络字节序向主机字节序转换</span><br></pre></td></tr></table></figure><p>到现在为止我们可以写入如下的代码来创建一个套接字地址结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in addr;</span><br><span class="line">memset(&amp;addr,0,sizeof(addr));</span><br><span class="line">addr.sin_family=AF_INET;</span><br><span class="line">addr.sin_port= htons(9000);</span><br></pre></td></tr></table></figure><p>还剩下最后一步，设置ip地址。人类可读的常见的IP地址是用点分十进制的形式表示的，如：192.168.0.1，但是套接字地址结构体中的ip地址是以网络字节序的二进制值存储的，所以我们还需要将以点分十进制表示的ip地址值转换为以网络字节序表示的二进制值。头文件&lt;arpa&#x2F;inet.h&gt;中提供的两个转换函数可以完成两者之间的转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int inet_pton(int family,const char* strptr,void *addrptr);</span><br><span class="line">const char *inet_ntop(int family,const void *addrptr,char *strptr,size_t len);</span><br></pre></td></tr></table></figure><p>两个函数的family参数可以是AF_INET，也可以是AF_INET6。如果设置了不被支持的地址族，函数会返回一个错误，errno会被设置为EAFNOSUPPORT。</p><p>inet_pton函数将字符串strptr表示的点分十进制地址转换为二进制值存储到指针addrptr指向的内存地址，指针addrptr指向套接字中的地址字段sin_addr。成功返回1，如果输入不是有效表达式返回0，若出错返回-1。</p><p>inet_ntop进行相反的转换，转换的结果存储到strptr指向的内存，len表示内存的大小。成功返回指向结果的指针，出错返回NULL。</p><p>所以将点分十进制地址“127.0.0.1”转换并存储到地址套接字相应字段的代码可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inet_pton(AF_INET,&quot;127.0.0.1&quot;,&amp;addr.sin_addr);</span><br></pre></td></tr></table></figure><p>为了简（tou）洁（lan），这里省略了错误判断。</p><p>所以现在，我们就可以写出客户端连接服务端的代码了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in addr;</span><br><span class="line">memset(&amp;addr,0,sizeof(addr));</span><br><span class="line">addr.sin_family=AF_INET;</span><br><span class="line">addr.sin_port= htons(9000);</span><br><span class="line">inet_pton(AF_INET,&quot;127.0.0.1&quot;,&amp;addr.sin_addr);</span><br><span class="line">int fd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">if(!connect(fd,(const struct sockaddr*)&amp;addr,sizeof(addr)))&#123;</span><br><span class="line">  write(fd,&quot;hello\n&quot;,6);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  cout&lt;&lt;&quot;connect failed&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用connect函数连接本机的9000端口，函数成功返回后我们就得到了一个TCP连接，通过套接字描述符可以向连接中写入数据，我们调用write函数写入“hello”字符串。这里为了方（zai）便（ci）演（tou）示（lan），使用了硬编码，实际操作时不要用这么不专业的写法。</p><p>我们可以使用netcat模拟服务端，在终端调用命令“nc -lk 9000”监听本机的9000端口，编译运行我们的代码，就可以看到netcat输出hello了。</p><p>参考书目：《UNIX网络编程》、《TCP&#x2F;IP详解 卷1》</p>]]></content>
      
      
      <categories>
          
          <category> Linux网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络编程(一)：TCP基础概念</title>
      <link href="/2022/12/13/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%80)%EF%BC%9ATCP%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/12/13/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%80)%EF%BC%9ATCP%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>TCP协议：即传输控制协议（Transmission Control Protocol）是一种面向连接的协议，为用户进程提供可靠的全双工字节流，TCP套接字是一种流套接字，TCP关心确认、超时和重传之类的细节。TCP可以使用IPv4和IPv6。</p><p>RTT：round-trip time，端与端之间的往返时间，TCP含有用于动态估算客户和服务器之间RTT的算法。</p><p>分节：TCP传递给IP的数据单元。</p><p>TCP字节序列号：TCP回给每个字节关联一个序列号用于对所发送的数据进行排序。</p><p>MSS：最大分节大小（Maximum segment size），发送SYN的TCP一端使用本字段通知对端它在本连接的每个TCP分节中愿意接受的最大数据量。</p><p>MTU：最大传输单元（Maximum transmission unit)，以太网的MTU是1500字节，当一个IP数据报将从某个接口送出时，如果它的大小超过相应链路的MTU，IPv4和IPv6都将执行分片。</p><p>套接字：TCP每个端点的IP地址和端口号称为一个套接字。</p><p>套接字对：定义一个TCP连接的两个端点的四元组：本地IP地址、本地TCP端口号、外地IP地址、外地TCP端口号。套接字对唯一标识网络上的每个TCP连接。</p><p>三路握手：</p><p>客户端与服务器建立一个TCP连接，需要经历以下几个步骤：</p><ol><li>服务器处于被动打开的状态，也就是可以接收外来连接</li><li>客户端通过调用connect发起主动打开，此时客户端会发送一个同步分节（SYN）给服务器，这个SYN会携带一个序列号j，用于通知服务器连接中发送的数据的初始序列号，SYN本身会占用一个序列号</li><li>服务器收到SYN分节后，发送确认分节（ACK）和自己的SYN分节给客户端，ACK和SYN是一同发送的，所以使用一个分节。ACK中会携带一个序列号j+1，意思是通知客户端本端所期待的下一个序列号，SYN分节中会携带一个新的序列号K，这个序列号是通知客户端本端发送的数据的初始序列号</li><li>客户端收到来自服务端的ACK分节和SYN分节后需要回复客户端一个ACK分节，同时携带序列号K+1，告知服务端本端期待的下一个序列号</li></ol><p>至此一个TCP连接就建立完成了，由于整个过程中需要至少交换三组数据，因此称之为TCP的三路握手或三次握手，TCP三路握手连接示意图如下：</p><p><img src="https://raw.githubusercontent.com/wxyfq/blog-pic/master/TCP_connect.png" alt="TCP_connect"></p><p>TCP连接终止：</p><p>TCP连接的建立需要交换三个分节，而终止一个连接则通常需要交换四个分节，所以TCP连接的终止又叫四路分手。</p><p>TCP连接的终止需要经历以下几个步骤：</p><ol><li>主动关闭连接的一端的应用程序调用close执行主动关闭。该端的TCP会发送一个FIN分节，表示数据发送完毕</li><li>接收到FIN分节的对端执行被动关闭。接收端会发送ACK给对端确认。FIN的接收也作为一个文件结束符通知给接收端的应用进程。此时主动关闭一端到被动关闭一端的数据流就关闭了</li><li>被动关闭的一端在处理完数据后，应用进程调用close关闭套接字，这会导致它的TCP也发送一个FIN</li><li>接收到这个FIN的原发送端TCP再发送一个确认给对端，此时被动关闭一端到主动关闭一端的数据流也关闭了</li></ol><p>TCP连接终止时的分节也携带序列号，同时一个FIN分节也占用一个字节的序列号。至此TCP双向的数据流都完成关闭，TCP连接终止，TCP终止连接时的数据交换示意图如下：</p><p><img src="https://raw.githubusercontent.com/wxyfq/blog-pic/master/TCP_disconnect.png" alt="TCP_disconnect"></p><p>TCP连接的终止通常需要交换四组数据，但是步骤2和步骤3的分节合并成一个分节发送的可能性是存在的，而且步骤1的分节也是有可能随数据一起发送的。在步骤2和步骤3之间，主动关闭一端到被动关闭一端的数据流被关闭了，但是相反方向的数据流还未被关闭，这种状态称为班关闭（half-close）。</p><p>上述示意图中展示的FIN分节的发送都是通过close函数的调用发生的，但是在linux系统中，无论程序是怎样终止的，其打开的所有描述符都会被关闭，包括套接字描述符，此时也会导致本端的TCP发送一个FIN。</p><p>TCP状态转换图：</p><p>TCP涉及连接建立和终止的操作可以用状态转换图来说明：</p><p><img src="https://raw.githubusercontent.com/wxyfq/blog-pic/master/TCP_status.png" alt="TCP_status"></p><p>建立连接时的TCP状态转换：</p><p>TCP初始状态是CLOSED，作为客户端执行主动打开时，发送SYN分节后TCP状态会变为SYN_SENT，接收到来自服务端的ACK和SYN后会发送ACK分节，然后变为ESTABLISHED状态，这种状态表示TCP连接已经建立成功，可以进行数据传输，这也是绝大多数数据传送发生时的状态；作为服务端从CLOSED状态通过调用socket，bind，listen执行被动打开，此时服务器已经准备好接受新连接，服务端的TCP状态为LISTEN，此时如果收到SYN分节并发送ACK分节和自己的SYN分节，会转换成SYN_RCVD状态，在这个状态如果收到客户端发送的ACK分节，则转换为ESTABLISHED状态。</p><p>终止连接时的TCP状态转换：</p><p>如果本端调用close执行主动关闭，TCP发送FIN后会转换为FIN_WAIT_1状态，等到接收到对端发回的ACK分节后转换为FIN_WAIT_2状态，此时TCP连接已经处于半关闭状态状态，本端到对端的数据流已经关闭了，在FIN_WAIT_2状态下收到对端发送的FIN分节并回复ACK分节后TCP状态会转换为TIME_WAIT，在此状态等待最长2MSL的时间后变为CLOSED状态。如果本端是被动关闭的，在收到FIN分节并发送ACK后会从ESTABLISHED转换至CLOSE_WAIT状态，此时对端到本端的数据流已经关闭了，同样TCP连接处于半关闭状态。一段时间后本端发送FIN给对端后状态转换至LAST_ACK，等接收到对端的确认ACK后，状态转换至CLOSED。</p><p>TCP连接在传输数据时一端发送一个数据分组，对端在收到分组后会发送一个ACK回来，发送端如果在指定时间内没有收到ACK应答，会重传分组。所以如果我们只需要传送一个请求分组，使用TCP连接时，需要额外8个数据分组的开销（连接建立时三个，终止时四个，作为对端成功接收数据的ACK应答一个）；如果使用UDP，则只需要两个数据分组，一个用于承载数据，一个用于承载应答。</p><p>TIME_WAIT状态：</p><p>执行主动关闭的一端在发送最后一个ACK确认分节后会进入TIME_WAIT状态并等待最长2MSL时间后变成CLOSED状态。MSL(maximum segment lifetime)标志分节最长生命周期。这个时间一般为30秒到2分钟。所以TIME_WAIT持续时间一般为一分钟到四分钟。TIME_WAIT状态有两个存在的理由：1.可靠地实现TCP全双工连接的终止；2.允许老的重复分解在网络中消逝。对于第一个理由，假设主动关闭的一端最后发送的ACK分节丢失了，那么服务端会重新发送FIN，客户端就需要维持状态等待重新发送的FIN到达，然后再发送ACK，如果客户端不维持状态，那么在收到服务端重新发送的FIN分节后会发送RST作为应答，这个分节会被服务器解释成一个错误。对于第二个理由，如果一条TCP连接关闭后，一条新建立的TCP连接的两端使用了与旧连接相同的地址和端口号，那么新连接称为旧连接的化身。假设旧连接最后发送的数据分节因为超时重传了，但是数据分节的生命周期并没有结束，只是可能在网络中“迷路”了，重传的数据分节到达对端后连接终止，此时如果作为化身的新连接建立，原来的数据分节在新连接建立后到达了，它就会被误认为是属于新连接中的数据。为了防止这一情况的发生，发送端TCP会在TIME_WAIT状态等待2MSL的时间，TCP不会给处于TIME_WAIT状态的连接发起新的化身。由于TIME_WAIT的持续时间是MSL的两倍，这个时间足够让一个方向的数据分节存在MSL后被丢弃，另一个方向上的应答最多存在MSL后被丢弃。TCP通过TIME_WAIT机制保证了一个TCP连接建立时，之前使用同样的地址端口建立的TCP连接上的老的重复分节已经消逝在网络中了。</p><p>参考书目：《UNIX网络编程》、《TCP&#x2F;IP详解 卷1》</p>]]></content>
      
      
      <categories>
          
          <category> Linux网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程学习笔记：并发数据结构（一）</title>
      <link href="/2022/12/10/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/12/10/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在多线程程序中，如果某一些数据需要支持多个线程的并发读写，我们需要使用一些手段来同步线程间的读写操作。比如我们可以使用互斥量配合锁来完成数据同步，我们可以使用标准库容器存储共享数据。当线程需要读写数据的时候，先请求锁，然后对数据进行读写，读写完成后再释放锁。为了防止遗漏解锁操作，我们使用std::lock_guard&lt;&gt;作为协助，为了不用每次读写操作都重复书写std::lock_guard代码，我们将获取锁的操作和读写操作封装成一个函数，为了方便复用，我们将标准库容器封装进一个类中，将我们的读写函数变成类的成员函数，于是我们就得到了一个简单的支持并发操作的数据结构。</p><p>当然设计一个支持高并发访问甚至部分并行访问的数据结构并不是这么简单，需要设计者根据使用场景考虑很多问题，你需要哪些强制性的准则来约束使用者的行为？当一个线程在对数据结构进行某一项操作时，来自于其他线程的哪些操作是安全的？你需要考虑怎样尽最大可能减少必要的串行访问并且最大化并行访问。例如多个线程只是从从数据结构中读取数据的时候，这些操作就可以被允许完全并行，但是如果有线程想要修改数据结构，这个操作与其他操作就需要是串行的，只有修改数据的操作完成后其他操作才可以开始。标准库的共享锁std::shared_mutex&lt;&gt;就是这种机制，并行操作访问数据时使用std::shared_mutex&lt;&gt;获取共享锁，互斥（串行）操作访问数据时使用std::lock_guard&lt;&gt;或std::unique_lock&lt;&gt;获取独占锁。</p><p>《C++Concurrency in Action 2nd Edition》一书中为我们提供了两种设计并发数据结构的方法，一种是基于锁的方式，使用互斥量和锁以确保某一时刻只有一个线程访问数据结构；另外一种是使用原子操作的无锁设计。基于锁的方式是比较简单的，也是本章介绍的设计方式。</p><p>我们先看一个基于锁的线程安全的stack的实现，代码来自《C++Concurrency in Action 2nd Edition》：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class empty_stack:std::exception&#123;</span><br><span class="line">  const char *what() const noexcept override &#123;</span><br><span class="line">    return &quot;Stack is empty&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class threadsafe_stack&#123;</span><br><span class="line"> private:</span><br><span class="line">  std::stack&lt;T&gt; data;</span><br><span class="line">  mutable std::mutex m;</span><br><span class="line"> public:</span><br><span class="line">  threadsafe_stack()=default;</span><br><span class="line">  threadsafe_stack(const threadsafe_stack&amp; other)&#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lg(other.m);</span><br><span class="line">    data=other.data;</span><br><span class="line">  &#125;</span><br><span class="line">  threadsafe_stack&amp; operator=(const threadsafe_stack&amp;)=delete;</span><br><span class="line">  void push(T value)&#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lg(m);</span><br><span class="line">    data.push(std::move(value));</span><br><span class="line">  &#125;</span><br><span class="line">  void pop(T&amp; value)&#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lg(m);</span><br><span class="line">    if(data.empty())throw empty_stack();</span><br><span class="line">    value=std::move(data.top());</span><br><span class="line">    data.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  std::shared_ptr&lt;T&gt; pop()&#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lg(m);</span><br><span class="line">    if(data.empty())throw empty_stack();</span><br><span class="line">    const std::shared_ptr&lt;T&gt; res(std::make_shared&lt;T&gt;(std::move(data.top())));</span><br><span class="line">    data.pop();</span><br><span class="line">    return res;</span><br><span class="line">  &#125;</span><br><span class="line">  bool empty() const&#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lg(m);</span><br><span class="line">    return data.empty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到每个成员函数都使用锁提供互斥访问，保证了每次只有一个线程能够访问数据结构。接口的设计也与std::stack&lt;&gt;不一样，先来看一下从std::stack&lt;&gt;读取数据的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; s;</span><br><span class="line">if(!s.empty())&#123;</span><br><span class="line">const int value = s.top();</span><br><span class="line">s.pop();</span><br><span class="line">do_something(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们要知道所有标准库的容器都不是线程安全的。如果我们设计的threadsafe_stack也采用跟std::stack&lt;&gt;相同的接口，那么我们只能保证empty(),top(),pop()这三个接口函数是线程安全的，从threadsafe_stack读取数据的代码也会跟上述代码相同，这样做会导致多线程访问数据时出现竞态条件，因为两个相邻函数执行的间隙其他线程可以抢占锁执行自己的函数。例如第一个线程判断栈不为空，此时第二个线程开始执行将栈中仅剩的数据拿出，然后第一个线程再继续执行栈不为空条件下的代码，显然是不对的。</p><p>假设两个线程同时执行上述操作，s中有足够的数据，我们使用一个表格来模拟一种可能的函数调用顺序：</p><table><thead><tr><th align="center">Thread A</th><th align="center">Thread B</th></tr></thead><tbody><tr><td align="center">if(!s.empty())</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">if(!s.empty())</td></tr><tr><td align="center">const int value &#x3D; s.top();</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">const int value &#x3D; s.top();</td></tr><tr><td align="center">s.pop();</td><td align="center"></td></tr><tr><td align="center">do_something(value);</td><td align="center">s.pop();</td></tr><tr><td align="center"></td><td align="center">do_something(value);</td></tr></tbody></table><p>线程A和线程B是两个执行相同操作的线程，正常情况下应该是各自拿到一个数据进行相应的操作，但是两个线程如果按照表格上的调用顺序执行，栈顶的数据会同时被线程A和B访问到，栈顶的第二个数据还未被访问就被弹出，这显然不是想要的结果。所以在threadsafe_stack的接口设计中将top()和pop()封装到同一个接口函数中。还有一点不一样的是，相较于stack的pop()直接返回值的操作，threadsafe_stack的pop函数选择返回一个指向数据的智能指针，另外一个重载接受一个引用作为参数，将值赋给引用绑定的对象。之所以这样设计是考虑到将top()和pop()封装成一个函数，意味着函数返回时，数据已经从栈中删除了，返回的数据会被用来初始化调用点的一个临时变量，此时如果拷贝构造函数因为内存不足抛出异常，临时变量没有创建成功，而栈中的数据也被删除，那数据就丢失了。这种情况在系统负载特别高而栈中存放的数据类型占用空间特别大时（例如stack&lt;vector<string>&gt;）很容易发生。标准库的stack保证pop()不抛出异常，所以不用担心数据丢失的情况。解决的方式有两种，一种是我们提前创建好变量，然后将变量的引用作为参数传给pop()，在数据弹出栈前先将数据赋值给引用绑定的变量，这样即便复制过程中抛出异常，那么数据还在栈中；另外一种是返回一个指向数据的智能指针，因为指针的拷贝是不会抛出异常的，如果指针创建过程中发生了异常，数据还在栈中，指针一旦创建成功，就一定可以传递成功。使用智能指针将内存管理交给标准库，可以避免内存泄露，而且标准库控制内存分配方案而不是使用new和delete会有性能上的优势，因为每次检出数据时都用new创建指针会造成很大的性能消耗。</p><p>threadsafe_stack使用锁实现了多线程对数据结构的互斥访问，但是所有线程抢占同一个锁的事实造成了潜在的性能影响，因为当一个线程在等待锁的过程当中是阻塞的，所有的后续任务都会因为阻塞时间而延后。另外threadsafe_stack没有提供等待数据被添加进栈的方法，这就导致如果一个线程在等待栈中的数据，而栈是空的，等待线程就只能不停的调用empty()进行判断或者调用pop()然后处理异常，等待线程这种不断的轮询会消耗CPU的执行时间片。或者用户自己写条件变量的代码，但是如果这都要用户自己写，那还要我们这个数据结构做什么呢？所以下一步我们就要想办法将条件变量应用到我们的数据结构中。下一章我们将介绍一种使用锁和条件变量实现线程安全的队列数据结构的实现方法。</p><p>参考书目：《C++Concurrency in Action 2nd Edition》</p><p>参考网站：cppreference.com</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程学习笔记：并发数据结构（三）</title>
      <link href="/2022/12/10/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2022/12/10/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>使用一个锁保护数据结构保证每次只有一个线程可以访问数据结构，这种做法虽然保证了线程安全，但是确是以完全的串行化作为代价的，所有访问操作都需要排队抢占锁，宏观上看似做到了并发，但是微观上还是串行访问。但其实作为一个队列来讲，当一个线程在向队列的一端写入数据时，可以有另外的线程在队列的另一端读取数据，只要保证同一时刻写入和读取的数据不是同一个就可以。我们可以使用两个锁分别保护头指针和尾指针的访问，这样从头部读取数据和从尾部放入数据的操作就可以同时进行了，这对于提高并发性能是有帮助的。为了实现这种更细粒度的锁，我们需要对数据结构有完全的掌控，所以相较于使用标准库作为底层实现，完全自己实现一个队列数据结构是一个更好的选择。作为开始，先来实现一个单线程的队列，比较简单的方式是使用链表，为了能够更加轻松的管理内存，我们使用智能指针负责链表数据的管理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class queue&#123;</span><br><span class="line"> private:</span><br><span class="line">  struct node&#123;</span><br><span class="line">    T data;</span><br><span class="line">    std::unique_ptr&lt;node&gt; next;</span><br><span class="line">    node(T _data):data(std::move(_data))&#123; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::unique_ptr&lt;node&gt; head;</span><br><span class="line">  node* tail;</span><br><span class="line"> public:</span><br><span class="line">  queue():tail(nullptr)&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  queue(const queue&amp;)=delete;</span><br><span class="line">  queue&amp; operator=(const queue&amp;)=delete;</span><br><span class="line">  std::shared_ptr&lt;T&gt; try_pop()&#123;</span><br><span class="line">    if(!head)&#123;</span><br><span class="line">      return std::shared_ptr&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    const std::shared_ptr&lt;T&gt; res(</span><br><span class="line">        std::make_shared&lt;T&gt;(std::move(head-&gt;data)));</span><br><span class="line">    const std::unique_ptr&lt;node&gt; old_head = std::move(head);</span><br><span class="line">    head = std::move(head-&gt;next);</span><br><span class="line">    if(!head)</span><br><span class="line">      tail= nullptr;</span><br><span class="line">    return res;</span><br><span class="line">  &#125;</span><br><span class="line">  void push(T value)&#123;</span><br><span class="line">    std::unique_ptr&lt;node&gt; p(new node(std::move(value)));</span><br><span class="line">    const node* new_tail = p.get();</span><br><span class="line">    if(tail)&#123;</span><br><span class="line">      tail-&gt;next = std::move(p);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      head = std::move(p);</span><br><span class="line">    &#125;</span><br><span class="line">    tail = new_tail;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码在单线程环境中可以正常运行，但是如果在此基础上通过添加细粒度的锁使其能够适应多线程环境则会遇到一些问题。首先函数操作的数据项有两个：head和tail，所以需要两个互斥量分别进行保护。我们先来分析push函数，函数可能修改head和tail的数据，所以需要同时锁定两个互斥量。这没有什么太大的问题。更加棘手的是push()和pop()都修改了next字段，push()修改的是head-&gt;next，pop修改的是tail-&gt;next，当队列中只有一个数据项的时候，head&#x3D;&#x3D;tail，他们的next字段自然指向了同一个对象。如果想要判断head和tail是否相等，那就需要同时锁定两个互斥量，这样依赖，无论是push还是pop都要同时锁定两个互斥量，相对于使用一个锁的方式，这种更细粒度的锁并不能带来任何并发性能的提升。</p><p>为了解决上面描述的问题，可以提前分配一个空的数据项以保证队列中至少都有一个空的数据项可以将对head和tail的访问分割开来。对于空队列，head和tail同时指向这个空的数据项而不是指向nullptr。而且空队列的时候pop()函数也不会访问head-&gt;next，所以不用考虑同时加锁的问题。对于非空队列，当最少有一个有用的数据项时，其实队列中是有两个项目的，此时head指向有用的数据项，而tail则指向空的数据项，这就保证了只要队列里有数据，head和tail永远都不可能相等，问题解决，修改后的实现如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class queue</span><br><span class="line">&#123;</span><br><span class="line"> private:</span><br><span class="line">  struct node &#123;</span><br><span class="line">    std::shared_ptr&lt;T&gt; data;</span><br><span class="line">    std::unique_ptr&lt;node&gt; next;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::unique_ptr&lt;node&gt; head;</span><br><span class="line">  node* tail;</span><br><span class="line"> public:</span><br><span class="line">  queue():</span><br><span class="line">      head(new node),tail(head.get())</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  queue(const queue&amp; other)=delete;</span><br><span class="line">  queue&amp; operator=(const queue&amp; other)=delete;</span><br><span class="line">  std::shared_ptr&lt;T&gt; try_pop()</span><br><span class="line">  &#123;</span><br><span class="line">    if(head.get()==tail)</span><br><span class="line">    &#123;</span><br><span class="line">      return std::shared_ptr&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    std::shared_ptr&lt;T&gt; const res(head-&gt;data);</span><br><span class="line">    std::unique_ptr&lt;node&gt; old_head=std::move(head);</span><br><span class="line">    head=std::move(old_head-&gt;next);</span><br><span class="line">    return res; </span><br><span class="line">    &#125;</span><br><span class="line">  void push(T new_value)</span><br><span class="line">  &#123;</span><br><span class="line">    std::shared_ptr&lt;T&gt; new_data(</span><br><span class="line">        std::make_shared&lt;T&gt;(std::move(new_value)));</span><br><span class="line">    std::unique_ptr&lt;node&gt; p(new node); </span><br><span class="line">    tail-&gt;data=new_data;</span><br><span class="line">    const node* new_tail=p.get();</span><br><span class="line">    tail-&gt;next=std::move(p);</span><br><span class="line">    tail=new_tail;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>跟之前的实现相比，新的node结构体使用智能指针管理数据。queue在构造时使用一个空的node初始化head，tail的值通过head.get()获取的指针值初始化。这样就得到了一个至少存在一个空数据项的队列。try_pop()函数的不再判断head是否为空，而是判断head和tail是否相等，因为新的实现下，head永远不可能为空；由于node使用智能指针管理数据，所以try_pop()可以直接使用获取到的指针初始化res，不需要再构建一个新的T类型的实例了。构建实例的操作被放在了push()函数中，使用new_value创建的共享指针随后被赋给tail的data字段，新创建的不含数据的node p则成为了新的空数据项，也是新的tail。</p><p>这些改进有什么用呢？首先push()操作现在只需要访问tail了；其次try_pop()虽然需要访问head和tail，但是对tail的访问仅仅是用于跟head比较，所以只需要持有tail的锁很短的时间，最大的改进就是空数据项的引入保证了try_pop()和push()永远不可能操作同一个对象，所以也就不需要保护整个数据结构的锁了，我们就可以使用更细粒度的锁来分别保护head和tail了。</p><p>接下来的工作就是考虑在哪里加锁，整体的原则就是尽可能缩短持有锁的时间。push()函数中需要tail锁保护对tail的所有操作，所以将锁放在tail-&gt;data&#x3D;new data;这行代码的上面就可以了。try_pop()需要持有head锁保护对head的所有操作，也就是从函数开始到最后的return语句之前；在这期间需要短暂获取tail锁，也就是比较head和tail是否相等的操作期间。只需要读取tail的值的时候持有tail锁就可以了，所以可以将获取tail值的操作封装成一个函数，然后在函数中使用锁，这样当函数返回时，锁就释放了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class threadsafe_queue</span><br><span class="line">&#123;</span><br><span class="line"> private:</span><br><span class="line">  struct node &#123;</span><br><span class="line">    std::shared_ptr&lt;T&gt; data;</span><br><span class="line">    std::unique_ptr&lt;node&gt; next;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::mutex head_mutex;</span><br><span class="line">  std::unique_ptr&lt;node&gt; head;</span><br><span class="line">  std::mutex tail_mutex;</span><br><span class="line">  node* tail;</span><br><span class="line">  node* get_tail()</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; tail_lock(tail_mutex);</span><br><span class="line">    return tail;</span><br><span class="line">  &#125;</span><br><span class="line">  std::unique_ptr&lt;node&gt; pop_head()</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; head_lock(head_mutex);</span><br><span class="line">    if(head.get()==get_tail())</span><br><span class="line">    &#123;</span><br><span class="line">      return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    std::unique_ptr&lt;node&gt; old_head=std::move(head);</span><br><span class="line">    head=std::move(old_head-&gt;next);</span><br><span class="line">    return old_head;</span><br><span class="line">  &#125;</span><br><span class="line"> public:</span><br><span class="line">  threadsafe_queue():</span><br><span class="line">      head(new node),tail(head.get())</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  threadsafe_queue(const threadsafe_queue&amp; other)=delete;</span><br><span class="line">  threadsafe_queue&amp; operator=(const threadsafe_queue&amp; other)=delete;</span><br><span class="line">  std::shared_ptr&lt;T&gt; try_pop()</span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_ptr&lt;node&gt; old_head=pop_head();</span><br><span class="line">    return old_head?old_head-&gt;data:std::shared_ptr&lt;T&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  void push(T new_value)</span><br><span class="line">  &#123;</span><br><span class="line">    std::shared_ptr&lt;T&gt; new_data(</span><br><span class="line">        std::make_shared&lt;T&gt;(std::move(new_value)));</span><br><span class="line">    std::unique_ptr&lt;node&gt; p(new node);</span><br><span class="line">    node* const new_tail=p.get();</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; tail_lock(tail_mutex);</span><br><span class="line">    tail-&gt;data=new_data;</span><br><span class="line">    tail-&gt;next=std::move(p);</span><br><span class="line">    tail=new_tail;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比较有意思的是try_pop()函数中tail_mutex锁的作用，它的存在不仅仅是用于保护对tail的读取，对于防止从head读取数据时发生数据竞争也是必要的。如果没有这个锁，那么try_pop()和push()操作就是完全并行的了，所以它们各自函数中的操作顺序就无法保证了。虽然每个成员函数都持有一个互斥量的锁，但是他们锁定的是不同的互斥量，相互之间并没有同步，所以发生数据竞争的潜在可能性是存在的，毕竟队列中所有的数据都来自push()的写入。tail_mutex的加入解决了这个问题，由于这个互斥量是push()和try_pop()同时使用的，所以它可以保证get_tail()要么发生在push()修改tail之前(此时get_tail()读取的是旧tail的数据)，要么发生在push()修改tail之后(此时get_tail()读取的是新tail的数据)，而不会发生在push()修改tail期间。</p><p>另外需要注意的是对tail_mutex的锁定必须在持有head_mutex锁的前提下进行，在未锁定head_mutex时读取到的tail数据没有任何参考价值，看下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;node&gt; pop_head()</span><br><span class="line">&#123;</span><br><span class="line">  const node* old_tail=get_tail();</span><br><span class="line">  std::lock_guard&lt;std::mutex&gt; head_lock(head_mutex);</span><br><span class="line">  if(head.get()==old_tail)</span><br><span class="line">  &#123;</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">  std::unique_ptr&lt;node&gt; old_head=std::move(head);</span><br><span class="line">  head=std::move(old_head-&gt;next);</span><br><span class="line">  return old_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在get_tail()调用后，可能会开始执行其他的函数调用，push()，try_pop()都有可能,所以当函数获取head_mutex的锁之后，head和tail可能都不是函数最开始时候的值了。现在的head位置甚至可能在old_tail之后，而old_tail可能已经不是队列的一部分了，这就会导致head.get()&#x3D;&#x3D;old_tail的比较返回false，那么接下来更新head的操作就很致命了，如果现在队列已经空了（head&#x3D;&#x3D;tail），这些操作将会破坏数据结构。而上面正确的实现方式保证了读取tail值后head的值不会改变，head的位置永远不可能在old_tail之后，也就保证了判断条件不会失效。</p><p>现在我们回头整体看一下threadsafe_queue的实现，push()函数虽然有耗时的内存分配的操作，但是是在获取锁之前进行的，虽然一次只有一个线程可以持有锁对tail进行修改，但是这些修改操作都是简单的指针赋值操作，所以每个线程持有锁的时间是很短的；try_pop()虽然也持有tail的锁，但是持有时间很短，而且耗时的回收内存操作(old_head占用内存的释放)是在释放锁之后进行的，所以push和try_pop()的大部分操作是可以并行进行的。</p><p>现在我们已经有一个支持细粒度锁的线程安全的队列数据结构了，接下来我们将条件变量添加进去。对push()的修改只需要在函数最后加上notify_one()的调用即可。但是我们还需要考虑一件事，如果我们只是简单的加上一句调用的代码，那么锁将在notify_one()调用才释放，存在这么一种可能，等待线程在锁释放之前就被唤醒了，但是所还没释放，所以等待线程需要等锁释放；相反如果锁在notify_one()调用前就释放了，那么当等待线程被唤醒时就可以直接获取锁。这可能会带来细微的性能提升，修改也很简单，只需要使用一个花括号把加锁的部分包裹住就好了。</p><p>我们看一下完整的实现代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;mutex&gt;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class threadsafe_queue</span><br><span class="line">&#123;</span><br><span class="line"> private:</span><br><span class="line">  struct node &#123;</span><br><span class="line">    std::shared_ptr&lt;T&gt; data;</span><br><span class="line">    std::unique_ptr&lt;node&gt; next;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::mutex head_mutex;</span><br><span class="line">  std::unique_ptr&lt;node&gt; head;</span><br><span class="line">  std::mutex tail_mutex;</span><br><span class="line">  node* tail;</span><br><span class="line">  std::condition_variable data_cond;</span><br><span class="line"> private:</span><br><span class="line">  node* get_tail()</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; tail_lock(tail_mutex);</span><br><span class="line">    return tail;</span><br><span class="line">  &#125;</span><br><span class="line">  std::unique_ptr&lt;node&gt; pop_head()</span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_ptr&lt;node&gt; old_head=std::move(head);</span><br><span class="line">    head=std::move(old_head-&gt;next);</span><br><span class="line">    return old_head;</span><br><span class="line">  &#125;</span><br><span class="line">  std::unique_lock&lt;std::mutex&gt; wait_for_data()</span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; head_lock(head_mutex);</span><br><span class="line">    data_cond.wait(head_lock,[&amp;]&#123;return head.get()!=get_tail();&#125;);</span><br><span class="line">    return std::move(head_lock);</span><br><span class="line">  &#125;</span><br><span class="line">  std::unique_ptr&lt;node&gt; wait_pop_head()</span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; head_lock(wait_for_data());</span><br><span class="line">    return pop_head();</span><br><span class="line">  &#125;</span><br><span class="line">  std::unique_ptr&lt;node&gt; wait_pop_head(T&amp; value)</span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; head_lock(wait_for_data());</span><br><span class="line">    value=std::move(*head-&gt;data);</span><br><span class="line">    return pop_head();</span><br><span class="line">  &#125;</span><br><span class="line">  std::unique_ptr&lt;node&gt; try_pop_head()</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; head_lock(head_mutex);</span><br><span class="line">    if(head.get()==get_tail())</span><br><span class="line">    &#123;</span><br><span class="line">      return std::unique_ptr&lt;node&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    return pop_head();</span><br><span class="line">  &#125;</span><br><span class="line">  std::unique_ptr&lt;node&gt; try_pop_head(T&amp; value)</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; head_lock(head_mutex);</span><br><span class="line">    if(head.get()==get_tail())</span><br><span class="line">    &#123;</span><br><span class="line">      return std::unique_ptr&lt;node&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    value=std::move(*head-&gt;data);</span><br><span class="line">    return pop_head();</span><br><span class="line">  &#125;</span><br><span class="line"> public:</span><br><span class="line">  threadsafe_queue():</span><br><span class="line">      head(new node),tail(head.get())</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  threadsafe_queue(const threadsafe_queue&amp; other)=delete;</span><br><span class="line">  threadsafe_queue&amp; operator=(const threadsafe_queue&amp; other)=delete;</span><br><span class="line"></span><br><span class="line">  void push(T new_value)</span><br><span class="line">  &#123;</span><br><span class="line">    std::shared_ptr&lt;T&gt; new_data(</span><br><span class="line">        std::make_shared&lt;T&gt;(std::move(new_value)));</span><br><span class="line">    std::unique_ptr&lt;node&gt; p(new node);</span><br><span class="line">    &#123;</span><br><span class="line">      std::lock_guard&lt;std::mutex&gt; tail_lock(tail_mutex);</span><br><span class="line">      tail-&gt;data=new_data;</span><br><span class="line">      node* const new_tail=p.get();</span><br><span class="line">      tail-&gt;next=std::move(p);</span><br><span class="line">    &#125;</span><br><span class="line">    data_cond.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line">  std::shared_ptr&lt;T&gt; wait_and_pop()</span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_ptr&lt;node&gt; const old_head=wait_pop_head();</span><br><span class="line">    return old_head-&gt;data;</span><br><span class="line">  &#125;</span><br><span class="line">  void wait_and_pop(T&amp; value)</span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_ptr&lt;node&gt; const old_head=wait_pop_head(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;T&gt; try_pop()</span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_ptr&lt;node&gt; old_head=try_pop_head();</span><br><span class="line">    return old_head?old_head-&gt;data:std::shared_ptr&lt;T&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  bool try_pop(T&amp; value)</span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_ptr&lt;node&gt; const old_head=try_pop_head(value);</span><br><span class="line">    return old_head;</span><br><span class="line">  &#125;</span><br><span class="line">  bool empty()</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; head_lock(head_mutex);</span><br><span class="line">    return (head.get()==get_tail());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>wait_and_pop()调用wait_pop_head()获取返回值，wait_pop_head()通过调用wait_for_data()等待条件变量并且通过移动语义获得线程唤醒后head锁的所有权。对于返回智能指针的重载函数，直接返回pop_head()的执行结果，pop_head()会返回指向queue的head的指针并将head从queue中移除。需要注意的是针对使用T&amp;类型参数的重载，需要先对value进行赋值，再调用pop_head()，因为对value的赋值使用的是类型T的赋值调用运算符，有可能会抛出异常，再pop_head()之前调用可以防止数据因异常丢失。</p><p>参考书目：《C++Concurrency in Action 2nd Edition》</p><p>参考网站：cppreference.com</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程学习笔记：并发数据结构（二）</title>
      <link href="/2022/12/10/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/12/10/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>上一章我们介绍了一个基于锁实现的线程安全的stack，在文章的末尾我们也指出了这种实现方式的弊端，在此基础上我们加以改进，引入条件变量实现一个线程安全的队列，样例代码来自《C++Concurrency in Action 2nd Edition》：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class threadsafe_queue</span><br><span class="line">&#123;</span><br><span class="line"> private:</span><br><span class="line">  mutable std::mutex mut;</span><br><span class="line">  std::queue&lt;T&gt; data_queue;</span><br><span class="line">  std::condition_variable data_cond;</span><br><span class="line"> public:</span><br><span class="line">  threadsafe_queue()</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  threadsafe_queue(const threadsafe_queue&amp; other)</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lk(other.mut);</span><br><span class="line">    data_queue=other.data_queue;</span><br><span class="line">  &#125;</span><br><span class="line">  threadsafe_queue operator=(const threadsafe_queue&amp;)=delete;</span><br><span class="line">  void push(T new_value)</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lk(mut);</span><br><span class="line">    data_queue.push(new_value);</span><br><span class="line">    data_cond.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line">  void wait_and_pop(T&amp; value)</span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lk(mut);</span><br><span class="line">    data_cond.wait(lk,[this]&#123;return !data_queue.empty();&#125;);</span><br><span class="line">    value=std::move(data_queue.front());</span><br><span class="line">    data_queue.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  std::shared_ptr&lt;T&gt; wait_and_pop()</span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lk(mut);</span><br><span class="line">    data_cond.wait(lk,[this]&#123;return !data_queue.empty();&#125;);</span><br><span class="line">    std::shared_ptr&lt;T&gt; res(std::make_shared&lt;T&gt;(std::move(data_queue.front()));</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    return res;</span><br><span class="line">  &#125;</span><br><span class="line">  bool try_pop(T&amp; value)</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lk(mut);</span><br><span class="line">    if(data_queue.empty())</span><br><span class="line">      return false;</span><br><span class="line">    value=std::move(data_queue.front());</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  std::shared_ptr&lt;T&gt; try_pop()</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lk(mut);</span><br><span class="line">    if(data_queue.empty())</span><br><span class="line">      return std::shared_ptr&lt;T&gt;();</span><br><span class="line">    std::shared_ptr&lt;T&gt; res(std::make_shared&lt;T&gt;(std::move(data_queue.front()));</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    return res;</span><br><span class="line">  &#125;</span><br><span class="line">  bool empty() const</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lk(mut);</span><br><span class="line">    return data_queue.empty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pop()接口为什么设计成传引用和返回智能指针我们已经在上一章分析过原因。这次我们我们主要看一下条件变量的应用：每次push数据的时候对条件变量调用notify_one()唤醒等待线程；pop操作设计了四个接口函数，分别是两个阻塞函数和两个非阻塞函数，阻塞函数会对条件变量调用wait()加上判断条件等待队列中有数据才返回，非阻塞函数则是立刻返回，无数据就返回false或空指针。读线程如果需要等待数据，就调用wait_and_pop的两个重载函数，否则就调用try_pop的两个重载函数并且加上处理读取失败的代码。相比于threadsafe_stack那种栈为空就抛出异常的做法，这种设计方式显然更加友好。</p><p>仔细分析上面的代码，会发现一个小小的瑕疵。std::make_shared&lt;&gt;()函数可能会抛出bad_alloc或任何T构造函数抛出的异常（std::shared_ptr&lt;&gt;的拷贝构造函数不会抛出异常），所以如果一个线程调用std::shared_ptr<T> wait_and_pop()函数并阻塞在wait()函数，之后因为notify_one()函数的调用被唤醒，但是在创建智能指针的时候抛出异常导致没有成功读取数据，于此同时其他线程也不会再被唤醒了，只能等待下一次notify_one()的调用或者假醒。可以将notify_one()修改成notify_all()，不过需要承受的代价就是除了成功抢占锁的线程，其他被唤醒的线程无功而返；也可以在捕获std::make_shared&lt;&gt;()的异常后再异常处理中再调用一次notify_one();再有就是直接在队列中存放智能指针，因为智能指针的传递是不会抛出异常的，我们看一下基于这种方式的实现，样例代码来自《C++Concurrency in Action 2nd Edition》：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class threadsafe_queue</span><br><span class="line">&#123;</span><br><span class="line"> private:</span><br><span class="line">  mutable std::mutex mut;</span><br><span class="line">  std::queue&lt;std::shared_ptr&lt;T&gt; &gt; data_queue;</span><br><span class="line">  std::condition_variable data_cond;</span><br><span class="line"> public:</span><br><span class="line">  threadsafe_queue()</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  void wait_and_pop(T&amp; value)</span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lk(mut);</span><br><span class="line">    data_cond.wait(lk,[this]&#123;return !data_queue.empty();&#125;);</span><br><span class="line">    value=std::move(*data_queue.front());</span><br><span class="line">    data_queue.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  bool try_pop(T&amp; value)</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lk(mut);</span><br><span class="line">    if(data_queue.empty())</span><br><span class="line">      return false;</span><br><span class="line">    value=std::move(*data_queue.front());</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  std::shared_ptr&lt;T&gt; wait_and_pop()</span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lk(mut);</span><br><span class="line">    data_cond.wait(lk,[this]&#123;return !data_queue.empty();&#125;);</span><br><span class="line">    std::shared_ptr&lt;T&gt; res=data_queue.front();</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    return res;</span><br><span class="line">  &#125;</span><br><span class="line">  std::shared_ptr&lt;T&gt; try_pop()</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lk(mut);</span><br><span class="line">    if(data_queue.empty())</span><br><span class="line">      return std::shared_ptr&lt;T&gt;();</span><br><span class="line">    std::shared_ptr&lt;T&gt; res=data_queue.front();</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    return res;</span><br><span class="line">  &#125;</span><br><span class="line">  void push(T new_value)</span><br><span class="line">  &#123;</span><br><span class="line">    std::shared_ptr&lt;T&gt; data(</span><br><span class="line">        std::make_shared&lt;T&gt;(std::move(new_value)));</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lk(mut);</span><br><span class="line">    data_queue.push(data);</span><br><span class="line">    data_cond.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line">  bool empty() const</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lk(mut);</span><br><span class="line">    return data_queue.empty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>跟上一个实现对比可以很容易看出区别，使用T&amp;作为参数的两个函数使用value&#x3D;std::move(*data_queue.front());代替之前的value&#x3D;std::move(data_queue.front());因为队列中存放的是指针，需要解引用获取值；返回智能指针的两个函数就是简单的将获取到的指针赋值给res然后直接返回res，这个过程不会抛出异常；push函数的改动则是创建智能指针然后将指针放入队列，创建智能指针的代码是在获取锁的代码之前，对比之前持有锁时创建智能指针的做法，这种做法可以提升性能，因为内存的分配一般是比较耗时的操作，这样线程持有锁的时间就减少了，并发程度也就提高了。</p><p>参考书目：《C++Concurrency in Action 2nd Edition》</p><p>参考网站：cppreference.com</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程学习笔记：线程实参传递</title>
      <link href="/2022/12/09/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E5%8F%82%E4%BC%A0%E9%80%92/"/>
      <url>/2022/12/09/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E5%8F%82%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<p>使用std::thread类和std::async()创建线程时的实参传递适用相同的规则，不同的是std::thread构造函数的第一个参数是表示任务函数的可调用对象，std::async()第一个参数是可选的launch发射策略，第二个参数（选择默认策略时是第一个参数）对应std::thread构造函数的第一参数。</p><p>以std::thread为例，想要传递实参，可以直接在线程构造函数中追加实参，实参个数和类型与任务函数的参数个数和类型对应，并且实参支持隐式转换，例如：</p><p><code>void f(int i,const std::string&amp; s);</code></p><p><code>std::thread t(f,3,&quot;hello&quot;);</code></p><p>传递给线程的实参默认是执行拷贝操作的，实参被拷贝进线程对象独占的内存当中并被当作右值传递。即使函数参数类型是引用，也遵循上述规则。如果实参发生隐式转换，该转换会在线程对象的上下文进行。上面的例子拷贝到线程对象上下文中的实参是一个const char*，然后在线程对象的上下文当中隐式转换为std::string。这一事实引发了一个问题，如下所示代码：</p><p><code>void f(int i,const string&amp; s);</code><br><code>void func()&#123;</code><br>    <code>char buffer[1024];</code><br>    <code>std::thread t(f,3,buffer);</code><br>    <code>t.detach();</code><br><code>&#125;</code></p><p>由于线程对象创建成功后调用detach()函数将线程与主线程卸离，func()随即执行完毕返回，局部变量buffer会被销毁，此时使用该局部变量的线程t中char*向std::string的隐式转换可能还未开始，当buffer被销毁后，线程t中对一个无效指针执行隐式转换，会导致未定义的行为。想要避免这种情况，可以在实参传入线程构造函数之前进行显式的转换：</p><p><code>std::thread t(f,3,std::string(buffer));</code></p><p>当希望任务函数能修改某一个对象的值时，我们可能会想要将对象的引用传入线程，所以可能会写下类似下面的代码：</p><p><code>void update_data(int id,Data&amp; data);//用于更新data数据的代码</code><br><code>void func(int id)&#123;</code><br>    <code>Data data;</code><br>    <code>std::thread t(update_data,id,data);</code><br>    <code>t.join();</code><br><code>&#125;</code></p><p>我们单独调用update_data(id,data)时，函数运行良好，但是当跟线程一起使用时，会出现一些意想不到的情况。上面的这段代码无法通过编译，因为线程的构造函数并不知道update_data的第二个参数是一个引用类型，所以它依然会将data整个拷贝到自己的独立存储区，我们知道线程中实参是以右值的形式传递的，而一个右值只能与右值引用或const左值引用绑定，而上述两种情况update_data()的第二个参数都不符合。所以线程内的实参传递会失败，解决方法告诉线程的构造函数data是作为引用传递到线程当中的，我们可以使用std::ref()达成目的：</p><p>std::thread t(update_data,id,std::ref(data));</p><p>这样在线程内部传递的就是data引用的右值引用：Data&amp; &amp;&amp;，通过引用折叠规则会变成Data&amp;，刚好与update_data()函数的第二个参数类型匹配。</p><p>也可以使用lambda表达式：</p><p>std::thread t([id,&amp;data]{update_data(id,data);});</p><p>std::thread构造函数的机制与bind内部的实现原理是一样的。所以我们也可以像使用bind时那样，第一个参数传入一个成员函数指针，第二个参数传递对象指针：</p><p><code>class X&#123;</code><br><code>public:</code><br>    <code>void func();</code><br><code>&#125;;</code><br><code>X x;</code><br><code>std::thread t(&amp;X::func,&amp;x);</code></p><p>有些对象不支持拷贝操作但支持移动语义，传入线程时可以使用移动语义。例如我们想要传递一个std::unique_ptr&lt;&gt;对象：</p><p><code>void do_something(std::unique_ptr&lt;big_object&gt;);//任务函数</code></p><p><code>std::unique_ptr&lt;big_object&gt; p(new big_object);</code></p><p><code>std::thread t(process_big_object,std::move(p));</code></p><p>std::thread对象本身也不支持拷贝但支持移动语义，所以我们可以通过移动线程对象来转移线程所有权：</p><p><code>void func();</code><br><code>std::thread t1(func);</code><br><code>std::thread t2 = std::move(t1);</code></p><p>转移线程对象所有权时要特别注意在转移过程中是否会导致某些线程在销毁前无法被join()或detach()：</p><p><code>std::thread t1(func1);</code><br><code>std::thread t2(func2);</code><br><code>t2=std::move(t1);</code></p><p>代码会导致程序终止，原因是t2原先持有的线程在t2获得t1线程的所有权后变成了“野线程”，再也无法被join()或detach()了。</p><p>参考书目：《Effective.Modern.C++》、《C++Concurrency in Action 2nd Edition》、《C++标准库第二版》、《Primer C++ 第五版》</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程学习笔记：线程同步</title>
      <link href="/2022/12/08/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2022/12/08/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>如果线程A需要等待线程B的某个操作完成才能继续执行，应该怎样编写代码？最简单直接的办法，设置一个标志位，线程A通过一个while循环不断去检查这个标志位的值，而线程B在完成某些操作后将标志位置位，所以在A的下一个循环中就可以读取到被置位的标志位，从而继续接下来的工作，当然标志位需要被一个互斥量保护起来。我们可能会写出下面这样的代码：</p><p><code>bool flag;</code><br><code>std::mutex m</code><br><code>void do_some_task()&#123;</code><br>  <code>...;//线程B完成某些耗时操作；</code><br>  <code>std::lock_guard&lt;std::mutex&gt; lg(m);</code><br>  <code>flag = true;</code><br><code>&#125;</code><br><code>void wait_for_flag()&#123;</code><br>  <code>std::unique_lock&lt;std::mutex&gt; ul(m);</code><br>  <code>while(!flag)&#123;//线程A在此不断检查标志位</code><br>    <code>lk.unlock();</code><br>    <code>lk.lock();</code><br>  <code>&#125;</code><br>  <code>do_something_after_waiting();</code><br><code>&#125;</code></p><p>这就是所谓的忙等待，它有一个很明显的缺点：线程A一直在消耗cpu时间片来查询flag状态，这会浪费掉珍贵的cpu执行时间，并且每次的查询过程中都会持有锁，这也就意味着与此同时其他想要请求锁的线程就需要等待。想象一下一堆线程等待同一个flag状态的场景吧，大量的cpu执行时间片被消耗在检查标志位上，被等待的线程获取到的执行时间片就会减少，导致需要花更长的时间才能执行完前置工作，好不容易flag置位的条件满足了，还要跟一堆检查标志位的等待线程抢占锁，成功获取锁后才能将flag成功置位，这边成功置位了，一堆等待线程又要排队抢占锁……</p><p>一种优化的方式是让等待线程在两次查询之间sleep一段时间，在sleep期间线程是阻塞状态，不会消耗cpu执行时间，其他线程也可以获取锁，好像解决了问题。但是sleep多久合适呢？时间太短，上述两个问题依旧会存在，时间太长，可能等待线程刚sleep，flag就被置位了，那只能等下次被唤醒是才能检查标志位，这就造成了响应不及时。</p><p>C++标准库提供的条件变量可以解决这些烦恼，一个条件变量可以跟一个事件或其他条件变量绑定，一个或多个线程可以等待这个条件变量，当一个条件变量被满足时，可以通知一个或多个线程进行响应。C++标准库提供了两种条件变量：std::condition_variable和std::condition_variable_any,在头文件<condition_variable>声明。条件变量需要跟互斥量一起使用来提供同步。前者只能跟std::mutex配合使用，后者则宽泛得多，可以跟任何满足互斥量最基本特性的对象配合使用，相应的也会消耗更多的资源，所以除非是明确需要特定的灵活特性，一般使用std::condition_variable就足够了，代码示例如下：</p><p><code>std::mutex mut;</code><br><code>std::queue&lt;data_chunk&gt; data_queue;</code><br><code>std::condition_variable data_cond;</code><br><code>void data_preparation_thread()//在线程A中执行</code><br><code>&#123;</code><br>    <code>while(more_data_to_prepare())</code><br>    <code>&#123;</code><br>        <code>data_chunk const data=prepare_data();</code><br>        <code>&#123;</code><br>            <code>std::lock_guard&lt;std::mutex&gt; lk(mut);</code><br>            <code>data_queue.push(data);</code><br>        <code>&#125;</code><br>        <code>data_cond.notify_one();</code><br>        <code>&#125;</code><br><code>&#125;</code></p><p><code>void data_processing_thread()//在线程B中执行</code><br><code>&#123;</code><br>    <code>while(true)</code><br>    <code>&#123;</code><br>        <code>std::unique_lock&lt;std::mutex&gt; lk(mut);</code><br>        <code>data_cond.wait(</code><br>            <code>lk,[]&#123;return !data_queue.empty();&#125;);</code><br>        <code>data_chunk data=data_queue.front();</code><br>        <code>data_queue.pop();</code><br>        <code>lk.unlock();</code><br>        <code>process(data);</code><br>                <code>if(is_last_chunk(data))</code><br>                <code>break;</code><br>    <code>&#125;</code><br><code>&#125;</code></p><p>线程A将数据放入队列后，使用条件变量对象调用notify_one()通知线程B。线程B中使用std::unique_lock&lt;&gt;锁定mut，然后使用条件变量调用wait(),wait()函数的第一个参数是std::unique_lock&lt;&gt;对象，第二个参数则是传入一个lambda表达式作为判断条件。</p><p>wait()函数对参数中的条件进行判断。如果条件没有满足，则释放锁并阻塞当前线程，当notify_one()函数被调用时，线程从阻塞状态被唤醒，重新请求锁并且再次对条件进行判断，此时如果条件满足，函数返回，锁不释放，如果条件依旧不满足，则释放锁并阻塞线程等待下一次唤醒。因为当条件未满足时，等待线程需要释放锁，之后再重新加锁，所以需要使用std::unique_lock&lt;&gt;而不是用std::lock_guard&lt;&gt;。后者会在等待线程阻塞时持有锁，这样工作线程就无法获取锁，自然也就无法向队列中添加数据，并且唤醒等待线程了。</p><p>wait()函数的第二个参数是一个判断条件，接受一切可调用对象作为输入，在wait()函数的执行过程中，作为判断条件的函数（或其他可调用对象）可能会被多次执行，wait()函数确保每次执行都是获取锁的状态，并且一旦条件满足，函数立即返回。有时等待线程在未被通知时也会请求锁并且检查条件，这种情况被称为假醒，假醒的次数跟库的实现方式有关，所以如果判断条件中有一些附加操作，需要做好这些操作被多次执行的准备。</p><p>多个线程等待同一个条件变量时，对条件变量调用notify_one()会唤醒一个等待线程，但是并不能确定是唤醒哪一个，甚至不能保证是否有线程在等待通知，有可能所有线程都在执行各自的任务，没有等待该条件变量。还有一种情景是多个线程需要被同时唤醒，这时可以使用notify_all()，这个函数可以唤醒所有阻塞在wait()的线程对条件进行检查。</p><p>使用条件变量进行线程同步通常适用于重复等待某一事件，等待线程通常会使用一个无限循环等待同一个条件的反复触发，通知信号也会被重复发送。那么对于那些只发生一次的同步事件，使用这种方式会有什么问题吗？我们需要一个互斥量，如果我们使用wait(lk)这样的写法，如果被等待的线程在等待线程执行wait()函数之前就下发了通知，那么等待线程将会永远阻塞在wait()函数那里，而且也无法应对假醒的场景。为了避免这种问题，我们在wait()的第二个参数里写入了判断条件，这样wait()会先判断条件是否满足再决定是否阻塞线程，但是有些时候等待线程可能没办法知道被等待线程怎样才算满足条件，要知道等待线程之所以使用条件变量，就是因为它很难直接去判断被等待的任务是否满足条件。一种改进方案是使用atomic的flag，被等待的线程执行完任务后修改flag值，等待线程在一个while循环中不停检查flag，这种方案不需要互斥量，也不用担心等待线程wait之前被等待任务就下发通知，也不用担心假醒，唯一的缺点就是等待线程一直在消耗硬件资源，因为它不停的在轮询查看flag状态而不是阻塞在那里，就像我们在文章开头提到的那样。将上述两者结合就是将wait的判断条件设置为对flag的判断。但是整个流程会变成这样：被等待的线程任务执行完了，然后通知等待线程可以开始你的工作了，等待线程被唤醒后并不是立刻开始工作，而是要先判断flag值再决定要不要执行接下来的任务，工作是完成了，但是给人的感觉很别扭，用户最初的想法可能只是在线程间传递一个同步信号。更好的方式是使用future和promise结合，等待线程通过future的wait()函数被阻塞(不消耗执行资源)，被等待的线程执行完后对promise执行set_value().对于简单的同步信号来讲，两者的类模板参数都设置为void就可以了，具体的使用方式我们在future的介绍文章中已经详细介绍过，此处不再赘述。</p><p>参考书目：《Effective.Modern.C++》、《C++Concurrency in Action 2nd Edition》</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程学习笔记：线程间数据共享</title>
      <link href="/2022/12/07/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/"/>
      <url>/2022/12/07/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p><strong>不变量（invariants）</strong>是指针对一个特定的数据结构永远为真的一种状态。比如“这个变量保存着链表中条目的数量”。当链表被修改时，不变量被打破，例如当插入和删除操作完成之前。<strong>竞态条件（race condition）</strong>是指程序输出的结果依赖于多个线程的执行顺序。我们常说的竞态条件是指会引发错误的情形。C++定义的<strong>数据竞争（data race）</strong>是指对单个对象的并行修改从而引发竞态条件的一种情形。数据竞争会引发未定义的行为。</p><p>竞态条件比较难发现，因为它发生时间的不确定性，通常是转瞬即逝的。但是随着系统运行时间和负荷的增加，竞态条件会更加容易发生。避免发生竞态条件可以通过使用一种保护机制，使得一次只有一个线程修改数据，例如加锁；还可以通过修改数据结构的设计和它的不变量从而使得数据的修改操作可以通过一系列无法分割的操作来实现，每个操作都可以保护不变量，这种方式涉及到无锁编程（lock-free programming）；再有一种方式就是通过事务来实现，就像数据库操作一样。</p><p>最简单也是最直接的加锁方式是使用互斥量std::mutex，对其调用std::lock()实现加锁，调用std::unlock()实现解锁：</p><p><code>std::mutex m;</code><br><code>std::lock(m);</code><br><code>do_something();</code><br><code>std::unlock(m);</code></p><p>这种方式常见的问题是修改数据后没有调用std::unlock()解锁导致其他线程无法获取锁，有时可能是忘记了，有时可能是do_someting()中抛出了异常导致程序提前退出。所以如果使用std::lock()和std::unlock()完成互斥操作需要程序员考虑到各种情况，保证在程序退出的所有路径中都调用了std::unlock()，例如异常处理。</p><p>C++标准库提供了一种std::lock_guard&lt;&gt;类模板，为std::mutex实现了RAII习语，即在构造函数中获取锁，在析构函数中释放锁，将锁的生命周期与std::lock_guard&lt;&gt;对象的生命周期绑定，从而实现了自动解锁。使用std::lock_guard&lt;&gt;获取锁的方式如下：</p><p><code>std::mutex m;</code><br><code>void func()&#123;</code><br>  <code>std::lock_guard&lt;std::mutex&gt; lg(m);</code><br>  <code>//C++17加入了类模板参数自动推断，所以这一行可以简写成</code><br>  <code>//std::lock_guard lg(m);</code><br>  <code>//C++17还引入了lock_guard的加强版scoped_lock</code><br>  <code>//std::scoped_lock lg(m);</code><br>  <code>do_something();</code><br><code>&#125;</code></p><p>上述代码中当lg在函数的最开始获取锁，在函数完成操作并返回时，lg离开作用域，对象销毁的同时释放锁。与传统的手动方式相比，使用std::lock_guard&lt;&gt;显然更省时省力并更加可靠。</p><p>使用mutex保护共享数据看似很安全，但是还是有其他隐患，例如do_something()这个函数具体做了什么事？如果这个函数返回了受保护数据的指针或者引用，那么意味着其它线程就可以在不获取锁的前提下对数据进行操作，从而形成数据竞争。避免这种情况有一个准则：<strong>不要将被保护的数据的指针或引用传递出锁的作用域，不管是直接返回，还是将之存储在外部可见的存储区域，或是将他们传递给用户提供的函数中作为参数。</strong></p><p>即使单个操作是线程安全的，但是当这些操作组合在一起时同样会引发竞态条件，最简单的方式当然是使用互斥量将所有操作保护起来，但是这会大大影响性能。还有一种方式就是优化接口函数，将多个操作组合为一个操作，并用一个mutex进行保护。</p><p>c++标准库还提供了一种比std::lock_guard&lt;&gt;更具灵活性的类：std::unique_lock&lt;&gt;，相比于std::lock_guard&lt;&gt;整个生命周期中都持有对mutex的锁，std::unique_lock&lt;&gt;并不是始终持有mutex的锁。</p><p>std::unique_lock&lt;&gt;的第二个参数可以设置为:</p><ol><li>std::adopt_lock:表示为一个已经加锁的mutex创建一个lock_guard;</li><li>std::defer_lock:表示表示为一个mutex创建一个lock_guard但是暂时不锁定它;</li><li>std::try_lock:表示为一个mutex创建一个lock_guard并尝试锁定它;</li><li>也可以设置为时间段或者时间点分别表示在时间段内或者某个时间点锁定mutex。</li></ol><p>std::unique_lock&lt;&gt;比std::lock_guard&lt;&gt;的占用稍大并且性能稍弱，因为前者需要维护锁状态，例如需要一个标志位来表示对象当前是否持有锁。在离开作用域时，如果std::unique_lock&lt;&gt;持有锁，则会自动调用std::unlock()释放锁，反之则一定不会调用std::unlock().可以通过owns_lock()函数查询std::unique_lock&lt;&gt;对象是否持有锁。除非有特定用途，std::lock_guard&lt;&gt;是更好的选择。</p><p>一个使用std::unique_lock&lt;&gt;的场景就是延迟加锁，还有就是传递锁的所有权。例如</p><p><code>std::unique_lock&lt;std::mutex&gt; get_lock()</code><br><code>&#123;</code><br>    <code>extern std::mutex some_mutex;</code><br>    <code>std::unique_lock&lt;std::mutex&gt; lk(some_mutex);</code><br>    <code>prepare_data();</code><br>    <code>return lk;</code><br><code>&#125;</code><br><code>void process_data()</code><br><code>&#123;</code><br>    <code>std::unique_lock&lt;std::mutex&gt; lk(get_lock());</code><br>    <code>do_something();</code><br><code>&#125;</code></p><p>这里为什么不能用std::lock_guard&lt;&gt;？很简单，因为离开作用域后随着std::lock_guard&lt;&gt;对象的析构锁就被释放了，如果此时有其他线程对其加锁，那传递过程就失败了。而由于std::lock_guard&lt;&gt;并不一定持有锁，所以锁的所有权就可以通过移动语义在对象间传递。从函数返回对象，移动操作是自动进行的，其他时候需要调用std::move()来实现对象的移动。std::unique_lock&lt;&gt;和std::lock_guard&lt;&gt;的对象都是无法拷贝但是可移动。</p><p>std::unique_lock&lt;&gt;还有一个特性是可以提前解锁，而不必等到其对象离开作用域，这一特性的意义在于当用户明确知道无需再占有锁时，可以及时释放，从而让其他线程可以获取锁。</p><p>要合理控制锁的粒度，尽量不要在进行耗时操作时（如硬盘文件IO操作）持有锁。</p><p>提到锁，一个绕不开的话题就是死锁。引发死锁的原因是线程间的相互等待，不光是互相等待对方释放锁，线程间相互join这种情况也能引发死锁。《C++Concurrency in Action 2nd Edition》中为避免死锁提供了若干建议：</p><ol><li><p>避免嵌套加锁：已经获取一个锁以后，不要再尝试获取锁，如果必须要加多个锁，可以使用std::lock()一次性请求。</p></li><li><p>避免加锁后执行用户提供的代码。本质上跟第一条相同，因为无法判定用户的代码中作了什么操作，如果用户代码中请求了锁，那么就违背了第一条建议。但是在编写泛型代码的时候，这种情况无法避免。</p></li><li><p>以固定顺序请求锁。当必须请求多个锁又无法使用std::lock()一次性请求时，最好的方法就是在每个线程中以一个固定顺序请求它们。这里所说的顺序固定是相对于所有线程，加锁的顺序都是一致的，类似如下函数：</p><p>a.exchange_data_with(b);</p><p>两个实例互换数据，调用方和作为参数的一方实例都需要加锁，就不能单纯的在函数中先lock a再lock b，因为如果当调用主体变了，加锁的顺序也就随之变了，应该保证不论谁是调用方，在函数中的加锁顺序都是a先于b或者相反。</p><p>再比如多线程访问双向链表，每次对当前节点加锁，读取数据，然后再请求下一个节点的锁，成功后释放当前节点的锁。如果不能保证绝对顺序的一致，那么当两个线程分别从链表的头尾进行访问时，在中间的某个点相遇时就会遭遇死锁。此时想要防止死锁可以通过限制链表的访问顺序来实现。</p></li><li><p>为锁引入层级概念。这其实是第三条的一种特例。具体做法是将应用程序进行分层，然后标记每个层次的每个锁，当代码试图请求锁时，如果已经在更低的层级获取到了一个锁，那么本次加锁会失败。以此来保证加锁的顺序一致。</p></li></ol><p>有时我们需要保证在多线程的场景下一个操作只调用一次。像延迟初始化的场景，例如数据库操作，每次操作之前都要确认一下连接是否建立，如果没有就需要创建连接并且这个操作只能进行一次。在没有更好的办法之前，我们可能会使用现有学到的东西写出如下代码：</p><p><code>&#123;</code><br>  <code>std::unique_lock&lt;std::mutex&gt; lk(resource_mutex);</code><br>    <code>if(!connected)</code><br>    <code>&#123;</code><br>        <code>connect_db();</code><br>    <code>&#125;</code><br>    <code>lk.unlock();</code><br><code>do_something();</code><br><code>&#125;</code></p><p>这种写法可能是最下意识的写法了，并且也能达到目的，但是这种写法有一个问题，因为每次请求都要加锁判断是否存在数据库连接，所有的线程会去抢占同一个锁，当有大量的并行的访问请求到达时，会造成线程的排队从而降低性能。为此，C++标准库提供了一种解决方案：std::call_once()，该函数配合std::once_flag对象使用可以保证某个函数只被调用一次。具体用法如下：</p><p><code>std::once_flag flag;</code><br><code>std::call_once(flag,connect_db);</code><br><code>do_something();</code></p><p>使用这种方式，所有的互斥操作就交由标准库执行，使用这种方式比直接使用mutex性能要强，尤其是当像connect_db这样的一次性操作已经执行过时。</p><p>C++11标准后出现了替代std::call_once()的方式，就是使用static声明全局静态变量。C++11以后，标准规定static变量在被首次访问之前已经完成了初始化，并且这种操作是线程安全的。利用这个特性，我们可以很容易写出线程安全的单例模式的代码：</p><p><code>class X；</code><br><code>X&amp; get_instance()&#123;</code><br>  <code>static X x;</code><br>  <code>return x;</code><br><code>&#125;</code></p><p>上述两种机制只是在初始化时保护数据，对数据的修改只是在初始化时进行一次，如果遇到偶尔修改的的数据，该用什么方式呢？有些数据可能很长时间才会被修改一次，如DNS缓存数据，修改这种数据的时候我们需要保证其他线程的读取操作是被阻塞的以防止读到错误的数据。最简单的方式当然还是使用一个mutex，读取和修改操作前先获取锁。但是为了一个偶然的写操作而让所有的读操作去请求锁显然是不合理的，而且会大大影响性能。C++提供了一种读写锁的机制来应对这种场景。它允许多个读操作同时用有锁，但是只允许一个写操作用有锁，并且当写操作拥有锁时，其他读操作无法再获取锁。</p><p>C++14提供了std::shared_timed_mutex,C++17增加了std::shared_mutex，C++11则没有提供读写锁。写锁的获取可以使用std::lock_guard或std::unique_lock，读锁的获取可以使用std::shared_lock；</p><p>标准库还提供了递归锁，普通的mutex多次加锁会导致未定义的行为，但是std::recursive_mutex可以多次上锁，但是当你发现你需要用递归锁的时候，最好是重新审视一下你的设计。</p><p>参考书目：《C++Concurrency in Action 2nd Edition》</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程学习笔记：future</title>
      <link href="/2022/12/07/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Afuture/"/>
      <url>/2022/12/07/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Afuture/</url>
      
        <content type="html"><![CDATA[<p>future&lt;&gt;是一个模板类，用来表示某一操作的成果，可以是一个返回值或者异常，模板参数表示返回值的类型，如果为void表示没有返回值。具体的信息会被保存在与future相关联的一个shared state内。获取future的方式有以下几种：调用std::async()的返回值，通过std::packaged_task或promise创建出来。</p><p>std::packaged_task&lt;&gt;模板类在头文件<future>中声明，它将future与一个函数或可调用对象绑定在一起，当packaged_task调用时，其绑定的函数或可调用对象被调用并且future的状态被设置为ready，函数的返回值被存储在future关联的shared state中。使用packaged_task的好处是所有任务可以被包装成一个个执行单元，而这些执行单元是可以作为对象传递的（packaged_task对象是可移动的，但是不可复制）packaged_task对象本身也是一个可调用对象，可以像其他可调用对象那样使用。我们可以将不同的任务包装成packaged_task实例传给执行线程或者线程池，负责执行的线程只需要获取packaged_task对象，然后调用对象，仅此而已。</p><p>packaged_task&lt;&gt;的模板函数是一个函数签名，如packaged_task&lt;int(int)&gt;表示封装的函数接受一个int参数并返回一个int类型的值。当传入packaged_task构造函数的函数或者可调用对象的参数值或返回值符合隐式转换规则时，也可以构造成功，如上述模板也可以接受一个参数为double或返回值为double的函数。</p><p>通过对packaged_task对象调用get_future()可以获取相关联的future，封装函数的返回值类型决定了通过调用get_future()函数返回的futrue的模板参数类型。packaged_task的用法一般是先把任务函数封装成一个packaged_task对象，然后通过get_future()函数获取future，然后将实例发送给执行单元。当需要任务函数的执行结果时，对future调用get();</p><p>std::packaged_task&lt;&gt;的使用方法如下所示：</p><p><code>std::packaged_task&lt;void()&gt; task(print_once);</code><br><code>auto fut = task.get_future();</code><br><code>task();</code><br><code>fut.wait();</code></p><p>std::promise<T>是跟std::future<T>成对出现的，promise负责写数据，与其对应的的future则可以读取该数据，这种即使可以用来作为线程间点对点传输数据的一种手段。使用模板参数为void的std::promise和std::future是线程间传递同步信号的一种很好的选择。使用promise传递数据的方法如下所示：</p><p><code>std::promise&lt;int&gt; p;</code><br><code>auto fut = p.get_future();</code><br><code>p.set_value(10);</code><br><code>cout&lt;&lt;fut.get()&lt;&lt;endl;</code></p><p>使用promise在线程间传递信号如下所示：</p><p><code>std::promise&lt;void&gt; p;</code><br><code>std::thread t(</code><br>    <code>[&amp;p]&#123;</code><br>      <code>std::this_thread::sleep_for(std::chrono::seconds(1));</code><br>      <code>cout&lt;&lt;&quot;thread first&quot;&lt;&lt;endl;</code><br>      <code>p.set_value();</code><br>    <code>&#125;</code><br>    <code>);</code><br><code>p.get_future().wait();</code><br><code>cout&lt;&lt;&quot;hello&quot;&lt;&lt;endl;</code><br><code>t.join();</code></p><p>我们使用线程t来模拟一个耗时操作，主线程需要等待线程t完成才能进行下一步的工作，使用promise和future的组合只需要在主线程调用wait()等待future状态变为ready，工作线程中只需要在任务完成后对promise调用set_value()就可以完成线程间同步信号的传递了，具体到我们的代码里现象就是hello一定会在thread first输出后才会输出。</p><p>需要注意的是promise和future之前的信息传送是一次性的，并且由于需要一个shared state来保存返回值以及状态等信息，所以需要额外的堆上分配和回收的开销。</p><p>对future调用get()会取出future的返回值，并且取出后会使future处于无效状态，所以对future的get()调用只可以进行一次，多次调用会导致异常，C++标准库推荐抛出一个夹带std::future_errc::no_state错误码的future_error异常，但这不是强制的。</p><p>那么如果我们想要对future多次调用get()有没有什么好的办法呢？比如多个线程在等待同一个计算结果的情形。此时我们可以使用shared future，shared future和future的主要区别是前者允许多次调用get()，调用get()后不会令其状态失效。shared future对象是支持拷贝语义的，而future对象只支持移动语义。shared future的get()函数是const的，返回一个const reference指向存储在shared state中的值，而future的get()函数是non-const的，返回一个move-assigned拷贝，如果返回值类型不支持移动语义才会返回copy。</p><p>shared_future可以直接通过std::async()的返回值获取，但是需要指定返回值类型：</p><p><code>shared_future&lt;void&gt; sf = std::async(print_once);</code></p><p>等价于：</p><p><code>auto fut = std::async(print_once);</code><br><code>shared_future&lt;void&gt; sf = std::move(fut);</code></p><p>如果想使用auto，可以通过调用future的share()函数获取shared future:</p><p><code>auto sf = std::async(print_once).share();</code></p><p>future的析构函数中并没有执行join或者detach等特殊操作，仅仅是析构其自身的成员变量，另外还会对shared state中的引用计数进行了一次自减。如果future是最后一个关联通过std::async创建的non-deferred任务的future实例，那么future会阻塞直到任务函数返回才销毁。比如我们通过std::async()函数指定std::launch::async策略创建了一个异步任务获得了一个shared future，shared future可能有很多副本，当某一个副本离开作用域时，如果还存在其他副本，那么这个副本就会紧紧析构自身，然后将shared state的引用计数减1，如果这个副本已经是关联这个shared state的最后一个future了，那么会等待异步任务结束再执行future的析构函数。</p><p>参考书目：《Effective.Modern.C++》、《C++Concurrency in Action 2nd Edition》、《C++标准库第二版》、《Primer C++ 第五版》</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QMainWindow</title>
      <link href="/2022/12/06/QMainwindow/"/>
      <url>/2022/12/06/QMainwindow/</url>
      
        <content type="html"><![CDATA[<p>主窗口提供了构建用户界面的框架，QT通过QMainWindow和相关的类提供主窗口的管理。在一个主窗口中，可以添加若干个QToolBar，QDockWidget和一个QMenuBar，一个QStatusBar。每个主窗口都有一个中心区域用来填充任意类型的组件。主窗口的布局结构如下图。其中一个主窗口一定要有一个Central Widget，即便只是一个占位符。</p><p><img src="data:image/jpeg;base64,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" alt="img"></p><p>设置Central Widget</p><p>可以通过setCentralWidget()函数设置主窗口的Central Widget，主窗口的widget可以是标准的QWdiget，也可以是自定义的widget。</p><p>创建一个没有任何附加组件的QMainWindow并显示的代码如下：</p><p><code>#include &lt;QApplication&gt;</code><br><code>#include &lt;QMainWindow&gt;</code><br><code>int main(int argc,char *argv[]) &#123;</code><br>    <code>QApplication app(argc,argv);</code><br>    <code>QMainWindow window;</code><br>    <code>window.resize(800,600);</code><br>    <code>window.show();</code><br>    <code>return app.exec();</code><br><code>&#125;</code></p><p><strong>创建菜单栏</strong></p><p>QT通过QMenu创建菜单然后将他们添加到QMenuBar中.QMainWindow提供了一个函数menuBar()，该函数返回主窗口默认的QMenuBar，也可以自己新建QMenuBar然后通过QMainWindw 的setMenuBar()函数将新建的QMenuBar添加到主窗口中，如果是用户自定义的菜单栏组件，可以通过QMainWindow的setMenuWidget()函数将自定义菜单栏添加到主窗口中。</p><p>QMenuBar通过addMenu()函数向菜单栏中添加菜单项，该函数有三个重载：</p><table><thead><tr><th>QAction *</th><th><a href="qmenubar.html#addMenu">addMenu</a>(QMenu *<em>menu</em>)</th></tr></thead><tbody><tr><td>QMenu *</td><td><a href="qmenubar.html#addMenu-1">addMenu</a>(const QString &amp;<em>title</em>)</td></tr><tr><td>QMenu *</td><td><a href="qmenubar.html#addMenu-2">addMenu</a>(const QIcon &amp;<em>icon</em>, const QString &amp;<em>title</em>)</td></tr></tbody></table><p>第一个重载会添加一个现有的QMenu到QMenuBar中并返回相应QMenu的menuAction()，这种方式添加的QMenu，QMenuBar并没有取得QMenu的所有权。</p><p>后两个重载会新建一个QMenu并添加到QMenuBar中，用这两种方式添加的QMenu，QMenuBar拥有所有权。</p><p>为主窗口添加MenuBar的代码如下：</p><p><code>QMenuBar* menuBar = window.menuBar();//获取主窗口默认的menuBar</code><br><code>QMenu* menu1 = menuBar-&gt;addMenu(QMainWindow::tr(&quot;menu1&quot;));//向menuBar中添加menu</code><br><code>QMenu* menu2 = menuBar-&gt;addMenu(QMainWindow::tr(&quot;menu2&quot;));</code><br><code>QMenu* menu3 = menuBar-&gt;addMenu(QMainWindow::tr(&quot;menu3&quot;));</code></p><p><code>menu1-&gt;addAction(&quot;action1&quot;);//如果menu中没有任何内容，默认不显示</code><br><code>menu2-&gt;addAction(&quot;action2&quot;);</code><br><code>menu3-&gt;addAction(&quot;action3&quot;);</code></p><p>需要注意的是，如果添加的menu中没有内容，那么该menu项默认是不显示的，所以需要通过QMenu的addAction()函数添加下拉菜单的内容。运行后效果如下：</p><p><img src="data:image/jpeg;base64,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Lq1IpqUpK7s3069Fbz6eTtdFj5duf7h3bMbS3RTIoG5cg46lSQcqMfejlTk21uu9tdlqr7/e+qja5vFz9npPRa37rq1d38rJdOqdxq7m42/MrLIDwOcg56loycbVyFGMk5DAVHLtfb7Wn5u2npe/a1ve2U273V5fFB33/C71trf1VtQdC5Zi20lgAcb/ACy3U55wSMFcDA5IIzVqyvb79e/3JWtr9+zIr805K7ScrWiul73eja3WyXloSFSFYEg/LnIHJPRmALbS7KFBwMA5bYuRultXT172fXV9ddd+n3fCVyvlkm09LXW6drPTS91pa/8AnFgHzZAJO4hwCx64DEEDkgDHG3GMcNktbaS2+Xk/Ltd212v5MwipSaS6PV7p207rW34aa3chAAJABgvySvzYC42+oBfAALFeAcbSCSz1fl26/PrdPTt87g7KSaXPq7xd1bytu2mt7NelmpOwAc4jUHJ28Hbknov+6fmwQTtPTAFTypbWb7Wdtno90u+776bR0VSduZvlhJ621a97bu/dtezaXndjw4behJycDKjt0zjIOWVnGFGVxnccis5U7tNa666W/V9fJW87nRTxEVCVObskrxe9+re3fp1682rihOc/fKkB1dR8xzuByF4BwR8x6nIAbbvVKDTvrokmu19knd/l56fCNVfaQs5XUvhl6J62tffru+vLdOVY4kOSXw2wx/MVYHbsUbe2DlgAQNw3BiMmtoqyWmvX7+/W39bnBKSnPlbfKleLfktrb3+d7q+tkOXqVIA4bIyJGf5ePMbBEaqCMk7uOueXVtLpfp8vS913e2nnoEZN6PRXl1vfTVv71+d3a0YG2oxGFJJzw2CSfTG4E5Xgknft4UgOV0Vno2+lvO/k30205fV3XLzSTpSk1G93dx20/mvtorru91sxjNHtw8YXaeGwXYZ+6oAH3iCQuQ+zr3XcJu+i36aL5r0Xe299b2HKcNeZXVn7ybulfXRW1drWbdumz5xyAQf4CVIx0B7fNzzztPKFVYkZNCXM3p7ye29/xT73v6dLxTbgudaU/daW7vtf0turrezve8bEe1sHO3kHkZbcTtzt46I23jgqRkgjcsy/G1r+nppp366eZrSStzW00d/nvbo9X3vv3cY9xDuACT3IVdj4yAfnI2bj91d6r/d3gNUNNrXvtun8ml1219b6SNpVI+0cYqW0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KWb83NGbupOyXVxu9dErrpZ67NN3sRGQZOAVClGZlLEAkEMTtDMU3LkqqdQSc4O21RbSUrP5dPvte2+tlZPW3vctTHzd4wquMPdk2urT29L32v1S3vEZySoZlwGyOG4JIb7pz0Ct905DMGKjaUqvZqN7LW1tr/l/T67C+szqcnvNJPmUXLfq9Xtfdu0tu6Iz/wAs2Rg205QEALwTkgn5Vye4+8uM804pJtNJu29+/lb105n807E15VJ04zhUduf3Ytq7trs7NL1fnpa8RDJnLEE4G2N+VDoc4xxlQx+623gDbjOGtxjZOy63f3dOmltfy1cuWNSs6jvJ7e7DdrW715e973Wi6y+yxegIOCzP/CcfNnJx95BuJAQEjC4Od2Ktq9ktV3217L1vfr+kcY1LSlzXTbezun0bdktdNNEvS3vqELFhvYggqSAdp27snoTuUKTvyDkjlshlb5LKytr07dv01a8rWbkk6vtHzScrq1+iWq031t3W+97giqMAD5Tknhc7SfkYE4PXPDBQWye9TdO7d7t6eXbt+X3fZuHPBxUfg2lezbXlo2r72tp5WHhuRkZHBwcYGcjcSyjICg/J2ZsgEbTWcqbS0TXe/XrffS731eut18EuyGJhOSi1pZJK6Svs79F10smur0SkrAfN6vgbRgbgDx97OQFB5wxO75elUnyuKabS330f4v8AP52MavLNVOVcstOXzS0t1Svpu9ObrrzRCNlbcxO4MJDnBUZJCjO0dQqrn5uDngkLW3NFpu23f8r2W/yttre5wOnJSunZyd2k7633typNPa3y0+IYiF2+8SFOcAMDgcsOeWyQW4PzEcZANJpJLd67a6fn9/zVm7CUuafvOycuie//AJN9/wB7krxikis23ZkAfOhRSkecFsHLEnKdyGB67Qflpwtb11VtLd139NZPz1FVk5bLVO19l195qz6a76dnYNqn70bkpgrgkDJwd+ScDaeST8x2gY5xVbLRaapX6Wt9/b5kLllr53b7u+62tpb189hzBXb5Ny8MwRvu/dXlckJv3BcA788/MASKhNpOUr6v0/R277a+VjWcIzcYwlq03JPy11k9299LfglJp3HJJZduWGNoDAgDdzzgk52jgYOPlyy2uv8AXT9N+v6Rxkm+VJ8iXldfc2tGtdHH0ejJVVBhc7A8ZG9SRgEhSSxLtu3BTycgnAzj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g1JKMUt1JLVSTd769Xe935NEZVBwdx5P39qskmRnHcPIpBOTgZ4+bDLXNd3SV0tNVZ+mul1a1v8AyV2UsJpQj78npKWtm7JPZ/D1tq7Wuk1qnG1H5S7TGzFipU4VCSQcAZYsoXqoMqgYGRIAd64Scnf3LLd7Wb7ddLd0t99WdFCUYvWXNfS8tknZfDrd3s7KS7bpIerbp3G0KW3xt9z72RuV8NjgkLwy4OTtbCOqcfc++3qtF5uy027bm8akuZXk9Oremn8u1r7betlblRblXDEIASzYKnGwf3VYlkdGAy23aCVxtG12XN02tVe2j21/NL8NdbXuz0fridPkck4t2drpr5q1773ba20+Ef5sag5AUjadzEJtcjIVdjA8xkEj5sL82FYqal022tk099Nem2/a927231XLnSq8jmqj5opXXa26vrbTyXXpd80sV2gXhMAhixVd7AH5QFO37nXEkgOT/H8wK5Toyk9Oi0Vlrrd3bva6W7fN5rVnQscoWV9L372Wt7pXu79FLXs7NF6K6VckuSmSqgsjE9M7h5iYCk4IywwD93CMnLUw3MrO7k27bX32aWr93b01SteXVRx7TT+zZ6t25lrte32rrRa2TVrNFxL5CUGCuTlBnDHrkHjCheARuUsVJHKtXM8NNNrX3Vdr/Lo/weml7py9COOhyqTSd72t30/xJPz1XS2zla+3QlgX2IT/ABB0C7yuWw6co3GMk4bttO01zKhUWsdVdu9lp/lo13vddVaOsMXS0TacrfLXRN+8r99t9NdR6XEbnHLllySCpAJIweV5UA9WViME7wW+WHCpFaKz13Vr62e97bdVHyvdm6q05TipNO/ntffVatttuyXdX0XLeinhQvGyhtzEpkKTkAFhIC3OAw2nhQUyQMqy804Tklyt3Td0/wBVfXTTd23d7o6lWpaJWtq0/wDD1W366aa7RtxXKMwOCoJLoEI3liCuMZZQ2c/JkEDeRgAleWdOfVu+9vX77ra+julsrLn6o1o3UY25Wm230VtfTe20nZ3VrvmVZ4nYgoSSxYgyRouXA5BG7YXyM8+owCQyz7OUVd7L4Xt+C773bV+iuryv6xBfDHfdb6aq781vpe97u2iLAMJJYjcHGWBKnIY7TmTZg4AIDSJtIHVdxas5Smrroldbb3769mldel7tGsYwlq38TtLyu9vJvfRJa63d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" alt="img"></p><p><strong>创建工具栏</strong></p><p>可以通过QMainWindow的addToolBar()函数为窗口添加工具栏。toolbar中的工具项则通过QToolBar提供的函数addAction()完成。为主窗口添加toolbar的代码如下：</p><p><code>QToolBar* toolbar = window.addToolBar(&quot;file&quot;);</code><br><code>toolbar-&gt;addAction(&quot;tool1&quot;);</code><br><code>toolbar-&gt;addAction(&quot;tool1&quot;);</code><br><code>toolbar-&gt;addAction(&quot;tool1&quot;);</code><br><code>toolbar-&gt;addAction(&quot;tool1&quot;);</code><br><code>toolbar-&gt;addAction(&quot;tool1&quot;);</code></p><p>效果如下：</p><p><img src="data:image/jpeg;base64,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" alt="img"></p><p>不论是QMenu还是QToolBar，使用addAction()函数添加项目时都会返回一个QAction对象，可以使用信号槽将该对象连接至指定方法，达到调用函数的目的。</p><p><strong>创建状态栏</strong></p><p>可以通过QMainWindow的setStatusBar()来设置自定义状态栏，也可以使用statusBar()返回默认的状态栏，QStatusBar提供了两个槽函数：clearMessage(),showMessage(),通过函数名就能知道这两个函数的用途。</p><p>获取主窗口状态栏并显示信息的代码如下：</p><p><code>QStatusBar* statusBar = window.statusBar();//获取默认状态栏</code><br><code>statusBar-&gt;showMessage(&quot;test&quot;,3000);//显示信息，三秒后消失</code></p><p>创建dock widget</p><p><code>QDockWidget *dockWidget = new QDockWidget(&quot;Dock Widget&quot;); window.addDockWidget(Qt::LeftDockWidgetArea, dockWidget);</code></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt的隐式共享</title>
      <link href="/2022/12/06/%E9%9A%90%E5%BC%8F%E5%85%B1%E4%BA%AB/"/>
      <url>/2022/12/06/%E9%9A%90%E5%BC%8F%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>QT中的C++类使用隐式共享来最大化资源的利用率并减少拷贝。使用隐式共享的类实例在被当作参数进行传递的时候兼顾了安全和性能，因为只有指向数据的指针被传递了。只有当数据被改写的时候才会被整体拷贝，也就是copy-on-write。</p><p>共享类由一个指向共享数据块的指针构成；数据块中包含了数据和一个引用计数。</p><p>当一个共享实例被创建后，它的引用计数被设置为1，只要一个对象引用了共享数据，引用计数就增加1，反之如果有实例解除引用，引用计数就减1.当引用计数归零时，共享数据被删除。</p><p>隐式共享对象赋值都是使用的浅拷贝，也就是只有指针被复制。</p><p>隐式共享一般来说对程序员时透明的，但是使用QT的容器迭代器时，需要引起注意，隐式共享可能带来一下和标准库不一样的行为。所以当容器上有迭代器在操作时，应该避免拷贝该容器。</p><p>多线程情况下隐式共享也能发挥作用。</p><p>可以使用QSharedData和QSharedDataPointer类实现自己的隐式共享类。</p><p>当引用计数大于1并且一个对象要被修改时，它就被从共享块中分离出来。共享数据在被修改之前就被从共享块中分离出来。有一个特例就是在QT的容器迭代器时。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象树和所有权</title>
      <link href="/2022/12/06/%E5%AF%B9%E8%B1%A1%E6%A0%91%E5%92%8C%E6%89%80%E6%9C%89%E6%9D%83/"/>
      <url>/2022/12/06/%E5%AF%B9%E8%B1%A1%E6%A0%91%E5%92%8C%E6%89%80%E6%9C%89%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>多个QObject是通过对象树进行组织的。当创建一个QObject并且指定父对象（也是一个QObject）时，它就被添加到父对象的children列表里。当父对象销毁的时候，子对象也跟着一起销毁。</p><p>可以直接删除子对象，子对象删除后，会从父对象的children列表中移除</p><p>关于QObject对象构造析构的顺序，分两种情况<br>如果多个QObject是在堆上创建的，那么它们是通过一个树形结构组织在一起的，这个树型结构在构建时的顺序是任意的，之后树形结构上的QObject的销毁顺序也是任意的。如果一个QObject有父对象，析构函数会将它从父对象的children列表中删除，如果有子对象，那析构函数会销毁所有子对象。QT保证无论QObject是按照什么顺序销毁的，每个QObject都不会被重复销毁。<br>如果多个QObject是在栈上创建的，那么构造和析构的顺序遵循C++规范，析构顺序与构造顺序相反，但是当两个对象存在父子关系时，需要注意：<br><code>QWidget window;</code><br><code>QPushButton quit(&quot;Quit&quot;, &amp;window);</code></p><p>这种写法，在析构时，先析构quit，再析构window，不会出现问题。<br><code>QPushButton quit(&quot;Quit&quot;);</code><br><code>QWidget window;</code><br><code>quit.setParent(&amp;window);</code></p><p>这种写法，在析构时，会先析构window，但是因为window有一个子对象quit，所以会调用quit的析构函数，window的析构函数执行结束后，quit的函数又被调用了一次，会导致同一块内存被释放了两次，造成程序崩溃。<br>可以调换两者顺序，像上面的程序一样，也可以在堆上新建quit，像这样：<br><code>QPushButton *quit = new QPushButton(&quot;quit&quot;);</code><br><code>QWidget window;</code><br><code>quit-&gt;setParent(&amp;window);</code></p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元对象系统</title>
      <link href="/2022/12/06/%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/12/06/%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>QT的元对象系统提供了对象间通信的信号槽机制，运行时类型信息，和动态属性。<br>元对象系统有三个组成部分：<br>QObject：为所有需要使用元对象系统的类提供的一个基类；<br>Q_OBJECT：在QObject子类私有部分声明（一般是类声明的第一行），声明这个宏可以为当前类提供元对象系统特性，比如动态属性，信号槽等；<br>Meta-Object Compiler(MOC):为每个QObject子类提供必要的代码以实现元对象特性。</p><p>moc工具读取C++源文件，如果发现类中包含了Q_OBJECT宏，就另外生成一个C++源文件，在这个源文件中有对应类的元对象代码。这些生成的源文件可以直接通过#include导入原有的源文件中，或者有更常见的做法，就是编译后链接至指定的类实现。<br>元对象系统提供了以下功能：<br>1.信号槽，QT元对象系统的引入，主要就是为了提供这个机制；<br>2.QObject::metaObject()可以返回类对应的元对象；<br>3.QMetaObject::className()可以在运行时返回类名，这一功能不需要C++编译器支持RTTI；<br>4.QObject::inherits()判断一个对象是否是一个QObject对象树上某一个类的实例；<br>5.QObject::tr()提供字符串国际化；<br>6.QObject::setProperty()和 QObject::property() 动态设定和获取属性名；<br>7.QMetaObject::newInstance()构造一个类的实例。</p><p>元对象系统为QObject类及其子类提供了了动态类型转换函数qobject_cast(),效果类似标准C++的dynamic_cast().它不需要以来RTTI并且在动态链接库间也能正常工作。该函数如果成功则返回一个尖括号中指定的指针类型，如果失败则返回一个nullptr。<br>例如有一个QWidget的子类MyWidget声明了Q_OBJECT宏：<br><code>QObject *obj = new MyWidget;</code><br><code>QWidget *widget = qobject_cast&lt;QWidget *&gt;(obj);</code><br><code>MyWidget *myWidget = qobject_cast&lt;MyWidget *&gt;(obj);</code></p><p>第一次转型成功，因为obj实际指向的就是一个QWidget的派生类对象。<br>第二次转型成功，因为类型转换后得到的widget实际指向的是一个MyWidget实例，所以从<em>widget转型至</em>MyWidget也是成功的。qobjcet_cast()并不区分内置的qt类型和自定义类型。<br>但是以下的转换是失败的：<br><code>QLabel *label = qobject_cast&lt;QLabel *&gt;(obj);</code></p><p>QLable和MyWidget虽然都派生自QWidget，但是两者没有直接的派生关系，所以不能动态转换。<br>理论上是可以从QObject基类派生出一个子类，但是不声明Q_OBJECT宏的，这样moc就不会为这个类生成相应的代码，这个类的实例也就不能使用元对象系统的特性。从元系统的角度，认为这个类和它最近的拥有元系统代码（声明了Q_OBJECT宏）的父类是等同的。也就意味着，如果调用QMetaOjbect::className(),函数返回的是最近的拥有元系统特性的父类的名称。这可能会带来一些麻烦。<br>所以不管是否使用元系统特性，QT官方都建议凡是QObject的子类，都要声明Q_OBJECT宏。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS系统下QT连接mysql数据库</title>
      <link href="/2022/12/06/MacOS%E7%B3%BB%E7%BB%9F%E4%B8%8BQT%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/12/06/MacOS%E7%B3%BB%E7%BB%9F%E4%B8%8BQT%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>MACOS版本：12.3.1</p><p>Qt版本：5.15.2</p><p>1.安装mysql数据库，我的电脑上的安装目录为&#x2F;usr&#x2F;local&#x2F;mysql</p><p>2.准备一个测试程序打印一下当前qt加载的数据库驱动：</p><p>main.cpp</p><p><code>#include &lt;QApplication&gt;</code><br><code>#include &lt;QSqlDatabase&gt;</code><br><code>#include &lt;QDebug&gt;</code><br><code>int main(int argc,char* argv[]) &#123;</code><br>  <code>QApplication app(argc,argv);</code><br>  <code>QStringList drivers = QSqlDatabase::drivers();</code><br>  <code>foreach(QString driver,drivers)</code> <br>  <code>qDebug()&lt;&lt;driver;</code><br>  <code>return app.exec();</code><br><code>&#125;</code></p><p>接下来编写CMakeLists.txt</p><p>qt连接数据库需要编译时引入sql组件</p><p><code>cmake_minimum_required(VERSION 3.0)</code><br><code>project(qt_sql_test) s</code><br><code>et(CMAKE_CXX_STANDARD 11)</code><br><code>set(CMAKE_AUTOMOC ON)</code><br><code>set(CMAKE_AUTOUIC ON)</code><br><code>set(CMAKE_AUTORCC ON)</code><br><code>set(CMAKE_PREFIX_PATH /Users/wenxinyuan/Qt/5.15.2/clang_64)</code><br><code>find_package(Qt5 COMPONENTS Core Widgets Sql REQUIRED)</code><br><code>link_libraries(</code><br><code>Qt5::Core</code><br><code>Qt5::Widgets</code><br><code>Qt5::Sql</code><br><code>)</code><br><code>aux_source_directory(./srcs)</code><br><code>add_executable(qt_sql_test $&#123;srcs&#125;)</code></p><p>需要注意的是第9行，如果没有这一行，那么使用cmake构建的时候就会得到类似下面这样的提示：</p><blockquote><p>CMake Error at CMakeLists.txt:10 (find_package):<br>  By not providing “FindQt5.cmake” in CMAKE_MODULE_PATH this project has<br>  asked CMake to find a package configuration file provided by “Qt5”, but<br>  CMake did not find one.</p><p>  Could not find a package configuration file provided by “Qt5” with any of<br>  the following names:</p><p>Qt5Config.cmake<br>qt5-config.cmake</p><p>  Add the installation prefix of “Qt5” to CMAKE_PREFIX_PATH or set “Qt5_DIR”<br>  to a directory containing one of the above files.  If “Qt5” provides a<br>  separate development package or SDK, be sure it has been installed.</p></blockquote><p>所以我们按照提示设置下qt的安装目录，这个安装目录就是bin文件夹所在的目录</p><p>输出的结果如下：</p><p>“QSQLITE”</p><p>“QODBC”</p><p>“QODBC3”</p><p>“QPSQL”</p><p>“QPSQL7”</p><p>以上结果说明当前的qt中没有mysql的驱动，这就需要我们自行编译安装mysql的驱动。</p><p>qt官网中5.15版本的文档提供了编译mysql驱动以及安装插件的方法，链接如下:</p><p><a href="https://doc.qt.io/qt-5/sql-driver.html#driverwithqt">https://doc.qt.io/qt-5/sql-driver.html#driverwithqt</a></p><p>但是按照官网的方法在我的电脑上没有成功，我也找不到原因，所以我使用另一种方案</p><p>首先进入mysql驱动的源码目录,在我的电脑上，这个目录是</p><p>&#x2F;Users&#x2F;wenxinyuan&#x2F;QT&#x2F;5.15.2&#x2F;Src&#x2F;qtbase&#x2F;src&#x2F;plugins&#x2F;sqldrivers&#x2F;mysql</p><p>这个目录中有一个名称为mysql.pro的文件，打开文件做一下修改：</p><p><code>TARGET = qsqlmysql</code></p><p><code>HEADERS += $$PWD/qsql_mysql_p.h</code><br><code>SOURCES += $$PWD/qsql_mysql.cpp $$PWD/main.cpp</code></p><p><code>#QMAKE_USE += mysql //将原本的这一行注释掉</code><br><code>INCLUDEPATH+=/usr/local/mysql/include //添加mysql的include目录</code><br><code>LIBS+= -L /usr/local/mysql/lib -lmysqlclient //添加mysql的lib目录</code></p><p><code>OTHER_FILES += mysql.json</code></p><p><code>PLUGIN_CLASS_NAME = QMYSQLDriverPlugin</code><br><code>include(../qsqldriverbase.pri)</code></p><p>修改保存后就可以执行qmake进行构建：</p><p>&#x2F;Users&#x2F;wenxinyuan&#x2F;Qt&#x2F;5.15.2&#x2F;clang_64&#x2F;bin&#x2F;qmake  mysql.pro</p><p>由于我没有设置环境变量，所以使用了qmake的完整路径。</p><p>构建过程中没有输出，最后会生成一个新的Makefile文件。直接执行，make进行编译</p><p>编译生成的文件放在下面的目录,注意跟源码目录的差别。</p><p>&#x2F;Users&#x2F;wenxinyuan&#x2F;Qt&#x2F;5.15.2&#x2F;Src&#x2F;qtbase&#x2F;plugins&#x2F;sqldrivers</p><p>我们直接执行make install进行安装</p><p>编译好的库文件会被安装到目录</p><p>&#x2F;Users&#x2F;wenxinyuan&#x2F;Qt&#x2F;5.15.2&#x2F;clang_64&#x2F;plugins&#x2F;sqldrivers</p><p>中。至此我们已经完成的mysql驱动的编译以及安装。使用文章开头的程序重新检测输出如下：</p><p>“QSQLITE”</p><p>“QMARIADB”</p><p>“QMYSQL”</p><p>“QMYSQL3”</p><p>“QODBC”</p><p>“QODBC3”</p><p>“QPSQL”</p><p>“QPSQL7”</p><p>说明qt已经可以检测到mysql的驱动了。</p><p>接下来我们连接一下本地的数据库进行测试，连接数据库代码如下：</p><p><code>#include &lt;QApplication&gt;</code><br><code>#include &lt;QSqlDatabase&gt;</code><br><code>#include &lt;QDebug&gt;</code></p><p><code>int main(int argc,char* argv[])</code><br><code>&#123;</code><br>    <code>QApplication app(argc,argv);</code><br>    <code>QSqlDatabase db = QSqlDatabase::addDatabase(&quot;QMYSQL&quot;);</code><br>    <code>db.setHostName(&quot;localhost&quot;);</code><br>    <code>db.setDatabaseName(&quot;test1&quot;);</code><br>    <code>db.setUserName(&quot;xinyuan&quot;);</code><br>    <code>db.setPassword(&quot;123456&quot;);</code><br>    <code>bool ret = db.open();</code><br>    <code>qDebug()&lt;&lt;ret;</code><br>    <code>return app.exec();</code><br><code>&#125;</code></p><p>编译后运行输出结果如下：</p><p>QSqlDatabase: QMYSQL driver not loaded QSqlDatabase: available drivers: QSQLITE QMARIADB QMYSQL QMYSQL3 QODBC QODBC3 QPSQL QPSQL7 false</p><p>可以看到虽然qt已经识别到mysql的驱动，但是连接还是失败了。</p><p>为了排查原因，我们设置下环境变量<strong>QT_DEBUG_PLUGINS</strong>&#x3D;1,并重新运行看一下debug信息：</p><p>export QT_DEBUG_PLUGINS&#x3D;1</p><p>运行后输出的信息很多，我们提取最后的有用信息：</p><p>Reason: tried: ‘&#x2F;Users&#x2F;wenxinyuan&#x2F;sources&#x2F;qtsql&#x2F;build&#x2F;..&#x2F;Frameworks&#x2F;libmysqlclient.21.dylib’ (no such file), ‘&#x2F;Users&#x2F;wenxinyuan&#x2F;Qt&#x2F;5.15.2&#x2F;clang_64&#x2F;plugins&#x2F;sqldrivers&#x2F;..&#x2F;..&#x2F;lib&#x2F;libmysqlclient.21.dylib’ (no such file), ‘&#x2F;Users&#x2F;wenxinyuan&#x2F;sources&#x2F;qtsql&#x2F;build&#x2F;..&#x2F;Frameworks&#x2F;libmysqlclient.21.dylib’ (no such file), ‘&#x2F;Users&#x2F;wenxinyuan&#x2F;Qt&#x2F;5.15.2&#x2F;clang_64&#x2F;plugins&#x2F;sqldrivers&#x2F;..&#x2F;..&#x2F;lib&#x2F;libmysqlclient.21.dylib’ (no such file), ‘&#x2F;Users&#x2F;wenxinyuan&#x2F;sources&#x2F;qtsql&#x2F;build&#x2F;..&#x2F;Frameworks&#x2F;libmysqlclient.21.dylib’ (no such file), ‘&#x2F;Users&#x2F;wenxinyuan&#x2F;Qt&#x2F;5.15.2&#x2F;clang_64&#x2F;lib&#x2F;QtCore.framework&#x2F;Versions&#x2F;5&#x2F;Frameworks&#x2F;libmysqlclient.21.dylib’ (no such file), ‘&#x2F;Users&#x2F;wenxinyuan&#x2F;Qt&#x2F;5.15.2&#x2F;clang_64&#x2F;lib&#x2F;libmysqlclient.21.dylib’ (no such file), ‘&#x2F;usr&#x2F;local&#x2F;lib&#x2F;libmysqlclient.21.dylib’ (no such file), ‘&#x2F;usr&#x2F;lib&#x2F;libmysqlclient.21.dylib’ (no such file))</p><p>可以看到无法加载驱动的原因是相关的mysql的库找不到，那解决方案就很简单了，只需要在CMakeLists.txt文件中添加下相关的库目录就行了，在我的环境下，添加如下命令即可：</p><p>link_directories(     </p><p>&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;lib</p><p>​          )</p><p>重新编译运行后，db.open()返回值为true，成功连接上数据库；</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程学习笔记：使用std::async()创建异步任务</title>
      <link href="/2022/12/06/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8async()%E5%88%9B%E5%BB%BA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
      <url>/2022/12/06/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8async()%E5%88%9B%E5%BB%BA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>C++标准库提供了一个高层接口用于创建异步任务：std::async()，跟std::thread构造函数一样，该函数同样可以接受任何可调用类型对象作为参数，函数返回一个future<T>类型的对象，future<T>是一个模板类，类型参数T表示任务函数返回值的类型，如果任务函数没有返回值，则T为void。使用std::async()创建异步任务的方法如下：</p><p><code>void print_once()&#123;</code><br>    <code>this_thread::sleep_for(chrono::seconds(1));</code><br>    <code>cout&lt;&lt;&quot;hello world from thread： &quot;&lt;&lt;std::this_thread::get_id()&lt;&lt;endl;</code><br><code>&#125;;</code><br><code>int main()&#123;</code><br>  <code>std::future&lt;void&gt; res = std::async(print_once);</code><br>  <code>res.wait();</code><br>  <code>return 0;</code><br><code>&#125;</code></p><p>使用std::async()创建异步任务与使用std::thread创建线程有一个重要的差异，就是前者并不保证任务函数一定在单独的线程中执行，也就是说std::async()并不保证一定会创建一个新的线程，自然也不能保证创建异步任务后任务函数会立刻开始执行。那如果调用线程需要确保异步任务执行结束或者需要获取异步任务的执行结果呢？答案是使用std::async()返回的future对象调用wait()或get()，wait()函数会阻塞直到异步任务执行完毕，get()函数会阻塞直到异步任务执行完毕并从获取任务函数的返回值。wait()函数和get()函数会强制启动future关联的线程并等待线程执行结束。</p><p>到这里我们已经可以发现使用std::async()的第一个好处了：我们可以获取任务函数的执行结果！当我们使用std::thread创建线程时，线程创建后就独立运行，如果任务函数有返回值，即便线程执行结束，我们也没有办法通过线程对象获取到任务函数的返回值，只能通过传入引用或者修改共享内存等方法来获取线程的执行结果。但是使用std::async()我们只需要对其返回的future执行get()就可以轻松获取线程的执行结果！future还有一个强大的功能，传递异常！当我们使用std::thread创建线程时，如果线程中的函数抛出异常，会发生什么呢？我们来模拟一下这种情况，先写个简单的测试函数，抛出一个异常：</p><p><code>int func()&#123;</code><br>  <code>throw logic_error(&quot;error&quot;);</code><br><code>&#125;</code></p><p>我们像往常一样使用try-catch块将调用函数的地方包起来，看看会发生什么：</p><p><code>try&#123;</code><br>  <code>std::thread t(func);</code><br>  <code>t.join();</code><br><code>&#125;catch (exception &amp;e)&#123;</code><br>  <code>cout&lt;&lt;e.what()&lt;&lt;endl;</code><br><code>&#125;</code></p><p>代码执行后报错：libc++abi: terminating with uncaught exception of type std::logic_error: error。</p><p>怎么会这样呢？这是因为如果将异常从任务函数向上传递给std::thread的构造函数，异常并不会被传递给创建线程的主线程，所以在主线程中当然不会捕获到任何异常，所以未处理的异常会导致std::terminate()被调用，整个程序就会被终止。因为一个线程的异常导致整个程序被异常终止通常不是我们想要的结果，理想的结果是只有发生异常的线程被终止，其他线程不受影响。要想达成这样的目的，我们可以在任务函数中将所有异常处理掉，不让异常向上传递，但是实际开发时，你不能保证所有的任务函数都出自同一个程序员之手，甚至不能保证所有函数你都能看到源码，所以也不能保证这些任务函数都会有自己的异常处理代码；第二种方法是在创建线程时使用try-catch块包裹住任务函数：</p><p><code>std::thread t([]&#123;try&#123;func();&#125;catch(exception &amp;e)&#123;cout&lt;&lt;e.what()&lt;&lt;endl ;&#125;&#125;);</code></p><p>这种方式明显比第一种方式优雅许多。那么使用std::async()创建的异步任务怎么处理异常呢？答案是使用try-catch将get()调用包裹起来,甚至如果你不想处理异常，你都可以不写任何异常处理代码，也不会导致程序异常终止！当然这种做法是不提倡的。</p><p><code>auto res = std::async(func);</code><br><code>try&#123;</code><br>  <code>res.get();</code><br><code>&#125;catch (exception &amp;e)&#123;</code><br>  <code>cout&lt;&lt;e.what()&lt;&lt;endl;</code><br><code>&#125;</code></p><p>我们用auto来修饰std::async()的返回值，这是一种常用的简化代码的方式，我们不必去记住每个任务函数的返回类型。异步任务中的异常信息会被保存在一个shared state对象当中，该对象是引用计数的。当对返回值future调用get()时，保存在shared state中的异常会被重新抛出，我们就可以在try-catch块中捕捉异常了。</p><p>在文章的开头我们说过，使用std::async()创建的异步任务可能并不会创建一个新的线程单独运行，也不保证在函数调用后异步任务立刻就开始执行，只是保证在对future调用的wait()或get()函数返回时，异步任务已经执行完毕。这种行为就像是我们为我们将来可能使用的某个结果安排了一个异步任务，标准库保证我们在需要这个结果的时候异步任务会执行完并将结果返回给我们，如果我们以后不需要这个结果了，那么我们提前安排的异步任务可能根本就不会执行。那么我们能手动控制这种行为吗？答案是肯定的。std::async()函数的第一个参数用于指定发射（Launch）策略，当没有手动指定的时候（就像之前我们的用法），会启用默认策略。标准库提供的策略有三种：</p><ol><li><p>std::launch::deferred：任务函数会在当前线程中执行并会延迟执行直到wait()或get()被调用；</p></li><li><p>std::launch::async：任务函数会在独立线程中立即执行；</p></li><li><p>std::launch::deferred|std::launch::async：选择哪种执行方式交给具体实现。</p></li></ol><p>默认的策略是第三种，所以如果我们期望异步任务一定要在单独线程中执行时，应该明确指定Launch策略为std::launch::async：</p><p><code>auto res = std::async(std::launch::async,func);</code></p><p>当我们指定策略为std::launch::async时，即便我们未来没有对res调用wait()或get(),在res离开作用域被销毁之前，主线程也会等待直到异步任务执行结束。相反如果我们指定策略为std::launch::deffered，在我们调用wait()和get()之前，任务函数根本就不会被执行。</p><p>使用默认策略会将选择权交给标准库，标准库会根据全局的线程使用情况来选择使用哪种策略。这就带来一个问题，就是当你使用默认策略的时候，你并不知道任务函数会在当前线程还是新线程中执行，如果函数涉及到一些thread_local类型数据的修改，就会导致你不知道究竟是哪个线程的数据被修改了。另外假如你想要等待某个异步任务执行成功，写了如下代码：</p><p><code>auto res = std::async(func);</code></p><p><code>while(res.wait_for(1000ms)!=std::future_status::ready)&#123;</code></p><p><code>...</code></p><p><code>&#125;</code></p><p>你可能会被永远困在循环中！因为如果自动选定的策略是deferred，那么wait_for()函数的返回结果永远都会是std::future_status::defferred。wait_for()函数会等待一段时间并返回future的状态，当任务函数执行完毕后，future会被设置为ready，该状态被保存在future关联的shared state对象当中，类似的函数还有wait_until(),与wait()函数不同，wait_for()和wait_until()只会返回future的状态，并不会强制启动异步任务。</p><p>参考书目：《Effective.Modern.C++》、《C++Concurrency in Action 2nd Edition》、《C++标准库第二版》、《Primer C++ 第五版》</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（八）：音视频同步</title>
      <link href="/2022/12/05/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5/"/>
      <url>/2022/12/05/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>ffplay的音视频同步模式有三种，音频流为主，视频流为主，外部时钟为主，定义在一个枚举类型中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  AV_SYNC_AUDIO_MASTER,</span><br><span class="line">  AV_SYNC_VIDEO_MASTER,</span><br><span class="line">  AV_SYNC_EXTERNAL_CLOCK,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>语音视频同步相关的还有一个结构体Clock，它与PacketQueue是绑定的，表示某一个流的时钟：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Clock</span> &#123;</span></span><br><span class="line">  <span class="type">double</span> pts;           <span class="comment">/* clock base */</span></span><br><span class="line">  <span class="type">double</span> pts_drift;     <span class="comment">/* clock base minus time at which we updated the clock */</span></span><br><span class="line">  <span class="type">double</span> last_updated;<span class="comment">//上次更新的时间</span></span><br><span class="line">  <span class="type">double</span> speed;<span class="comment">//时钟速度</span></span><br><span class="line">  <span class="type">int</span> serial;<span class="comment">//时钟的序列号 /* clock is based on a packet with this serial */</span></span><br><span class="line">  <span class="type">int</span> paused;<span class="comment">//暂停标志位</span></span><br><span class="line">  <span class="type">int</span> *queue_serial;<span class="comment">//指向时钟绑定的包队列的序列号</span></span><br><span class="line">&#125; Clock;</span><br></pre></td></tr></table></figure><p>时钟用来记录各个流的播放时间点，这里需要注意的是pts_drift这个值，它用来表示更新时钟时pts相对于当前系统时间点的偏移量。有了这个值，我们获取任意时间点的时钟，只需要获取系统时间再加上这个偏移量即可；但是这种计算方式有一个前提，就是时钟的速度是恒定的，由于Clock中表示速度的speed字段是会改变的，所以计算实际的时间点时，还需要减去速度差带来的误差，所以最终获取时钟的算法就变成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> time = av_gettime_relative() / <span class="number">1000000.0</span>;</span><br><span class="line"><span class="keyword">return</span> c-&gt;pts_drift + time - (time - c-&gt;last_updated) * (<span class="number">1.0</span> - c-&gt;speed);</span><br></pre></td></tr></table></figure><p>音频流的时钟会在callback调用的时候更新，视频流的时钟会在video_refresh函数中读取新一帧的时候更新，两者的逻辑都是先更新本身的时钟，然后再将外部时钟与自身的时钟同步。</p><p>我们先来分析默认的AV_SYNC_AUDIO_MASTER情形。这种情况下音频流的时钟为主时钟，所以对于音频流来讲只要按照顺序将解析好的数据发送给音频设备正常播放就行了，与此同时，每解析一帧音频数据，音频流的时钟都会更新，更新后的时钟也会同步到外部时钟。对于视频流来说，需要播放时同步音频流的时钟，如果视频流的时钟快于主时钟，那么就需要通过重复播放视频帧来等待音频流，相反如果视频流的时钟慢于主时钟，那就要丢帧去追赶音频流。视频同步音频的算法我们在之前分析视频播放的时候已经看过，我们现在重温一遍：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">double</span> <span class="title function_">compute_target_delay</span><span class="params">(<span class="type">double</span> delay, VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> sync_threshold, diff = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* update delay to follow master synchronisation source */</span></span><br><span class="line">  <span class="keyword">if</span> (get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER) &#123;</span><br><span class="line">    <span class="comment">/* if video is slave, we try to correct big delays by</span></span><br><span class="line"><span class="comment">       duplicating or deleting a frame */</span></span><br><span class="line">    <span class="comment">//如果不是音频同步视频，通过复制帧或者丢帧来修正延时</span></span><br><span class="line">    diff = get_clock(&amp;is-&gt;vidclk) - get_master_clock(is);<span class="comment">//视频流是时钟和主时钟的差值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* skip or repeat frame. We take into account the</span></span><br><span class="line"><span class="comment">       delay to compute the threshold. I still don&#x27;t know</span></span><br><span class="line"><span class="comment">       if it is the best guess */</span></span><br><span class="line">    sync_threshold = FFMAX(AV_SYNC_THRESHOLD_MIN, FFMIN(AV_SYNC_THRESHOLD_MAX, delay));<span class="comment">//算一个时间差阈值，如果delay在最大和最小阈值范围内，取delay，过大了，去最大阈值，过小了取最小阈值</span></span><br><span class="line">    <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; is-&gt;max_frame_duration) &#123;</span><br><span class="line">      <span class="keyword">if</span> (diff &lt;= -sync_threshold)<span class="comment">//视频流慢太多了，delay需要减小，这样下一帧能更快显示（跳帧）</span></span><br><span class="line">        delay = FFMAX(<span class="number">0</span>, delay + diff);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold &amp;&amp; delay &gt; AV_SYNC_FRAMEDUP_THRESHOLD)<span class="comment">//（重复帧）</span></span><br><span class="line">        delay = delay + diff;<span class="comment">//视频流快太多了，并且延时超过了复制一帧的最大阈值。这个阈值的意思是，如果上一帧的持续时间超过了这个值，就不应该通过重复帧来进行同步</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold)</span><br><span class="line">        delay = <span class="number">2</span> * delay;<span class="comment">//视频流快太多，且上一帧的持续时间没超过阈值，将延迟增加一倍</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  av_log(<span class="literal">NULL</span>, AV_LOG_TRACE, <span class="string">&quot;video: delay=%0.3f A-V=%f\n&quot;</span>,</span><br><span class="line">         delay, -diff);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> delay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的主要思想是根据视频流时钟与主时钟的差值来计算当前帧的实际显示时间，如果当前时钟慢了，就缩小显示时间，反之就延长显示时间。计算时会有一个阈值，在这个阈值的正负值范围内，认为音视频是同步的，不需要校正。在这一步计算出当前帧的显示时间后，如果计算的结果是延长显示时间，那么相应的帧的显示时间会被拉长以达到等待音频流的目的。如果就算的结果是缩短显示时间，甚至显示时间被缩短到最小的0，那么会根据相应的算法进行丢帧以达到追赶音频流的目的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">is-&gt;frame_timer += delay;<span class="comment">//上述条件未满足，先将timer设置为上一帧结束的时间，这个值现在表示的是当前帧的显示时间</span></span><br><span class="line">      <span class="keyword">if</span> (delay &gt; <span class="number">0</span> &amp;&amp; time - is-&gt;frame_timer &gt; AV_SYNC_THRESHOLD_MAX)<span class="comment">//如果跟当前时间差超过时间同步最大阈值，将时间点设置为当前时间</span></span><br><span class="line">        is-&gt;frame_timer = time;<span class="comment">//如果不执行这一步，结果就是连续好多帧的结束时间都会小于当前时间点，如果设置可以丢帧，就会导致连续丢好多帧，造成视频的不连续，比如暂停一段时间后再恢复播放，这个值就需要更新</span></span><br><span class="line"></span><br><span class="line">SDL_LockMutex(is-&gt;pictq.mutex);</span><br><span class="line"><span class="keyword">if</span> (!isnan(vp-&gt;pts))<span class="comment">//使用当前帧的数据更新视频流时钟</span></span><br><span class="line">    update_video_pts(is, vp-&gt;pts, vp-&gt;pos, vp-&gt;serial);</span><br><span class="line">SDL_UnlockMutex(is-&gt;pictq.mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (frame_queue_nb_remaining(&amp;is-&gt;pictq) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Frame *nextvp = frame_queue_peek_next(&amp;is-&gt;pictq);</span><br><span class="line">        duration = vp_duration(is, vp, nextvp);<span class="comment">//当前帧的显示时长</span></span><br><span class="line">        <span class="keyword">if</span>(!is-&gt;step &amp;&amp; (framedrop&gt;<span class="number">0</span> || (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &amp;&amp; time &gt; is-&gt;frame_timer + duration)&#123;</span><br><span class="line">          is-&gt;frame_drops_late++;<span class="comment">//如果当前时间点晚于当前帧结束的时间点，就丢弃一帧，按照现实逻辑，其实丢弃的是上一帧</span></span><br><span class="line">          frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">          <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>丢帧的逻辑很简单，就是计算下一帧的结束时间，如果这个时间比当前系统时间还小，那就执行丢帧动作。</p><p>接下来我们再来分析AV_SYNC_VIDEO_MASTER的情况，从上面的两段函数中可以看出，当视频流为主时，每一帧的显示时间不需要修正，后面的丢帧动作也不会执行，此时视频流会按照自己的时钟播放。同样的，无论是否是视频流为主的情况，视频帧没解析一帧，都会更新视频流的时钟，并同步到外部时钟。</p><p>与视频流重复帧等待，丢帧追赶的逻辑相似，音频流是通过增减样本数的方式同步主时钟的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">synchronize_audio</span><span class="params">(VideoState *is, <span class="type">int</span> nb_samples)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> wanted_nb_samples = nb_samples;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* if not master, then we try to remove or add samples to correct the clock */</span></span><br><span class="line">  <span class="keyword">if</span> (get_master_sync_type(is) != AV_SYNC_AUDIO_MASTER) &#123;</span><br><span class="line">    <span class="type">double</span> diff, avg_diff;</span><br><span class="line">    <span class="type">int</span> min_nb_samples, max_nb_samples;</span><br><span class="line"></span><br><span class="line">    diff = get_clock(&amp;is-&gt;audclk) - get_master_clock(is);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">      is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef * is-&gt;audio_diff_cum;</span><br><span class="line">      <span class="keyword">if</span> (is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) &#123;</span><br><span class="line">        <span class="comment">/* not enough measures to have a correct estimate */</span></span><br><span class="line">        is-&gt;audio_diff_avg_count++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* estimate the A-V difference */</span></span><br><span class="line">        avg_diff = is-&gt;audio_diff_cum * (<span class="number">1.0</span> - is-&gt;audio_diff_avg_coef);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) &#123;</span><br><span class="line">          wanted_nb_samples = nb_samples + (<span class="type">int</span>)(diff * is-&gt;audio_src.freq);</span><br><span class="line">          min_nb_samples = ((nb_samples * (<span class="number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX) / <span class="number">100</span>));</span><br><span class="line">          max_nb_samples = ((nb_samples * (<span class="number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) / <span class="number">100</span>));</span><br><span class="line">          wanted_nb_samples = av_clip(wanted_nb_samples, min_nb_samples, max_nb_samples);</span><br><span class="line">        &#125;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_TRACE, <span class="string">&quot;diff=%f adiff=%f sample_diff=%d apts=%0.3f %f\n&quot;</span>,</span><br><span class="line">               diff, avg_diff, wanted_nb_samples - nb_samples,</span><br><span class="line">               is-&gt;audio_clock, is-&gt;audio_diff_threshold);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* too big difference : may be initial PTS errors, so</span></span><br><span class="line"><span class="comment">         reset A-V filter */</span></span><br><span class="line">      is-&gt;audio_diff_avg_count = <span class="number">0</span>;</span><br><span class="line">      is-&gt;audio_diff_cum       = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> wanted_nb_samples;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到，与视频同步每一帧都进行修正不同，音频流每AUDIO_DIFF_AVG_NB帧进行一次修正。AUDIO_DIFF_AVG_NB的默认值是20，对于每一帧，计算音频时钟和主时钟的差值，当没有达到20帧时，通过加权算法累计总的偏移量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef * is-&gt;audio_diff_cum;</span><br></pre></td></tr></table></figure><p>其中audio_diff_avg_coef是加权系数。</p><p>当累计20帧时，计算出平均偏移量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avg_diff = is-&gt;audio_diff_cum * (<span class="number">1.0</span> - is-&gt;audio_diff_avg_coef);</span><br></pre></td></tr></table></figure><p>然后根据这个偏移量与阈值的关系计算实际的样本数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) &#123;</span><br><span class="line">         wanted_nb_samples = nb_samples + (<span class="type">int</span>)(diff * is-&gt;audio_src.freq);</span><br><span class="line">         min_nb_samples = ((nb_samples * (<span class="number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX) / <span class="number">100</span>));</span><br><span class="line">         max_nb_samples = ((nb_samples * (<span class="number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) / <span class="number">100</span>));</span><br><span class="line">         wanted_nb_samples = av_clip(wanted_nb_samples, min_nb_samples, max_nb_samples);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>阈值audio_diff_threshold是硬件缓存样本容量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is-&gt;audio_diff_threshold = (<span class="type">double</span>)(is-&gt;audio_hw_buf_size) / is-&gt;audio_tgt.bytes_per_sec;</span><br></pre></td></tr></table></figure><p>计算样本数的逻辑其实神简单，只是计算平均偏移量的那个算法以及加权系数的选择我着实是无法理解，网上也搜不到相关的解释，希望有知道的朋友能不吝赐教。</p><p>现在就剩下最后一种AV_SYNC_EXTERNAL_CLOCK，其实从compute_target_delay和synchronize_audio代码中的判断条件我们很容易知道，两者都是使用不等式判断，而不是等式判断，所以我们就能推断出，同步外部时钟就是上述两种情况的结合，只不过这次的主时钟变成了外部时钟。不过有一点比较有意思的是，不论是音频流还是视频流，都会将外部时钟与自己的时钟同步，那么这种模式到底有什么用呢？我的理解是，这种模式相当于音视频流互相同步。回顾音视频处理数据的代码，将外部时钟与当前流时钟同步的操作都是在执行完同步算法之后。此时ffplay就认为当前流的时钟是同步的，更新外部时钟是为了消除剩下的一丁点”误差“。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程学习笔记：async()与thread对比</title>
      <link href="/2022/12/05/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Aasync()%E4%B8%8Ethread%E5%AF%B9%E6%AF%94/"/>
      <url>/2022/12/05/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Aasync()%E4%B8%8Ethread%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<p>通过std::thread类创建的线程，用户拥有最大的自由度，同时也需要承担相应的风险，我们先来看看使用std::thread创建线程后我们需要面临什么。</p><p>首先，通过非默认构造函数成功创建出线程对象后，我们必须保证在线程对象离开作用域被销毁之前对其调用join()或detach(),否则会造成程序终止。以join()为例，我们必须保证在任何情况下线程对象在销毁前都能调用join()函数，包括异常处理。这需要特别的细心以及不小的工作量，同时可能产生大量重复的代码。幸好C++的RAII机制可以减轻我们的负担，RAII是Resource Acquisition Is Initialization的缩写，即“资源获取即初始化”，是C++的一项技术，它将资源的获取放在类的构造函数中，资源的释放放在类的析构函数中，这样，资源的获取和释放就与类对象的生命周期绑定了，这样做可以有效的避免内存泄漏。我们可以将线程放入一个类中，然后将join放在类的析构函数中，这样只要离开了类实例的作用域，当类实例销毁时就会调用join()。一个简单的线程包裹类的实现如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class thread_guard&#123;</span><br><span class="line">  thread t;</span><br><span class="line"> public:</span><br><span class="line">  explicit thread_guard(thread _t):t(std::move(_t))&#123;</span><br><span class="line">    if(!t.joinable())</span><br><span class="line">      throw std::logic_error(&quot;No thread&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  thread_guard(const thread_guard&amp;)=delete;</span><br><span class="line">  thread_guard&amp; operator=(const thread_guard&amp;)=delete;</span><br><span class="line">  ~thread_guard()&#123;</span><br><span class="line">    t.join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们先来看不使用包裹类的时候我们应该怎样写：</p><p><code>int func()&#123;</code><br>  <code>throw logic_error(&quot;error&quot;);</code><br><code>&#125;</code><br><code>int main()&#123;</code><br>  <code>std::thread t(print_once);</code><br>  <code>try&#123;</code><br>    <code>func();</code><br>    <code>t.join();</code><br>  <code>&#125;catch (exception &amp;e)&#123;</code><br>    <code>cout&lt;&lt;e.what()&lt;&lt;endl;</code><br>    <code>t.join();</code><br>    <code>return -1;</code><br>  <code>&#125;</code><br>  <code>return 0;</code><br><code>&#125;</code></p><p>我们用func()函数模拟异常，可以看到t.join()出现在了两处地方，如果func()不只会抛出一个异常，或者有多个类似func()这样会抛出异常的函数，我们就需要在每个异常处理的代码块中调用t.join()，一不小心漏掉一个就会导致程序的异常退出，而这种错误往往不是那么容易发现，因为测试的时候可能无法模拟所有异常的场景。而使用thread_guard后，代码就会变得很简单：</p><p><code>int main()&#123;</code><br>  <code>thread_guard(std::thread(print_once));</code><br>  <code>try&#123;</code><br>    <code>func();</code><br>  <code>&#125;catch (exception &amp;e)&#123;</code><br>    <code>cout&lt;&lt;e.what()&lt;&lt;endl;</code><br>    <code>return -1;</code><br>  <code>&#125;</code><br>  <code>return 0;</code><br><code>&#125;</code></p><p>线程的join()交给运行时环境去处理，不论是从任何正常逻辑退出程序还是发生了任何异常，只要离开了thread_guard对象的作用域，就会对线程对象调用join()。detach()的操作也可以使用类似的方式，不过detach()由于分离线程，所以一般在创建了线程对象后直接调用，所以不太需要用到这种方式。</p><p>现在我们已经不用担心因为线程没有被join或detach而导致程序异常退出了，我们创建了一个线程去执行我们的计算函数，然后就可以一遍做其他事情一遍等线程执行结束获取计算结果了。等等！我们怎么获取计算结果？std::thread只负责帮我们创建线程，但是线程执行结束后的返回值我们怎么获取呢？没有一个方法可以帮我们获取任务函数的返回值！所以只能靠我们自己在函数执行结束后将结果写入共享内存中，那我们就需要使用锁来避免数据竞争，无形中又增加了代码量。如果在我们的任务函数的执行过程中产生了异常，我们还需要确保异常在线程中被处理，如果任务函数直接抛出异常，异常不但不会被传递到线程外，还会导致线程终止，从而导致整个程序异常终止。我们又增加了一些代码来处理异常：（，这些事情都做完了，没有其他的事情需要操心了吧？</p><p>更棘手的还在后面，我们将系统层面的线程称作软件线程，将CPU实际执行计算时使用的线程叫做硬件线程。而软件线程的资源是有限的，如果我们新建线程的时候软件线程的数量达到了系统限制的最大数量，那么就会创建失败并抛出std::system_error异常，而且这个异常是强制抛出的，即便你使用了noexcept修饰词。处理这种情况我们要么等待其他线程执行结束释放资源，这也是靠运气的，万一其他线程也在等待这个新建线程的执行结果呢：），要么直接将任务安排在当前线程完成，但如果当前线程是个GUI线程，这种做法会导致界面未响应的问题。</p><p>好，我增加硬件，修改系统参数，调大软件线程的最大数量，把软件线程资源用尽的可能性降到最低，是不是就没问题了呢？不是！即便软件线程的数量是无限的，但是硬件线程的数量终究是有限的，那么当就绪状态的软件线程的数量超过了硬件线程的数量，这时就会发生超订（oversubscription）。线程调度器会为每一个就绪的线程在cpu上分配时间片，当一个线程的时间片结束，另一个线程的时间片开始时，就会发生上下文的切换，这种切换会增加系统开销，尤其是同一个线程的两个相邻的时间片在不同的CPU内核上执行时，上一个时间片缓存的数据全部作废，这个时间片的数据需要重新写入现在这个核的缓存，写入的时候很可能还会覆盖掉其他线程未使用的缓存数据，那么其他线程下一个时间片时就要重新写入数据。避免超订是很困难的一件事，即使你可以在软件层面尽可能的进行优化，但是不同cpu的硬件线程数和缓存也不一样，你不可能照顾到所有情况。而且厉害到可以优化线程调度器的大佬估计也不会看这篇文章：）。</p><p>可能很多体量很小的程序极少遇到上面说的那些情况，但是人总是要进步的，你不可能永远只维护那么几百行代码两三个线程的小程序，问题总是要解决的。那么这么多难题摆在面前，我们该从哪里开始着手解决呢？当然是把问题交给更厉害的人去解决呀：）。std::async()就是我们最容易找到的更厉害的那个”人“。使用std::async()创建异步任务，我们不需要担心线程join和detach的事情，而且我们还能从返回值future中获取到任务函数的返回值以及任务函数执行中发生的异常信息，并且即使发生了异常，也只是异常所在的线程终止，并不会导致整个程序的终止。虽然仍旧无法完全避免超订，但是将线程的调度交给运行时调度器去做大多数情况下会比程序员自己做的更好，因为运行时调度器管理着所有进程中的线程，它会比人更清楚硬件的使用情况，从而做出最优的选择，如果系统线程耗尽了或者发生了超订，std::async()可以选择让任务函数在当前线程中执行，或者延后执行。使用std::async()并不会使线程耗尽或者超订的问题消失，只是将这种情况的处理从程序员的手中接管过去并且利用自身对全局的掌握选择当前的最优解，如果这些事都交给程序员去解决，很可能还会导致负载均衡的问题。并且随着标准库的发展，更好的线程调度算法会被应用，如果程序使用std::async()管理线程，到时候会自动从这些发展中受益。如果不是有着非使用std::thread不可的原因，干嘛不用std::async()呢？</p><p>非使用std::thread不可的原因来了，C++的并发库是基于不同平台的底层API实现的，如windows的线程库和POSIX的线程库pthread。当我们需要使用一些C++并发库没有提供的功能时（如线程优先级），就需要用到底层API，相应的我们需要获得底层平台的线程句柄，std::thread类的native_handle成员函数就可以实现这一操作，而future是没有类似功能的。还有一种情况是你需要对你的线程有绝对的掌控，一般是针对特定的硬件环境开发的专属程序，或者你想自己实现一个线程池。</p><p>参考书目：《Effective.Modern.C++》、《C++Concurrency in Action 2nd Edition》、《C++标准库第二版》、《Primer C++ 第五版》</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程学习笔记：使用std::thread类创建线程</title>
      <link href="/2022/12/05/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8thread%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/12/05/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8thread%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>自C++11开始，标准库增加了多线程的支持，使用标准库创建线程有两种方式：</p><p>1.使用std::thread类创建线程实例</p><p>2.使用std::async函数创建异步任务</p><p>我们先从第一种开始介绍。无论是哪种创建方式，C++支持的可调用类型都可以作为参数传入，例如函数，函数指针，函数对象，lambda表达式，bind创建的对象以及function类型等。我们先准备几个可调用对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_per_second</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;hello world from thread：&quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>()&lt;&lt;endl;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_once</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;hello world from thread： &quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>()&lt;&lt;endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;hello world from thread：&quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>()&lt;&lt;endl;</span><br><span class="line">      this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两个print函数和一个重载了函数调用运算符的类，函数和重载的函数调用运算符执行的操作也很简单，只是输出一行带有线程id的信息，get_id是命名空间this_thread提供的一个全局函数，作用是返回当前线程的id。</p><p>现在我们创建第一个线程，创建方式也很简单，我们使用print_once的函数名作为阐述传给std::thread的构造函数就能得到一个线程实例，并且实例创建完成后，线程自动开始运行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(print_once)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行这段代码，发现并没有按照我们预期运行，反而是被终止了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libc++abi: terminating</span><br><span class="line">信号: SIGABRT (signal SIGABRT)</span><br></pre></td></tr></table></figure><p>产生这种错误的原因是C++标准规定，线程对象在销毁前一定要调用join()或detach()，否则会导致程序被终止（terminated）调用join()会使程序阻塞在调用点直到线程执行结束，相当于等待线程完成；调用detach()则是将线程与主线程分离，分离后的线程会独自运行直到线程调用的函数返回或主程序退出。</p><p>对于一个线程实例只能调用一次join()或detach()，多次调用会导致程序抛出异常。为了判断线程对象是否可以调用join()或detach()，标准库提供了一个joinable()函数返回一个表示线程对象joinable状态的bool值。当joinable()的返回值为true时，才可以对线程对象调用join()或detach();</p><p>我们修改刚才的代码，在主线程中等待t1结束：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(print_once)</span></span>;</span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样代码就正常运行了，当然这里也可以调用detach()，只不过这样一来，如果print_once执行的是某种耗时操作，例如等待几秒后再打印信息，那么在程序退出之前，该信息就无法打印出来了。</p><p>还有一点需要注意的是标准规定的是在线程对象销毁之前一定要对其调用join()或detach()，这就可能造成一个比较有意思的现象，看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(print_once)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(print_per_second)</span></span>;</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码只对t2调用了join()，但是对t1却没有调用，这段代码编译运行后并没有报错。原因是t2线程执行的函数是一个无限循环的函数，主线程会一直等待在t2.join()这个调用点不退出，所以t1就是始终在作用域，不会被销毁，所以也不会因为没有对其调用join()而导致程序终止。想要验证这一点也很简单，只需要将t2.join()改成t2.detach()即可。t2线程被分离，主线程不等待t2结束直接退出，t1在离开作用域之前没有调用join()或detach()，导致程序异常退出。代码比较简单，就不展示了。</p><p>另外一点需要注意的是使用std::thread默认构造函数创建的对象是unjoinable的，也就是说使用如下代码创建的线程对象不能调用join()或detach()，否则程序会抛出异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::thread t1;</span><br></pre></td></tr></table></figure><p>在上面的例子中我们已经使用print_once和print_per_second函数名作为参数传递给std::thread的构造函数创建出了线程对象，使用函数名作为参数会默认传递函数的指针。一开始我们已经说过，std::thread的构造函数可以接受所有可调用对象作为参数，所以作为重载了函数调用运算符的类的实例自然也可以作为参数传递给std::thread以构造线程对象，具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Task task;</span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(task)</span></span>;</span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们也可以使用匿名对象作为参数，不过这种情况需要注意，使用下面的写法是不行的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(Task())</span></span>;</span><br></pre></td></tr></table></figure><p>这种写法会让编译器认为这是一个函数声明，该函数的参数为一个没有参数且返回Task类型队形的函数指针，函数返回一个std::thread类型的对象。为了让编译器认为这是线程实例的初始化而不是一个函数声明，可以使用下面两种写法中的一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">((Task()))</span></span>;</span><br><span class="line">std::thread t1&#123;<span class="built_in">Task</span>()&#125;;</span><br></pre></td></tr></table></figure><p>第一种写法是在外面多加一个括号，阻止将改行代码解释为函数声明；第二种写法是利用统一初始化语法完成实例的创建。</p><p>C++11新增了对lambda表达式的支持，编译器在解释lambda表达式时，会将其翻译成一个匿名类的匿名对象，该匿名类中含所有一个重载的函数调用运算符，所以lambda表达式也可以作为参数传递给线程的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">([]()&#123;cout&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;endl;&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>C++11新增了一个function模板，可以用来存储任何可调用对象，相应的，具体的function类型也是可调用对象，也可以作为线程构造函数的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">void</span>()&gt; func = print_once;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br></pre></td></tr></table></figure><p>函数模板bind也返回一个可调用对象，也可以作为线程构造函数的参数，代码就不写了，有兴趣的可以自行了解。</p><p>参考书目：《Effective.Modern.C++》、《C++Concurrency in Action 2nd Edition》、《C++标准库第二版》、《Primer C++ 第五版》</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（七）：视频播放</title>
      <link href="/2022/12/04/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/"/>
      <url>/2022/12/04/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<p>在分析读线程的时候我们已经知道ffplay音频流的播放是通过SDL音频播放回调函数获取数据写入设备从而达到播放目的的，另外SDL音频的播放大部分情况下是在单独的线程中完成的。与之相对的，音频流和字幕流的播放则在主线程中完成。ffplay在event_loop()函数中完成画面显示和事件处理的工作。</p><p>event_loop函数只有一个无限for循环，按照功能可以划分为两部分：1.SDL事件处理；2.视频流和字幕流显示。本章我们先介绍视频流和字幕流的显示。event_loop函数的for循环每次都调用一个叫做refresh_loop_wait_event函数，函数代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">refresh_loop_wait_event</span><span class="params">(VideoState *is, SDL_Event *event)</span> &#123;</span><br><span class="line">  <span class="type">double</span> remaining_time = <span class="number">0.0</span>;<span class="comment">//当前帧剩余的显示时间</span></span><br><span class="line">  SDL_PumpEvents();</span><br><span class="line">  <span class="keyword">while</span> (!SDL_PeepEvents(event, <span class="number">1</span>, SDL_GETEVENT, SDL_FIRSTEVENT, SDL_LASTEVENT)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cursor_hidden &amp;&amp; av_gettime_relative() - cursor_last_shown &gt; CURSOR_HIDE_DELAY) &#123;</span><br><span class="line">      SDL_ShowCursor(<span class="number">0</span>);</span><br><span class="line">      cursor_hidden = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (remaining_time &gt; <span class="number">0.0</span>)</span><br><span class="line">      av_usleep((<span class="type">int64_t</span>)(remaining_time * <span class="number">1000000.0</span>));<span class="comment">//当前帧剩余显示时间结束再开始下一帧的显示</span></span><br><span class="line">    remaining_time = REFRESH_RATE;<span class="comment">//初始值为0.01秒</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;show_mode != SHOW_MODE_NONE &amp;&amp; (!is-&gt;paused || is-&gt;force_refresh))</span><br><span class="line">      video_refresh(is, &amp;remaining_time);</span><br><span class="line">    SDL_PumpEvents();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了便于理解我们先简单介绍一下SDL的事件框架原理，SDL库维护一个事件队列，当有新的事件如键盘输入或鼠标事件等到达时，通过调用SDL_PumpEvents()函数可以将这些事件收集起来放入事件队列。当用户想要处理事件时，可以调用SDL_PeepEvents()并设置SDL_GETEVENT标志位从事件队列中获取事件，该函数的返回值为获取到的事件数。SDL还有通过SDL_PollEvent()函数获取事件的方式，不在本文的讨论范围。</p><p>了解了SDL事件原理，我们再来分析代码就很容易理解了，while循环不断从事件队列中读取事件，一旦读取到事件，循环就会退出，接着函数返回到event_loop，进行接下来对具体sdl事件的处理。如果当前事件队列中没有事件，就调用video_refresh()显示一帧画面，该函数的第二个参数是一个double类型变量的指针，这是一个in-out类型的参数，变量的值用来存储当前帧剩余的显示时间。video_refresh函数的主要功能可以分为两步，针对音频的图形化显示以及针对视频和字幕的显示，两者最后都是调用video_display()函数。对音频流的处理比较简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!display_disable &amp;&amp; is-&gt;show_mode != SHOW_MODE_VIDEO &amp;&amp; is-&gt;audio_st) &#123;</span><br><span class="line">    time = av_gettime_relative() / <span class="number">1000000.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;force_refresh || is-&gt;last_vis_time + rdftspeed &lt; time) &#123;</span><br><span class="line">      video_display(is);</span><br><span class="line">      is-&gt;last_vis_time = time;</span><br><span class="line">    &#125;</span><br><span class="line">    *remaining_time = FFMIN(*remaining_time, is-&gt;last_vis_time + rdftspeed - time);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>视频流的处理则较为复杂，涉及到帧的重复和跳帧操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is-&gt;video_st) &#123;</span><br><span class="line">   retry:</span><br><span class="line">   <span class="keyword">if</span> (frame_queue_nb_remaining(&amp;is-&gt;pictq) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// nothing to do, no picture to display in the queue</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="type">double</span> last_duration, duration, delay;</span><br><span class="line">     Frame *vp, *lastvp;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* dequeue the picture */</span></span><br><span class="line">     lastvp = frame_queue_peek_last(&amp;is-&gt;pictq);<span class="comment">//获取上一帧</span></span><br><span class="line">     vp = frame_queue_peek(&amp;is-&gt;pictq);<span class="comment">//获取当前帧</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (vp-&gt;serial != is-&gt;videoq.serial) &#123;<span class="comment">//如果当前视频帧内容跟视频队列中最新的内容不连续，舍弃当前帧重新读</span></span><br><span class="line">       frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">       <span class="keyword">goto</span> retry;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (lastvp-&gt;serial != vp-&gt;serial)<span class="comment">//如果上一帧跟当前帧不是连续内容，将帧计时器调整为当前时间，表示重新开始计时</span></span><br><span class="line">       is-&gt;frame_timer = av_gettime_relative() / <span class="number">1000000.0</span>;<span class="comment">//帧计时器，用于一段连续的帧数据，每当开始一段新的帧数据时，设置为当前时间点。</span></span><br><span class="line">     <span class="keyword">if</span> (is-&gt;paused)</span><br><span class="line">       <span class="keyword">goto</span> display;<span class="comment">//display显示的其实是&quot;上一帧数据&quot;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/* compute nominal last_duration */</span></span><br><span class="line">     last_duration = vp_duration(is, lastvp, vp);<span class="comment">//通过pts计算上一帧的持续时间</span></span><br><span class="line">     delay = compute_target_delay(last_duration, is);<span class="comment">//根据上一帧的显示时长计算一个延时，这个时间是上一帧真正的显示时间</span></span><br><span class="line"></span><br><span class="line">     time= av_gettime_relative()/<span class="number">1000000.0</span>;<span class="comment">//当前系统时间</span></span><br><span class="line">     <span class="keyword">if</span> (time &lt; is-&gt;frame_timer + delay) &#123;<span class="comment">//还在上一帧的显示时间段，显示上一帧</span></span><br><span class="line">       *remaining_time = FFMIN(is-&gt;frame_timer + delay - time, *remaining_time);</span><br><span class="line">       <span class="keyword">goto</span> display;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     is-&gt;frame_timer += delay;<span class="comment">//上述条件未满足，先将timer设置为上一帧结束的时间，这个值现在表示的是当前帧的显示时间</span></span><br><span class="line">     <span class="keyword">if</span> (delay &gt; <span class="number">0</span> &amp;&amp; time - is-&gt;frame_timer &gt; AV_SYNC_THRESHOLD_MAX)<span class="comment">//如果跟当前时间差超过时间同步最大阈值，将时间点设置为当前时间</span></span><br><span class="line">       is-&gt;frame_timer = time;<span class="comment">//如果不执行这一步，结果就是连续好多帧的结束时间都会小于当前时间点，如果设置可以丢帧，就会导致连续丢好多帧，造成视频的不连续，比如暂停一段时间后再恢复播放，这个值就需要更新</span></span><br><span class="line"></span><br><span class="line">     SDL_LockMutex(is-&gt;pictq.mutex);</span><br><span class="line">     <span class="keyword">if</span> (!isnan(vp-&gt;pts))<span class="comment">//使用当前帧的数据更新视频流时钟</span></span><br><span class="line">       update_video_pts(is, vp-&gt;pts, vp-&gt;pos, vp-&gt;serial);</span><br><span class="line">     SDL_UnlockMutex(is-&gt;pictq.mutex);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (frame_queue_nb_remaining(&amp;is-&gt;pictq) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">       Frame *nextvp = frame_queue_peek_next(&amp;is-&gt;pictq);</span><br><span class="line">       duration = vp_duration(is, vp, nextvp);<span class="comment">//当前帧的显示时长</span></span><br><span class="line">       <span class="keyword">if</span>(!is-&gt;step &amp;&amp; (framedrop&gt;<span class="number">0</span> || (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &amp;&amp; time &gt; is-&gt;frame_timer + duration)&#123;</span><br><span class="line">         is-&gt;frame_drops_late++;<span class="comment">//如果当前时间点晚于当前帧结束的时间点，就丢弃一帧，按照现实逻辑，其实丢弃的是上一帧</span></span><br><span class="line">         frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">         <span class="keyword">goto</span> retry;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (is-&gt;subtitle_st) &#123;<span class="comment">//如果当前时间点已经超过了字幕帧数据的结束时间点，清除字幕画面</span></span><br><span class="line">       <span class="keyword">while</span> (frame_queue_nb_remaining(&amp;is-&gt;subpq) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         sp = frame_queue_peek(&amp;is-&gt;subpq);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (frame_queue_nb_remaining(&amp;is-&gt;subpq) &gt; <span class="number">1</span>)</span><br><span class="line">           sp2 = frame_queue_peek_next(&amp;is-&gt;subpq);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           sp2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (sp-&gt;serial != is-&gt;subtitleq.serial</span><br><span class="line">             || (is-&gt;vidclk.pts &gt; (sp-&gt;pts + ((<span class="type">float</span>) sp-&gt;sub.end_display_time / <span class="number">1000</span>)))</span><br><span class="line">             || (sp2 &amp;&amp; is-&gt;vidclk.pts &gt; (sp2-&gt;pts + ((<span class="type">float</span>) sp2-&gt;sub.start_display_time / <span class="number">1000</span>))))</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="keyword">if</span> (sp-&gt;uploaded) &#123;</span><br><span class="line">             <span class="type">int</span> i;</span><br><span class="line">             <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sp-&gt;sub.num_rects; i++) &#123;</span><br><span class="line">               AVSubtitleRect *sub_rect = sp-&gt;sub.rects[i];</span><br><span class="line">               <span class="type">uint8_t</span> *pixels;</span><br><span class="line">               <span class="type">int</span> pitch, j;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!SDL_LockTexture(is-&gt;sub_texture, (SDL_Rect *)sub_rect, (<span class="type">void</span> **)&amp;pixels, &amp;pitch)) &#123;</span><br><span class="line">                 <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; sub_rect-&gt;h; j++, pixels += pitch)</span><br><span class="line">                   <span class="built_in">memset</span>(pixels, <span class="number">0</span>, sub_rect-&gt;w &lt;&lt; <span class="number">2</span>);</span><br><span class="line">                 SDL_UnlockTexture(is-&gt;sub_texture);</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           frame_queue_next(&amp;is-&gt;subpq);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">     is-&gt;force_refresh = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (is-&gt;step &amp;&amp; !is-&gt;paused)</span><br><span class="line">       stream_toggle_pause(is);</span><br><span class="line">   &#125;</span><br><span class="line">   display:</span><br><span class="line">   <span class="comment">/* display picture */</span></span><br><span class="line">   <span class="keyword">if</span> (!display_disable &amp;&amp; is-&gt;force_refresh &amp;&amp; is-&gt;show_mode == SHOW_MODE_VIDEO &amp;&amp; is-&gt;pictq.rindex_shown)</span><br><span class="line">     video_display(is);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码中有一个关键函数computer_target_delay()用于计算一帧画面实际的显示时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">double</span> <span class="title function_">compute_target_delay</span><span class="params">(<span class="type">double</span> delay, VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> sync_threshold, diff = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* update delay to follow master synchronisation source */</span></span><br><span class="line">  <span class="keyword">if</span> (get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER) &#123;</span><br><span class="line">    <span class="comment">/* if video is slave, we try to correct big delays by</span></span><br><span class="line"><span class="comment">       duplicating or deleting a frame */</span></span><br><span class="line">    <span class="comment">//如果不是音频同步视频，通过复制帧或者丢帧来修正延时</span></span><br><span class="line">    diff = get_clock(&amp;is-&gt;vidclk) - get_master_clock(is);<span class="comment">//视频流是时钟和主时钟的差值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* skip or repeat frame. We take into account the</span></span><br><span class="line"><span class="comment">       delay to compute the threshold. I still don&#x27;t know</span></span><br><span class="line"><span class="comment">       if it is the best guess */</span></span><br><span class="line">    sync_threshold = FFMAX(AV_SYNC_THRESHOLD_MIN, FFMIN(AV_SYNC_THRESHOLD_MAX, delay));<span class="comment">//算一个时间差阈值，如果delay在最大和最小阈值范围内，取delay，过大了，去最大阈值，过小了取最小阈值</span></span><br><span class="line">    <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; is-&gt;max_frame_duration) &#123;</span><br><span class="line">      <span class="keyword">if</span> (diff &lt;= -sync_threshold)<span class="comment">//视频流慢太多了，delay需要减小，最小为0，这样下一帧能更快显示（跳帧）</span></span><br><span class="line">        delay = FFMAX(<span class="number">0</span>, delay + diff);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold &amp;&amp; delay &gt; AV_SYNC_FRAMEDUP_THRESHOLD)<span class="comment">//（重复帧）</span></span><br><span class="line">        delay = delay + diff;<span class="comment">//视频流快太多了，并且延时超过了复制一帧的最大阈值。这个阈值的意思是，如果上一帧的持续时间超过了这个值，就不应该通过重复帧来进行同步</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold)</span><br><span class="line">        delay = <span class="number">2</span> * delay;<span class="comment">//视频流快太多，并且延迟没超过复制一帧的最大阈值，就将延迟增加一倍。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  av_log(<span class="literal">NULL</span>, AV_LOG_TRACE, <span class="string">&quot;video: delay=%0.3f A-V=%f\n&quot;</span>,</span><br><span class="line">         delay, -diff);</span><br><span class="line">  <span class="keyword">return</span> delay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里计算实际延时的算法中已经涉及到了音视频同步，函数中对于当前帧延时的重新计算是在视频同步音频或音视频同步外部时钟的前提下生效的。delay的值直接影响后续的丢帧操作。</p><p>音视频流画面的实际显示工作通过调用video_display函数完成，函数最终通过调用video_audio_display和video_image_display完成显示工作。video_image_display函数完成视频以及字幕的显示，使用SDL库函数完成画面的渲染，其中也涉及到了ffmpeg图像格式到sdl支持的图像格式的转换，sdl库的使用不在本文的讨论范围，这里就不展开分析了。video_audio_display函数负责音频流波形图和频域图的显示，算法暂时没看懂，对理解ffplay原理帮助也不大，后面有时间再回头分析。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（六）：解码线程</title>
      <link href="/2022/12/02/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E8%A7%A3%E7%A0%81%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/12/02/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E8%A7%A3%E7%A0%81%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>ffplay的音频流、视频流和字幕流的解码工作通过三个解码线程完成，解码线程通过decoder_start函数开启，分别调用audio_thread,video_thread,subtitle_thread三个函数，接下来我们逐个分析。</p><p>作为参考，先放上Decoder结构体中各个字段的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Decoder</span> &#123;</span></span><br><span class="line">  AVPacket *pkt;<span class="comment">//用于存储压缩数据</span></span><br><span class="line">  PacketQueue *<span class="built_in">queue</span>;<span class="comment">//关联的包队列</span></span><br><span class="line">  AVCodecContext *avctx;<span class="comment">//解码器上下文</span></span><br><span class="line">  <span class="type">int</span> pkt_serial;<span class="comment">//包的序列号</span></span><br><span class="line">  <span class="type">int</span> finished;<span class="comment">//当解码到流末尾时，这个值被设置为包序列号</span></span><br><span class="line">  <span class="type">int</span> packet_pending;<span class="comment">//当前解码器中有未决的包</span></span><br><span class="line">  SDL_cond *empty_queue_cond;<span class="comment">//读写同步的条件变量，等于VideoState中的continue_read_thread</span></span><br><span class="line">  <span class="type">int64_t</span> start_pts;<span class="comment">//流开始的时间</span></span><br><span class="line">  AVRational start_pts_tb;<span class="comment">//流的time_base</span></span><br><span class="line">  <span class="type">int64_t</span> next_pts;<span class="comment">//通过当前帧的pts和duration计算出的下一帧的pts，作为备份</span></span><br><span class="line">  AVRational next_pts_tb;<span class="comment">//下一帧的time_base，使用的是当前帧的time_base</span></span><br><span class="line">  SDL_Thread *decoder_tid;<span class="comment">//解码线程id</span></span><br><span class="line">&#125; Decoder;</span><br></pre></td></tr></table></figure><p>有四个相关的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">decoder_init</span><span class="params">(Decoder *d, AVCodecContext *avctx, PacketQueue *<span class="built_in">queue</span>, SDL_cond *empty_queue_cond)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">decoder_abort</span><span class="params">(Decoder *d, FrameQueue *fq)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">decoder_destory</span><span class="params">(Decoder *d)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">decoder_decode_frame</span><span class="params">(Decoder *d, AVFrame *frame, AVSubtitle *sub)</span>;</span><br></pre></td></tr></table></figure><p>前三个函数比较简单，不再展开分析，最后一个函数稍后会重点分析。</p><p>首先是音频解码函数audio_thread，去除滤镜处理的相关代码，函数代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">audio_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  VideoState *is = arg;</span><br><span class="line">  AVFrame *frame = av_frame_alloc();</span><br><span class="line">  Frame *af;</span><br><span class="line">  <span class="type">int</span> got_frame = <span class="number">0</span>;</span><br><span class="line">  AVRational tb;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!frame)</span><br><span class="line">    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((got_frame = decoder_decode_frame(&amp;is-&gt;auddec, frame, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> the_end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (got_frame) &#123;</span><br><span class="line">      tb = (AVRational)&#123;<span class="number">1</span>, frame-&gt;sample_rate&#125;;</span><br><span class="line">       <span class="keyword">if</span> (!(af = frame_queue_peek_writable(&amp;is-&gt;sampq)))</span><br><span class="line">          <span class="keyword">goto</span> the_end;</span><br><span class="line"></span><br><span class="line">        af-&gt;pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);</span><br><span class="line">        af-&gt;pos = frame-&gt;pkt_pos;</span><br><span class="line">        af-&gt;serial = is-&gt;auddec.pkt_serial;</span><br><span class="line">        af-&gt;duration = av_q2d((AVRational)&#123;frame-&gt;nb_samples, frame-&gt;sample_rate&#125;);</span><br><span class="line"></span><br><span class="line">        av_frame_move_ref(af-&gt;frame, frame);</span><br><span class="line">        frame_queue_push(&amp;is-&gt;sampq);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (ret &gt;= <span class="number">0</span> || ret == AVERROR(EAGAIN) || ret == AVERROR_EOF);</span><br><span class="line">  the_end:</span><br><span class="line">  av_frame_free(&amp;frame);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑十分直观，在一个do-while循环中调用decocer_decode_frame()活的解码后的数据，存入一个AVFrame中，然后从FrameQueue中获取一个指向可写位置的指针af，将AVFrame中的数据写入af对应的字段，最后调用frame_queue_push移动FrameQueue的写指针。由于我们屏蔽掉了滤镜相关的函数，所以while的循环条件看起来有点奇怪，不过效果是一样的，在没有配置滤镜功能时就是一个简单的无线循环。</p><p>我们再来看一下视频解码线程video_thread，精简掉滤镜相关的代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">video_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  VideoState *is = arg;</span><br><span class="line">  AVFrame *frame = av_frame_alloc();</span><br><span class="line">  <span class="type">double</span> pts;</span><br><span class="line">  <span class="type">double</span> duration;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  AVRational tb = is-&gt;video_st-&gt;time_base;</span><br><span class="line">  AVRational frame_rate = av_guess_frame_rate(is-&gt;ic, is-&gt;video_st, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (!frame)</span><br><span class="line">    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    ret = get_video_frame(is, frame);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> the_end;</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      duration = (frame_rate.num &amp;&amp; frame_rate.den ? av_q2d((AVRational)&#123;frame_rate.den, frame_rate.num&#125;) : <span class="number">0</span>);</span><br><span class="line">      pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);</span><br><span class="line">      ret = queue_picture(is, frame, pts, duration, frame-&gt;pkt_pos, is-&gt;viddec.pkt_serial);</span><br><span class="line">      av_frame_unref(frame);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> the_end;</span><br><span class="line">  &#125;</span><br><span class="line">  the_end:</span><br><span class="line">  av_frame_free(&amp;frame);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与音频不同，视频解码线程的处理函数将解码视频帧和将视频帧放入队列这两个步骤封装在了get_video_frame和</p><p>queue_picture两个函数中。我们先来看get_video_fream的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_video_frame</span><span class="params">(VideoState *is, AVFrame *frame)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> got_picture;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((got_picture = decoder_decode_frame(&amp;is-&gt;viddec, frame, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (got_picture) &#123;</span><br><span class="line">    <span class="type">double</span> dpts = NAN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE)</span><br><span class="line">      dpts = av_q2d(is-&gt;video_st-&gt;time_base) * frame-&gt;pts;</span><br><span class="line"></span><br><span class="line">    frame-&gt;sample_aspect_ratio = av_guess_sample_aspect_ratio(is-&gt;ic, is-&gt;video_st, frame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (framedrop&gt;<span class="number">0</span> || (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">        <span class="type">double</span> diff = dpts - get_master_clock(is);</span><br><span class="line">        <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD &amp;&amp;</span><br><span class="line">            diff - is-&gt;frame_last_filter_delay &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            is-&gt;viddec.pkt_serial == is-&gt;vidclk.serial &amp;&amp;</span><br><span class="line">            is-&gt;videoq.nb_packets) &#123;</span><br><span class="line">          is-&gt;frame_drops_early++;</span><br><span class="line">          av_frame_unref(frame);</span><br><span class="line">          got_picture = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> got_picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到获取到解码后的帧数据后，video_thread还额外加入了一个丢帧逻辑。framedrop如果用户不设置，那么默认值就是-1，用户设置后会有0和1两种情况。所以上面的条件的意思是当用户设置可以丢帧或者用户没设置这个参数但是当前的同步逻辑不是音频同步视频，就可以丢帧。ffplay的时间同步逻辑有三个选项：视频同步音频（AV_SYNC_AUDIO_MASTER），音频同步视频（AV_SYNC_VIDEO_MASTER），音视频同步外部时钟（AV_SYNC_EXTERNAL_CLOCK）。那么当程序允许丢帧时，什么时候才可以丢弃当前帧呢？程序首先计算了当前帧的显示时间点和主时钟的时间差diff，如果这个时间差还在可同步范围内，也就是小于AV_NOSYNC_THRESHOLD才进行接下来的判断。接下来判断diff是否小于上一帧的延时，frame_last_filter_delay，上一帧如果经过滤镜处理，会消耗额外的时间，这个时间计算出来被存入frame_last_filter_delay，如果diff小于这个值，说明当延时时间结束后，当前帧的显示时间点就已经过了，此时判断如果包序列号与时钟序列号是否相同，这里是为了保证在内容连续时才可丢帧；最后判断视频流包队列中如果还有包，则表示后续还有可显示的内容，那么当前帧就可以丢弃。所有条件满足后，丢帧数加一，释放当前帧的数据，将got_picture设置为0返回。这里是在解码成功放入FrameQueue之前丢帧的，所以对frame_drops_early增加一个计数，后面我们还会看到显示画面时的丢帧，那种情况是对frame_drops_late增加计数。</p><p>queue_picture函数的作用就是将数据放入FrameQueue，这里就不上代码了，单独抽离成一个函数可能只是因为需要设置的参数比较多，为了代码好看一点吧：）。</p><p>字幕流的解码线程subtitle_thread的实现更加简单，就是在一个无限循环中读取帧，然后将数据放入FrameQueue的合适位置；</p><p>到现在为止，还有有一个关键的函数我们还没有展开分析，就是decoder_decode_frame，这个函数用于从PacketQueue中读取包然后解码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">decoder_decode_frame</span><span class="params">(Decoder *d, AVFrame *frame, AVSubtitle *sub)</span> &#123;</span><br><span class="line">  <span class="type">int</span> ret = AVERROR(EAGAIN);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">//音视频流解码</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//从PacketQueue中读包</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//字幕流解码</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中有一个无限循环，循环中的代码按照任务划分可以分为三部分：1.音视频流解码；2.从PacketQueue中读包；3.字幕流解码。</p><p>音视频流的解码和字幕流的解码没有放在一起，是因为字幕流的解码方式与音视频流不同。我们先看音视频流的解码流程:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//音视频流解码</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;serial == d-&gt;pkt_serial) &#123;<span class="comment">//当前包的序列号与解码器中注册的包队列序列号一致时（内容连续）才进行解码</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;abort_request)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (d-&gt;avctx-&gt;codec_type) &#123;</span><br><span class="line">          <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">            ret = avcodec_receive_frame(d-&gt;avctx, frame);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (decoder_reorder_pts == <span class="number">-1</span>) &#123;<span class="comment">//解码器对pts重新排序，0表示关，1表示开，-1表示自动</span></span><br><span class="line">                frame-&gt;pts = frame-&gt;best_effort_timestamp;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!decoder_reorder_pts) &#123;</span><br><span class="line">                frame-&gt;pts = frame-&gt;pkt_dts;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">            ret = avcodec_receive_frame(d-&gt;avctx, frame);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              AVRational tb = (AVRational)&#123;<span class="number">1</span>, frame-&gt;sample_rate&#125;;<span class="comment">//计算音频流的time_base</span></span><br><span class="line">              <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE)</span><br><span class="line">                frame-&gt;pts = av_rescale_q(frame-&gt;pts, d-&gt;avctx-&gt;pkt_timebase, tb);</span><br><span class="line">              <span class="comment">//转换time_base,按照播放时time_base重新计算pts</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (d-&gt;next_pts != AV_NOPTS_VALUE)</span><br><span class="line">                frame-&gt;pts = av_rescale_q(d-&gt;next_pts, d-&gt;next_pts_tb, tb);</span><br><span class="line">              <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">                d-&gt;next_pts = frame-&gt;pts + frame-&gt;nb_samples;</span><br><span class="line">                d-&gt;next_pts_tb = tb;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret == AVERROR_EOF) &#123;</span><br><span class="line">          d-&gt;finished = d-&gt;pkt_serial;</span><br><span class="line">          avcodec_flush_buffers(d-&gt;avctx);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">while</span> (ret != AVERROR(EAGAIN));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ffmpeg的解码库用于音视频解码的函数是avcodec_send_packet()和avcodec_receive_frame(),前者用户向解码器发送一个AVPacket数据用于解码，后者从解码器中读取解码后生成的AVFrame数据。了解了音视频流解码的原理后，我们再结合注释看代码，就很好理解了，音视频流解码成功后都对帧的pts进行了设置。音频流的pts设置比较有意思，转换了一个时基，相当于时间单位，算出一个新的pts。在pts设置成功后，会计算下一帧的pts：next_pts，这个值用于当解析到的frame中不含pts时充当备份，每一帧对应的next_pts都是在解析上一帧的时候计算出来的。</p><p>剩下的代码是用来判断是否在此处退出函数的。第一种情况是已经解析到流末尾了，将当前包序列号赋值给finished然后清空解码器缓存。第二种情况是ret&gt;&#x3D;0，当成功解析一帧数据时，ret值会被设置等于0。</p><p>接下来分析第二部分读取包的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">do</span> &#123;<span class="comment">//从PacketQueue中读取新的包</span></span><br><span class="line">  <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;nb_packets == <span class="number">0</span>)</span><br><span class="line">    SDL_CondSignal(d-&gt;empty_queue_cond);<span class="comment">//如果包队列空了，通知等待的读线程可以继续读了</span></span><br><span class="line">  <span class="keyword">if</span> (d-&gt;packet_pending) &#123;<span class="comment">//有未决的包，所以本次循环不用再读新的包了</span></span><br><span class="line">    d-&gt;packet_pending = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> old_serial = d-&gt;pkt_serial;</span><br><span class="line">    <span class="keyword">if</span> (packet_queue_get(d-&gt;<span class="built_in">queue</span>, d-&gt;pkt, <span class="number">1</span>, &amp;d-&gt;pkt_serial) &lt; <span class="number">0</span>)<span class="comment">//从队列中读一个包</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (old_serial != d-&gt;pkt_serial) &#123;<span class="comment">//新读到的包跟之前解析的包不是连续的内容？</span></span><br><span class="line">      avcodec_flush_buffers(d-&gt;avctx);<span class="comment">//刷新解码器缓存</span></span><br><span class="line">      d-&gt;finished = <span class="number">0</span>;<span class="comment">//解码还没结束</span></span><br><span class="line">      d-&gt;next_pts = d-&gt;start_pts;<span class="comment">//更新用于备份的next_pts和next_pts_tb</span></span><br><span class="line">      d-&gt;next_pts_tb = d-&gt;start_pts_tb;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;serial == d-&gt;pkt_serial)<span class="comment">//再校验一次内容的连续性</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  av_packet_unref(d-&gt;pkt);<span class="comment">//如果读到的包序列号与解码器关联的队列序列号不一致，丢弃包内容，下个循环继续读</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>最后分析字幕流解码代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (d-&gt;avctx-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) &#123;<span class="comment">//字幕流解码</span></span><br><span class="line">      <span class="type">int</span> got_frame = <span class="number">0</span>;</span><br><span class="line">      ret = avcodec_decode_subtitle2(d-&gt;avctx, sub, &amp;got_frame, d-&gt;pkt);<span class="comment">//解析字幕流AVPacket</span></span><br><span class="line">      <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = AVERROR(EAGAIN);<span class="comment">//读取失败，下次循环重读</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (got_frame &amp;&amp; !d-&gt;pkt-&gt;data) &#123;</span><br><span class="line">          d-&gt;packet_pending = <span class="number">1</span>;<span class="comment">//拿到数据了，data空了，为了防止有未读出的数据，下次循环还用这个空包去刷新解码器，直到got_frame==0</span></span><br><span class="line">        &#125;</span><br><span class="line">        ret = got_frame ? <span class="number">0</span> : (d-&gt;pkt-&gt;data ? AVERROR(EAGAIN) : AVERROR_EOF);<span class="comment">//拿到数据，ret=0，下次循环函数就返回；如果没拿到数据，但是包的data不为空，下次循环不退出，重新读；//如果又没拿到数据，data也空了，说明到达流末尾了</span></span><br><span class="line">      &#125;</span><br><span class="line">      av_packet_unref(d-&gt;pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是其他流，就将AVPacket发送给解码器</span></span><br><span class="line">      <span class="keyword">if</span> (avcodec_send_packet(d-&gt;avctx, d-&gt;pkt) == AVERROR(EAGAIN)) &#123;</span><br><span class="line">        av_log(d-&gt;avctx, AV_LOG_ERROR, <span class="string">&quot;Receive_frame and send_packet both returned EAGAIN, which is an API violation.\n&quot;</span>);</span><br><span class="line">        d-&gt;packet_pending = <span class="number">1</span>;<span class="comment">//解码器里的数据还未被读出，下次循环不用再发送新包了</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        av_packet_unref(d-&gt;pkt);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>字幕流的解析通过avcodec_decode_subtitle2()函数完成，如果成功解析到数据，数据会被存放到第二个参数sub，第三个参数got_frame会被设置为非零值。某些解码器并不能实时输出所有解码后的数据，此时需要不停发送一个pkt-&gt;data为NULL的包去刷新。</p><p>由于音视频解码器和字幕解码器都可能存在解码器中的数据未读取完暂时不能接受新的AVPacket的情况，所以需要通过packet_pending这个标志位告诉程序下次循环用不用给解码器发送新的AVPacket。</p><p>到此decoder_decode_frame全部分析完毕，解码线程的所有逻辑也分析结束。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（五）：读线程</title>
      <link href="/2022/12/01/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%AF%BB%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/12/01/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%AF%BB%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>在分析main函数的时候我们已经提到过stream_open函数，本章我们开始对其进行分析。stream_open函数的源码结构一目了然，主要做了如下几件事：</p><p>1.创建一个VideoState结构体指针变量is，为其分配内存并以0初始化；</p><p>2.为创建好的结构体变量的成员赋初值，stream_open函数接受两个参数，第一个参数是文件名，第二个参数是用户指定的文件格式，也在这一步赋给相应的结构体成员；</p><p>3.初始化结构体变量中对应视频流，音频流，字幕流的三个FrameQueue，其中视频流和音频流的keep_last值被设置为1，这个值的具体作用我们上一章已经介绍过；</p><p>4.初始化结构体变量中对应视频流，音频流，字幕流的三个PacketQueue；</p><p>5.创建continue_read_thread这个用于读写同步的条件变量；</p><p>6.初始化三个流对应的clock时钟结构体；</p><p>7.设置音量；</p><p>8.打开read_thread线程。</p><p>可以看到stream_open函数主要做的事情就是创建并初始化VideoState结构体变量，初始化完成后打开read_thread线程，然后函数就退出了。从代码中看除了调用相应的函数初始化FrameQueue和PacketQueue以外，函数初始化了三个时钟结构体，分别对应三个流。ffplay为每个流分配了一个Clock结构体类型的变量，其中包含了时间，偏移量，时钟速度等等一些成员，所有成员类型都是double或int。时钟的作用在后面我们分析到音视频同步的时候会详细介绍，现在只需要知道stream_open函数中完成了三个流对应时钟的初始化即可。</p><p>接下来我们看一下read_thread主要做了哪些事。根据任务类型我们可以将read_thread的代码氛围三部分：打开文件，打开流，主循环读流。</p><p>首先我们看一下打开文件部分的代码，我精简掉了一些变量声明，错误检查，打印信息的代码，只保留了重要部分以方便阅读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> st_index[AVMEDIA_TYPE_NB];<span class="comment">//存储各个类型的流对应的序号</span></span><br><span class="line"> <span class="built_in">memset</span>(st_index, <span class="number">-1</span>, <span class="keyword">sizeof</span>(st_index));</span><br><span class="line"> pkt = av_packet_alloc();<span class="comment">//创建一个默认初始化的AVPacket</span></span><br><span class="line"> ic = avformat_alloc_context();<span class="comment">//创建一个默认初始化的AVFormatContext</span></span><br><span class="line"> ic-&gt;interrupt_callback.callback = decode_interrupt_cb;<span class="comment">//中断回调函数，当ffmpeg的io库在执行阻塞操作时，这个函数会被间歇性的调用，当函数的返回值为1时，io库会终止阻塞操作</span></span><br><span class="line"> ic-&gt;interrupt_callback.opaque = is;</span><br><span class="line"> <span class="keyword">if</span> (!av_dict_get(format_opts, <span class="string">&quot;scan_all_pmts&quot;</span>, <span class="literal">NULL</span>, AV_DICT_MATCH_CASE)) &#123;<span class="comment">//设置mpegts的scan_all_pmts选项，该选项的含义是扫描并组合所有ts流的Program Map Table</span></span><br><span class="line">   av_dict_set(&amp;format_opts, <span class="string">&quot;scan_all_pmts&quot;</span>, <span class="string">&quot;1&quot;</span>, AV_DICT_DONT_OVERWRITE);<span class="comment">//所以这里是针对mpegts封装单独设置的选项</span></span><br><span class="line">   scan_all_pmts_set = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> err = avformat_open_input(&amp;ic, is-&gt;filename, is-&gt;iformat, &amp;format_opts);<span class="comment">//打开文件，传入AVFormatContext变量，文件名和格式，以及保存选项信息的字典format_opts,文件打开后，format_opts会被擦除并且写入未被发现的选项</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (scan_all_pmts_set)</span><br><span class="line">   av_dict_set(&amp;format_opts, <span class="string">&quot;scan_all_pmts&quot;</span>, <span class="literal">NULL</span>, AV_DICT_MATCH_CASE);<span class="comment">//打开文件后将scan_all_pmts选项重置</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> ((t = av_dict_get(format_opts, <span class="string">&quot;&quot;</span>, <span class="literal">NULL</span>, AV_DICT_IGNORE_SUFFIX))) &#123;<span class="comment">//如果t不为NULL，说明打开文件时设置的选项中有不被支持的选项</span></span><br><span class="line">   av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Option %s not found.\n&quot;</span>, t-&gt;key);</span><br><span class="line">   ret = AVERROR_OPTION_NOT_FOUND;</span><br><span class="line">   <span class="keyword">goto</span> fail;</span><br><span class="line"> &#125;</span><br><span class="line"> is-&gt;ic = ic;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (genpts)</span><br><span class="line">   ic-&gt;flags |= AVFMT_FLAG_GENPTS;</span><br><span class="line"></span><br><span class="line"> av_format_inject_global_side_data(ic);<span class="comment">//将全局的side data注入到每个流的下一个AVPacket中</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (find_stream_info) &#123;<span class="comment">//校验用户指定的codec选项是否支持</span></span><br><span class="line">   AVDictionary **opts = setup_find_stream_info_opts(ic, codec_opts);</span><br><span class="line">   <span class="type">int</span> orig_nb_streams = ic-&gt;nb_streams;</span><br><span class="line"></span><br><span class="line">   err = avformat_find_stream_info(ic, opts);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; orig_nb_streams; i++)</span><br><span class="line">     av_dict_free(&amp;opts[i]);</span><br><span class="line">   av_freep(&amp;opts);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     av_log(<span class="literal">NULL</span>, AV_LOG_WARNING,</span><br><span class="line">            <span class="string">&quot;%s: could not find codec parameters\n&quot;</span>, is-&gt;filename);</span><br><span class="line">     ret = <span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">goto</span> fail;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (ic-&gt;pb)</span><br><span class="line">   ic-&gt;pb-&gt;eof_reached = <span class="number">0</span>; <span class="comment">// FIXME hack, ffplay maybe should not use avio_feof() to test for the end</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (seek_by_bytes &lt; <span class="number">0</span>)<span class="comment">//当封装格式允许时间戳不连续且不是ogg格式时，以byte查找，否则以时间查找</span></span><br><span class="line">   seek_by_bytes = !!(ic-&gt;iformat-&gt;flags &amp; AVFMT_TS_DISCONT) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;ogg&quot;</span>, ic-&gt;iformat-&gt;name);</span><br><span class="line"></span><br><span class="line"> is-&gt;max_frame_duration = (ic-&gt;iformat-&gt;flags &amp; AVFMT_TS_DISCONT) ? <span class="number">10.0</span> : <span class="number">3600.0</span>;<span class="comment">//每一帧最长时序时间，如果封装格式允许时间戳不连续时，为10秒，否则为3600秒。</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!window_title &amp;&amp; (t = av_dict_get(ic-&gt;metadata, <span class="string">&quot;title&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>)))</span><br><span class="line">   window_title = av_asprintf(<span class="string">&quot;%s - %s&quot;</span>, t-&gt;value, input_filename);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* if seeking requested, we execute it */</span></span><br><span class="line"> <span class="keyword">if</span> (start_time != AV_NOPTS_VALUE) &#123;</span><br><span class="line">   <span class="type">int64_t</span> timestamp;</span><br><span class="line"></span><br><span class="line">   timestamp = start_time;</span><br><span class="line">   <span class="comment">/* add the stream start time */</span></span><br><span class="line">   <span class="keyword">if</span> (ic-&gt;start_time != AV_NOPTS_VALUE)</span><br><span class="line">     timestamp += ic-&gt;start_time;</span><br><span class="line">   ret = avformat_seek_file(ic, <span class="number">-1</span>, INT64_MIN, timestamp, INT64_MAX, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;%s: could not seek to position %0.3f\n&quot;</span>,</span><br><span class="line">            is-&gt;filename, (<span class="type">double</span>)timestamp / AV_TIME_BASE);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> is-&gt;realtime = is_realtime(ic);<span class="comment">//是否是实时流</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (show_status)</span><br><span class="line">   av_dump_format(ic, <span class="number">0</span>, is-&gt;filename, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;<span class="comment">//判断用户指定的流是否可用，如果可用将流的序号设置到数组st_index相应的成员中</span></span><br><span class="line">   AVStream *st = ic-&gt;streams[i];</span><br><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">AVMediaType</span> <span class="title">type</span> =</span> st-&gt;codecpar-&gt;codec_type;</span><br><span class="line">   st-&gt;discard = AVDISCARD_ALL;</span><br><span class="line">   <span class="keyword">if</span> (type &gt;= <span class="number">0</span> &amp;&amp; wanted_stream_spec[type] &amp;&amp; st_index[type] == <span class="number">-1</span>)</span><br><span class="line">     <span class="keyword">if</span> (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) &gt; <span class="number">0</span>)</span><br><span class="line">       st_index[type] = i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; AVMEDIA_TYPE_NB; i++) &#123;</span><br><span class="line">   <span class="keyword">if</span> (wanted_stream_spec[i] &amp;&amp; st_index[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">     av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Stream specifier %s does not match any %s stream\n&quot;</span>, wanted_stream_spec[i], av_get_media_type_string(i));</span><br><span class="line">     st_index[i] = INT_MAX;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//结合用户指定的流查找出最好的流最为最终解析的流</span></span><br><span class="line"> <span class="keyword">if</span> (!video_disable)</span><br><span class="line">   st_index[AVMEDIA_TYPE_VIDEO] =</span><br><span class="line">       av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,</span><br><span class="line">                           st_index[AVMEDIA_TYPE_VIDEO], <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (!audio_disable)</span><br><span class="line">   st_index[AVMEDIA_TYPE_AUDIO] =</span><br><span class="line">       av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,</span><br><span class="line">                           st_index[AVMEDIA_TYPE_AUDIO],</span><br><span class="line">                           st_index[AVMEDIA_TYPE_VIDEO],</span><br><span class="line">                           <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (!video_disable &amp;&amp; !subtitle_disable)</span><br><span class="line">   st_index[AVMEDIA_TYPE_SUBTITLE] =</span><br><span class="line">       av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,</span><br><span class="line">                           st_index[AVMEDIA_TYPE_SUBTITLE],</span><br><span class="line">                           (st_index[AVMEDIA_TYPE_AUDIO] &gt;= <span class="number">0</span> ?</span><br><span class="line">                            st_index[AVMEDIA_TYPE_AUDIO] :</span><br><span class="line">                            st_index[AVMEDIA_TYPE_VIDEO]),</span><br><span class="line">                           <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> is-&gt;show_mode = show_mode;</span><br><span class="line"> <span class="keyword">if</span> (st_index[AVMEDIA_TYPE_VIDEO] &gt;= <span class="number">0</span>) &#123;<span class="comment">//从视频流中获取画面宽高，依次设置默认窗口大小</span></span><br><span class="line">   AVStream *st = ic-&gt;streams[st_index[AVMEDIA_TYPE_VIDEO]];</span><br><span class="line">   AVCodecParameters *codecpar = st-&gt;codecpar;</span><br><span class="line">   AVRational sar = av_guess_sample_aspect_ratio(ic, st, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">if</span> (codecpar-&gt;width)</span><br><span class="line">     set_default_window_size(codecpar-&gt;width, codecpar-&gt;height, sar);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注释已经说明了大部分代码的用途，这部分代码做的事主要是打开文件，获取流信息，结合用户指定的流说明符选取最优的流用于接下来的步骤。打开文件和获取流信息都是通过ffmpeg库函数实现的，没有复杂的逻辑，结合相关函数的注释很好理解。占用篇幅最大也是最不好理解的部分就是选取最优的流的相关操作。</p><p>首先定义了一个的数组:int st_index[AVMEDIA_TYPE_NB],这里涉及到一个枚举类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AVMediaType</span> &#123;</span></span><br><span class="line">    AVMEDIA_TYPE_UNKNOWN = <span class="number">-1</span>,  <span class="comment">///&lt; Usually treated as AVMEDIA_TYPE_DATA</span></span><br><span class="line">    AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    AVMEDIA_TYPE_AUDIO,</span><br><span class="line">    AVMEDIA_TYPE_DATA,          <span class="comment">///&lt; Opaque data information usually continuous</span></span><br><span class="line">    AVMEDIA_TYPE_SUBTITLE,</span><br><span class="line">    AVMEDIA_TYPE_ATTACHMENT,    <span class="comment">///&lt; Opaque data information usually sparse</span></span><br><span class="line">    AVMEDIA_TYPE_NB</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用媒体类型作为数组索引，数组元素为int，数组元素是如何被赋值的呢？看下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;<span class="comment">//判断用户指定的流是否可用，如果可用将流的序号设置到数组st_index相应的成员中</span></span><br><span class="line">  AVStream *st = ic-&gt;streams[i];</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">AVMediaType</span> <span class="title">type</span> =</span> st-&gt;codecpar-&gt;codec_type;</span><br><span class="line">  st-&gt;discard = AVDISCARD_ALL;</span><br><span class="line">  <span class="keyword">if</span> (type &gt;= <span class="number">0</span> &amp;&amp; wanted_stream_spec[type] &amp;&amp; st_index[type] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) &gt; <span class="number">0</span>)</span><br><span class="line">      st_index[type] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; AVMEDIA_TYPE_NB; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (wanted_stream_spec[i] &amp;&amp; st_index[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Stream specifier %s does not match any %s stream\n&quot;</span>, wanted_stream_spec[i], av_get_media_type_string(i));</span><br><span class="line">    st_index[i] = INT_MAX;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中有一个特殊的数组wanted_stream_spec[],从数组的定义上我们会发现，这个数组的大小也是AVMEDIA_TYPE_NB，数组元素类型是const char*。这个数组中存储的是用户指定的流说明符，如wanted_stream_spec[AVMEDIA_TYPE_AUDIO]的值为”1“表示用户指定使用第二个音频流，wanted_stream_spec[AVMEDIA_TYPE_VIDEO]的值为”2“表示用户指定使用第三个视频流等。使用avformat_match_stream_specifier函数进行匹配，如果程序解析出的流与用户指定的流匹配，那么就将st_index[type]设置为这个流的序号，例如通过-vst 1指定第二个视频流，而文件解析出的第二个视频流对应的序号i为3，那么st_index[AVMEDIA_TYPE_VIDEO]的值就会被设置为3，如果没有匹配到，比如文件中只有一个视频流的时候，相应的值就不会被设置。还有一个逻辑就是st_index[type]一旦被设置过就不会再对同类型的流进行比对了。</p><p>接下来会将wanted_stream_spec和st_index进行比对，如果相同索引位置前者有值，而后者的值还是默认值-1，则表示用户指定的流没有被匹配到，随后后者的值会被设置为INT_MAX。</p><p>通过以上步骤，有可能某一类型的流未被指定，例如上面说到的，用户使用-vst 1指定第二个视频流，但是文件中却只含有一个视频流，这种情况下st_index[AVMEDIA_TYPE_VIDEO]会被设置为INT_MAX。所以就需要将合适的流序号赋给他，ffplay使用的方式是调用av_find_best_stream函数来找到最佳匹配，它会根据传入的参数选择一个最接近用户期望的流。</p><p>至此，st_index[]中已经保存了最优的流的序号，接下来就是打开这些流开始读取数据了。打开流的代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (st_index[AVMEDIA_TYPE_AUDIO] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ret = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (st_index[AVMEDIA_TYPE_VIDEO] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (is-&gt;show_mode == SHOW_MODE_NONE)</span><br><span class="line">    is-&gt;show_mode = ret &gt;= <span class="number">0</span> ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (st_index[AVMEDIA_TYPE_SUBTITLE] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>stream_component_open函数的返回值0表示成功，负数表示打开失败，在打开视频流的时候对返回值进行了一下判断，并且设置相应的显示模式。除此之外，所有流的打开都是通过stream_component_open函数完成的。我们接下来分析stream_component_open函数都做了什么工作。</p><p>首先stream_component_open根据传进来的流序号从AVFormatContext中获取到对应的信息，并用这些信息结合用户指定的参数完成了解码器的创建。关键代码注释如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">avctx = avcodec_alloc_context3(<span class="literal">NULL</span>);<span class="comment">//以默认值创建一个AVCodecContext</span></span><br><span class="line">...</span><br><span class="line"> ret = avcodec_parameters_to_context(avctx, ic-&gt;streams[stream_index]-&gt;codecpar);<span class="comment">//将AVFormatContext中读取到的codec相关的参数复制给AVCodecContext对应的成员</span></span><br><span class="line"> ...</span><br><span class="line"> codec = avcodec_find_decoder(avctx-&gt;codec_id);<span class="comment">//根据codec_id查找解码器，codec_id是通过之前的avcodec_parameters_to_context函数从流的codecpar中获取到的</span></span><br><span class="line">...  </span><br><span class="line"> <span class="keyword">if</span> (forced_codec_name)<span class="comment">//如果用户指定了解码器名称，根据名称搜索解码器</span></span><br><span class="line">   codec = avcodec_find_decoder_by_name(forced_codec_name);</span><br><span class="line">...</span><br><span class="line"> avctx-&gt;codec_id = codec-&gt;id;<span class="comment">//更新最终获取到的解码器id</span></span><br><span class="line">...</span><br><span class="line"> <span class="keyword">if</span> ((ret = avcodec_open2(avctx, codec, &amp;opts)) &lt; <span class="number">0</span>) &#123;<span class="comment">//设置好解码器选项后打开解码器</span></span><br><span class="line">   <span class="keyword">goto</span> fail;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打开解码器后针对不同的流类型做不同的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (avctx-&gt;codec_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">      sample_rate    = avctx-&gt;sample_rate;</span><br><span class="line">        nb_channels    = avctx-&gt;channels;</span><br><span class="line">        channel_layout = avctx-&gt;channel_layout;</span><br><span class="line">      <span class="comment">/* prepare audio output */</span></span><br><span class="line">      <span class="keyword">if</span> ((ret = audio_open(is, channel_layout, nb_channels, sample_rate, &amp;is-&gt;audio_tgt)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">      is-&gt;audio_hw_buf_size = ret;</span><br><span class="line">      is-&gt;audio_src = is-&gt;audio_tgt;</span><br><span class="line">      is-&gt;audio_buf_size  = <span class="number">0</span>;</span><br><span class="line">      is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* init averaging filter */</span></span><br><span class="line">      is-&gt;audio_diff_avg_coef  = <span class="built_in">exp</span>(<span class="built_in">log</span>(<span class="number">0.01</span>) / AUDIO_DIFF_AVG_NB);</span><br><span class="line">      is-&gt;audio_diff_avg_count = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">/* since we do not have a precise anough audio FIFO fullness,</span></span><br><span class="line"><span class="comment">         we correct audio sync only if larger than this threshold */</span></span><br><span class="line">      is-&gt;audio_diff_threshold = (<span class="type">double</span>)(is-&gt;audio_hw_buf_size) / is-&gt;audio_tgt.bytes_per_sec;</span><br><span class="line"></span><br><span class="line">      is-&gt;audio_stream = stream_index;</span><br><span class="line">      is-&gt;audio_st = ic-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_init(&amp;is-&gt;auddec, avctx, &amp;is-&gt;audioq, is-&gt;continue_read_thread)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">      <span class="keyword">if</span> ((is-&gt;ic-&gt;iformat-&gt;flags &amp; (AVFMT_NOBINSEARCH | AVFMT_NOGENSEARCH | AVFMT_NO_BYTE_SEEK)) &amp;&amp; !is-&gt;ic-&gt;iformat-&gt;read_seek) &#123;</span><br><span class="line">        is-&gt;auddec.start_pts = is-&gt;audio_st-&gt;start_time;</span><br><span class="line">        is-&gt;auddec.start_pts_tb = is-&gt;audio_st-&gt;time_base;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_start(&amp;is-&gt;auddec, audio_thread, <span class="string">&quot;audio_decoder&quot;</span>, is)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      SDL_PauseAudioDevice(audio_dev, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">      is-&gt;video_stream = stream_index;</span><br><span class="line">      is-&gt;video_st = ic-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_init(&amp;is-&gt;viddec, avctx, &amp;is-&gt;videoq, is-&gt;continue_read_thread)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_start(&amp;is-&gt;viddec, video_thread, <span class="string">&quot;video_decoder&quot;</span>, is)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      is-&gt;queue_attachments_req = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_SUBTITLE:</span><br><span class="line">      is-&gt;subtitle_stream = stream_index;</span><br><span class="line">      is-&gt;subtitle_st = ic-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_init(&amp;is-&gt;subdec, avctx, &amp;is-&gt;subtitleq, is-&gt;continue_read_thread)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_start(&amp;is-&gt;subdec, subtitle_thread, <span class="string">&quot;subtitle_decoder&quot;</span>, is)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里我删除了音频滤镜的代码，因为滤镜只是改变了相关参数的值，在分析代码逻辑的时候暂时注释掉这部分代码比较不容易混淆。</p><p>从代码中我们很容易发现视频流和字幕流的处理逻辑是完全一致的，都是初始化一个Decoder然后开启解码线程，音频则要复杂的多，所以我们先从视频流和字幕流的处理开始分析，最后再分析音频流的处理。</p><p>我们暂时不需要关心Decoder的工作原理，只需要知道decoder_init函数用于初始化一个Decoder结构体变量，而Decoder是对AVCodecContext的封装，加入了一些其他参数。而decoder_start所做的工作就是开启流对应的PacketQueue，表示已经可以向队列中写入数据了。然后开启对应的解码线程，如视频流是video_thread，字幕流是subtitle_thread。各个流对应的解码线程执行的具体工作我们会在后面的章节中详细分析。</p><p>接着是音频流的处理，从代码中我们可以发现，音频流的处理与视频流和字幕流最大的不同是在执行decoder_init之前，先是调用了一个名为audio_open的函数，然后设置了VideoState中很多相应的音频参数。我们先来看audio_open函数做了什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">audio_open</span><span class="params">(<span class="type">void</span> *opaque, <span class="type">int64_t</span> wanted_channel_layout, <span class="type">int</span> wanted_nb_channels, <span class="type">int</span> wanted_sample_rate, <span class="keyword">struct</span> AudioParams *audio_hw_params)</span></span><br><span class="line">&#123;</span><br><span class="line">  SDL_AudioSpec wanted_spec, spec;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *env;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> next_nb_channels[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> next_sample_rates[] = &#123;<span class="number">0</span>, <span class="number">44100</span>, <span class="number">48000</span>, <span class="number">96000</span>, <span class="number">192000</span>&#125;;</span><br><span class="line">  <span class="type">int</span> next_sample_rate_idx = FF_ARRAY_ELEMS(next_sample_rates) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  env = SDL_getenv(<span class="string">&quot;SDL_AUDIO_CHANNELS&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (env) &#123;</span><br><span class="line">    wanted_nb_channels = atoi(env);</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!wanted_channel_layout || wanted_nb_channels != av_get_channel_layout_nb_channels(wanted_channel_layout)) &#123;</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);</span><br><span class="line">    wanted_channel_layout &amp;= ~AV_CH_LAYOUT_STEREO_DOWNMIX;</span><br><span class="line">  &#125;</span><br><span class="line">  wanted_nb_channels = av_get_channel_layout_nb_channels(wanted_channel_layout);</span><br><span class="line">  wanted_spec.channels = wanted_nb_channels;</span><br><span class="line">  wanted_spec.freq = wanted_sample_rate;</span><br><span class="line">  <span class="keyword">if</span> (wanted_spec.freq &lt;= <span class="number">0</span> || wanted_spec.channels &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Invalid sample rate or channel count!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (next_sample_rate_idx &amp;&amp; next_sample_rates[next_sample_rate_idx] &gt;= wanted_spec.freq)</span><br><span class="line">    next_sample_rate_idx--;</span><br><span class="line">  wanted_spec.format = AUDIO_S16SYS;</span><br><span class="line">  wanted_spec.silence = <span class="number">0</span>;</span><br><span class="line">  wanted_spec.samples = FFMAX(SDL_AUDIO_MIN_BUFFER_SIZE, <span class="number">2</span> &lt;&lt; av_log2(wanted_spec.freq / SDL_AUDIO_MAX_CALLBACKS_PER_SEC));</span><br><span class="line">  wanted_spec.callback = sdl_audio_callback;</span><br><span class="line">  wanted_spec.userdata = opaque;</span><br><span class="line">  <span class="keyword">while</span> (!(audio_dev = SDL_OpenAudioDevice(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;wanted_spec, &amp;spec, SDL_AUDIO_ALLOW_FREQUENCY_CHANGE | SDL_AUDIO_ALLOW_CHANNELS_CHANGE))) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;SDL_OpenAudio (%d channels, %d Hz): %s\n&quot;</span>,</span><br><span class="line">           wanted_spec.channels, wanted_spec.freq, SDL_GetError());</span><br><span class="line">    wanted_spec.channels = next_nb_channels[FFMIN(<span class="number">7</span>, wanted_spec.channels)];</span><br><span class="line">    <span class="keyword">if</span> (!wanted_spec.channels) &#123;</span><br><span class="line">      wanted_spec.freq = next_sample_rates[next_sample_rate_idx--];</span><br><span class="line">      wanted_spec.channels = wanted_nb_channels;</span><br><span class="line">      <span class="keyword">if</span> (!wanted_spec.freq) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">&quot;No more combinations to try, audio open failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(wanted_spec.channels);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (spec.format != AUDIO_S16SYS) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">           <span class="string">&quot;SDL advised audio format %d is not supported!\n&quot;</span>, spec.format);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (spec.channels != wanted_spec.channels) &#123;</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(spec.channels);</span><br><span class="line">    <span class="keyword">if</span> (!wanted_channel_layout) &#123;</span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">             <span class="string">&quot;SDL advised channel count %d is not supported!\n&quot;</span>, spec.channels);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  audio_hw_params-&gt;fmt = AV_SAMPLE_FMT_S16;</span><br><span class="line">  audio_hw_params-&gt;freq = spec.freq;</span><br><span class="line">  audio_hw_params-&gt;channel_layout = wanted_channel_layout;</span><br><span class="line">  audio_hw_params-&gt;channels =  spec.channels;</span><br><span class="line">  audio_hw_params-&gt;frame_size = av_samples_get_buffer_size(<span class="literal">NULL</span>, audio_hw_params-&gt;channels, <span class="number">1</span>, audio_hw_params-&gt;fmt, <span class="number">1</span>);</span><br><span class="line">  audio_hw_params-&gt;bytes_per_sec = av_samples_get_buffer_size(<span class="literal">NULL</span>, audio_hw_params-&gt;channels, audio_hw_params-&gt;freq, audio_hw_params-&gt;fmt, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (audio_hw_params-&gt;bytes_per_sec &lt;= <span class="number">0</span> || audio_hw_params-&gt;frame_size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;av_samples_get_buffer_size failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> spec.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先从入参开始看，channel_layout, nb_channels, sample_rate都是从解码器对应的AVCodecContext中获取的，分别代表音频的通道布局，通道数和采样率，&amp;is-&gt;audio_tgt是一个AudioParams结构体变量的地址，该变量用于存储硬件支持的音频参数。</p><p>函数一开始先对传入的通道布局和通道数进行匹配，结合环境变量计算出合适的通道布局和通道数，然后根据传入的采样率算出一个不大于它的符合标准的采样率。</p><p>接下来使用SDL库函数SDL_OpenAudioDevice()打开音频设备。这里简单说一下这个函数的原理，函数的第一个参数类型为const char*，用来指定设备ID，这里设置为NULL,表示自动选择，第二个函数类型为int，为0时表示打开设备用于播放，非零时表示打开设备用于录音，第三个参数类型是 const SDL_AudioSpec*，存储用户指定的音频参数，第四个参数类型是SDL_AudioSpec*，存储函数执行成功后实际设置的音频参数，最后一个参数是标志位，用于指定那些参数可以被修改，这里我们设置的是允许修改频率和通道数。该函数返回0表示失败，大于0表示成功并且返回值为音频设备id。如果打开设备不成功，函数会修改通道数和采样率并尝试重新打开设备，当经过计算后的采样率为0时，函数返回-1。打开设备成功后，相应的音频参数会被赋给audio_tgt相应的字段，然后函数返回音频缓冲区的大小值。还有一个我们不能忽视的函数，作为第三个参数SDL_AudioSpec中callback成员传入的sdl_audio_callback函数。sdl音频输出的工作原理是这样的，当成功打开音频设备时，音频输出是暂停的，需要手动调用SDL_PauseAudioDevice()函数让音频设备开始工作，当音频设备开始工作的时候会间歇的调用SDL_AudioSpec中的callback函数来”拉取“音频数据写入音频设备，所以callback函数的作用就是提供音频数据。我们看一下ffplay的sdl_audio_callback函数是怎么写的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sdl_audio_callback</span><span class="params">(<span class="type">void</span> *opaque, Uint8 *stream, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  VideoState *is = opaque;</span><br><span class="line">  <span class="type">int</span> audio_size, len1;</span><br><span class="line"></span><br><span class="line">  audio_callback_time = av_gettime_relative();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;<span class="comment">//如果程序当前缓冲区中没有数据，就解析一帧数据</span></span><br><span class="line">      audio_size = audio_decode_frame(is);</span><br><span class="line">      <span class="keyword">if</span> (audio_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* if error, just output silence */</span></span><br><span class="line">        is-&gt;audio_buf = <span class="literal">NULL</span>;</span><br><span class="line">        is-&gt;audio_buf_size = SDL_AUDIO_MIN_BUFFER_SIZE / is-&gt;audio_tgt.frame_size * is-&gt;audio_tgt.frame_size;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;show_mode != SHOW_MODE_VIDEO)<span class="comment">//如果当前的显示模式不是视频模式，将音频数据进行图形化显示</span></span><br><span class="line">          update_sample_display(is, (<span class="type">int16_t</span> *)is-&gt;audio_buf, audio_size);</span><br><span class="line">        is-&gt;audio_buf_size = audio_size;</span><br><span class="line">      &#125;</span><br><span class="line">      is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<span class="comment">//计算写入数据的长度</span></span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len)</span><br><span class="line">      len1 = len;</span><br><span class="line">    <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf &amp;&amp; is-&gt;audio_volume == SDL_MIX_MAXVOLUME)<span class="comment">//当不静音且audio_buf有效时才输出数据，如果音量为SDL_MIX_MAXVOLUME，直接输出数据</span></span><br><span class="line">      <span class="built_in">memcpy</span>(stream, (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">memset</span>(stream, <span class="number">0</span>, len1);</span><br><span class="line">      <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf)<span class="comment">//否则混合音频数据以AUDIO_S16SYS格式输出</span></span><br><span class="line">        SDL_MixAudioFormat(stream, (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, AUDIO_S16SYS, len1, is-&gt;audio_volume);</span><br><span class="line">    &#125;</span><br><span class="line">    len -= len1;</span><br><span class="line">    stream += len1;</span><br><span class="line">    is-&gt;audio_buf_index += len1;</span><br><span class="line">  &#125;</span><br><span class="line">  is-&gt;audio_write_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">  <span class="comment">/* Let&#x27;s assume the audio driver that is used by SDL has two periods. */</span></span><br><span class="line">  <span class="keyword">if</span> (!isnan(is-&gt;audio_clock)) &#123;<span class="comment">//更新时钟</span></span><br><span class="line">    set_clock_at(&amp;is-&gt;audclk, is-&gt;audio_clock - (<span class="type">double</span>)(<span class="number">2</span> * is-&gt;audio_hw_buf_size + is-&gt;audio_write_buf_size) / is-&gt;audio_tgt.bytes_per_sec, is-&gt;audio_clock_serial, audio_callback_time / <span class="number">1000000.0</span>);</span><br><span class="line">    sync_clock_to_slave(&amp;is-&gt;extclk, &amp;is-&gt;audclk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>callback的函数签名是统一的，opaque是用户数据，本程序中我们设置的是VideoState，stream表示音频数据缓冲区，len表示缓冲区大小。从代码中我们可以看到由于sdl音频这种通过回调函数”拉取“数据的方式，程序需要在callback中提供音频数据，所以音频数据从FrameQueue中的读取从此时就开始了，这一点跟视频流和字幕流都不一样，后两者是在主循环中需要显示画面的时候才从FrameQueue中读取的，而且是在主线程中操作。</p><p>还有一个关键函数audio_decode_frame(),作用是从FrameQueue中读取一帧数据然后解析成音频数据。因为其中涉及到音视频同步，所以我准备在后面分析音视频同步的时候详细分析这部分代码，目前就只需要知道这个函数的功能就可以了。</p><p>audio_open分析完了，我们再来看音频流处理剩下的代码，之前我们提到过，SDL打开音频设备后，设备默认是暂停的，需要手动取消暂停设备才会开始通过callback函数获取数据播放音频。这样做的目的是为了打开音频设备后让程序有时间做一些数据的初始化工作的。接下来的代码就是做一些播放前的准备操作，包括一些参数的赋值或初始化以及开启音频解码线程。在做完这些操作后，调用SDL_PauseAudioDevice(audio_dev, 0)解除音频设备的静音状态，其中audio_dev是SDL_OpenAudioDevice函数的返回值。</p><p>stream_component_open函数到此就分析完了，read_thread剩下的代码是一个无限循环，主要工作就是使用av_read_frame()从流读取包再放入PacketQueue。我们看一下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*针对网络流的开启或关闭操作*/</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;seek_req) &#123;<span class="comment">//seek到指定位置，此操作会刷新PacketQueue，导致serial+1，并且如果是暂停状态下seek，seek完成后会更新一帧画面</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;queue_attachments_req) &#123;<span class="comment">//如果视频流保存的是附加数据，如专辑封面等，读取数据后放入队列，然后放入空包以此告诉解码器已经到达当前流结尾</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果队列已满，暂时不要读取更多数据，等待最长10ms，就开始下一个循环 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*播放完后判断是直接退出还是循环播放*/</span></span><br><span class="line">    ... </span><br><span class="line">    ret = av_read_frame(ic, pkt);<span class="comment">//读取一个AVPacket</span></span><br><span class="line">  <span class="comment">/*如果读取失败，判断是到达了文件结尾还是io错误，如果到达了文件结尾，就往队列里放空包并设置标志位</span></span><br><span class="line"><span class="comment">  如果是io错误，则选择退出程序或结束线程，否则就等待最长10ms，继续下一次循环*/</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 判断数据是否在用户指定的播放时间范围内，如果不在就丢弃 */</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;audio_stream &amp;&amp; pkt_in_play_range) &#123;</span><br><span class="line">      packet_queue_put(&amp;is-&gt;audioq, pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;video_stream &amp;&amp; pkt_in_play_range</span><br><span class="line">        &amp;&amp; !(is-&gt;video_st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC)) &#123;</span><br><span class="line">      packet_queue_put(&amp;is-&gt;videoq, pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;subtitle_stream &amp;&amp; pkt_in_play_range) &#123;</span><br><span class="line">      packet_queue_put(&amp;is-&gt;subtitleq, pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      av_packet_unref(pkt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码经过精简，精简掉的代码功能已经通过注释写明，这里比较难理解的是判断数据是否在播放范围的判断条件，我们详细分析一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stream_start_time = ic-&gt;streams[pkt-&gt;stream_index]-&gt;start_time;</span><br><span class="line">    pkt_ts = pkt-&gt;pts == AV_NOPTS_VALUE ? pkt-&gt;dts : pkt-&gt;pts;</span><br><span class="line">    pkt_in_play_range = duration == AV_NOPTS_VALUE ||</span><br><span class="line">        (pkt_ts - (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : <span class="number">0</span>)) *</span><br><span class="line">            av_q2d(ic-&gt;streams[pkt-&gt;stream_index]-&gt;time_base) -</span><br><span class="line">            (<span class="type">double</span>)(start_time != AV_NOPTS_VALUE ? start_time : <span class="number">0</span>) / <span class="number">1000000</span></span><br><span class="line">            &lt;= ((<span class="type">double</span>)duration / <span class="number">1000000</span>);</span><br></pre></td></tr></table></figure><p>首先获取stream的开始时间stream_start_time，然后拿到该数据包的展示时间pkt_ts，如果pts不存在，就用解码时间dts代替。判断是否在播放范围是一个或操作，第一个条件很好理解，duration未定义时，一律认定在播放范围。第二个条件我们分开看，首先是展示时间pkt_ts减去流开始时间stream_start_time，这样我们可以认为我们获得了以stream_start_time为零点的一个时间点，我们用这个值减去start_time（start_time是用户设置的开始时间，这个时间也是一个以stream_start_time为零点的一个时间点）得到的结果是一个时间段，如果这个时间段的值小于duration，说明该数据展示的时间点早于start_time+duration得到的时间点，那么这个数据就在播放范围内，否则说明该数据展示的时间点晚于start_time+duration得到的时间点，我们并不需要播放这段数据，所以这段数据就被丢弃。那么有没有可能pkt_ts小于start_time呢？这样也能满足上述条件，但是这个数据也不在播放范围内。答案是不可能，因为这种情况发生的情况只会是发生了seek，seek操作的处理在读取数据之前已经完成，所以seek时间点之前的数据是不可能被读到的。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（四）：FrameQueue</title>
      <link href="/2022/11/30/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AFrameQueue/"/>
      <url>/2022/11/30/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AFrameQueue/</url>
      
        <content type="html"><![CDATA[<p>FrameQueue是用于保存AVFrame数据的队列，同样的为了能够增加额外的参数，AVFrame与其他额外参数被封装成一个新的结构体Frame，FrameQueue中保存的就是Frame类型的数据。Frame和FrameQueue结构体代码注释如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Frame</span> &#123;</span></span><br><span class="line">  AVFrame *frame;<span class="comment">//指向帧结构体变量的指针</span></span><br><span class="line">  AVSubtitle sub;<span class="comment">//字幕结构体变量</span></span><br><span class="line">  <span class="type">int</span> serial;<span class="comment">//序列号</span></span><br><span class="line">  <span class="type">double</span> pts;<span class="comment">//这一帧展示的时间点</span></span><br><span class="line">  <span class="type">double</span> duration;<span class="comment">//这一帧内容的持续时间</span></span><br><span class="line">  <span class="type">int64_t</span> pos;<span class="comment">//这一帧在输入文件中的位置</span></span><br><span class="line">  <span class="type">int</span> width;<span class="comment">//画面的宽度</span></span><br><span class="line">  <span class="type">int</span> height;<span class="comment">//画面的高度</span></span><br><span class="line">  <span class="type">int</span> format;<span class="comment">//格式</span></span><br><span class="line">  AVRational sar;<span class="comment">//横向像素点与纵向像素点数量的比值</span></span><br><span class="line">  <span class="type">int</span> uploaded;<span class="comment">//是否已经渲染到输出设备</span></span><br><span class="line">  <span class="type">int</span> flip_v;<span class="comment">//垂直翻转</span></span><br><span class="line">&#125; Frame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FrameQueue</span> &#123;</span></span><br><span class="line">  Frame <span class="built_in">queue</span>[FRAME_QUEUE_SIZE];<span class="comment">//保存Frame格式数据的数组</span></span><br><span class="line">  <span class="type">int</span> rindex;<span class="comment">//读指针</span></span><br><span class="line">  <span class="type">int</span> windex;<span class="comment">//写指针</span></span><br><span class="line">  <span class="type">int</span> size;<span class="comment">//未读帧数</span></span><br><span class="line">  <span class="type">int</span> max_size;<span class="comment">//队列中能保存的最大帧数</span></span><br><span class="line">  <span class="type">int</span> keep_last;<span class="comment">//是否保留上一帧</span></span><br><span class="line">  <span class="type">int</span> rindex_shown;<span class="comment">//用于标识保留帧</span></span><br><span class="line">  SDL_mutex *mutex;<span class="comment">//互斥量</span></span><br><span class="line">  SDL_cond *cond;<span class="comment">//用于读写同步的条件变量</span></span><br><span class="line">  PacketQueue *pktq;<span class="comment">//包队列指针</span></span><br><span class="line">&#125; FrameQueue;</span><br></pre></td></tr></table></figure><p>FrameQueue通过一个固定长度的数组以及两个读写指针实现了一个循环队列，当需要从队列中读取数据或向队列中写入数据时，队列会返回一个指向可读或可写位置的指针，然后调用者可以通过指针进行读写操作。</p><p>FrameQueue的操作函数有如下几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">frame_queue_unref_item</span><span class="params">(Frame *vp)</span></span><br><span class="line">&#123;</span><br><span class="line">  av_frame_unref(vp-&gt;frame);<span class="comment">//释放所有跟frame关联的buffer并重置frame中所有字段的值</span></span><br><span class="line">  avsubtitle_free(&amp;vp-&gt;sub);<span class="comment">//释放sub中分配的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数用于释放Frame结构体变量中的AVFrame和AVSubtitle成员变量关联的数据，注意只是释放关联的数据，而不是销毁结构体变量，这一步的作用是重置Frame。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">frame_queue_init</span><span class="params">(FrameQueue *f, PacketQueue *pktq, <span class="type">int</span> max_size, <span class="type">int</span> keep_last)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(FrameQueue));</span><br><span class="line">  <span class="keyword">if</span> (!(f-&gt;mutex = SDL_CreateMutex())) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;SDL_CreateMutex(): %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(f-&gt;cond = SDL_CreateCond())) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;SDL_CreateCond(): %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">  &#125;</span><br><span class="line">  f-&gt;pktq = pktq;<span class="comment">//关联PacketQueue</span></span><br><span class="line">  f-&gt;max_size = FFMIN(max_size, FRAME_QUEUE_SIZE);</span><br><span class="line">  f-&gt;keep_last = !!keep_last;<span class="comment">//keep_last的值为0或1</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; f-&gt;max_size; i++)<span class="comment">//初始化队列数据</span></span><br><span class="line">    <span class="keyword">if</span> (!(f-&gt;<span class="built_in">queue</span>[i].frame = av_frame_alloc()))</span><br><span class="line">      <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列的初始化函数，与PacketQueue一样，也是使用memset()将所有内置类型的变量初始化为0。然后创建用于线程同步的互斥量以及条件变量，关联PacketQueue，设置队列最大成员数量，keep_last通过一个小技巧将输入值转换为0或1，保证所有非零输入都被转换为1保存，最后使用av_frame_alloc()初始化所有数组成员，该函数会创建一个AVFrame并设置默认值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">frame_queue_destory</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; f-&gt;max_size; i++) &#123;</span><br><span class="line">    Frame *vp = &amp;f-&gt;<span class="built_in">queue</span>[i];</span><br><span class="line">    frame_queue_unref_item(vp);</span><br><span class="line">    av_frame_free(&amp;vp-&gt;frame);</span><br><span class="line">  &#125;</span><br><span class="line">  SDL_DestroyMutex(f-&gt;mutex);</span><br><span class="line">  SDL_DestroyCond(f-&gt;cond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销毁函数，销毁队列中所有数据，针对每个数组成员，先调用frame_queue_unref_item销毁关联数据，再调用av_frame_free销毁AVFrame本身，AVSubtitle由于分配在栈上，所以不需要手动销毁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">frame_queue_signal</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  SDL_CondSignal(f-&gt;cond);</span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送同步信号，唤醒等待条件变量的线程。</p><p>接下来是重头戏，队列的读写函数，我们先分析逻辑较为简单的写操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Frame *<span class="title function_">frame_queue_peek_writable</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* wait until we have space to put a new frame */</span></span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  <span class="keyword">while</span> (f-&gt;size &gt;= f-&gt;max_size &amp;&amp;</span><br><span class="line">      !f-&gt;pktq-&gt;abort_request) &#123;</span><br><span class="line">    SDL_CondWait(f-&gt;cond, f-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;pktq-&gt;abort_request)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;f-&gt;<span class="built_in">queue</span>[f-&gt;windex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">frame_queue_push</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (++f-&gt;windex == f-&gt;max_size)</span><br><span class="line">    f-&gt;windex = <span class="number">0</span>;</span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  f-&gt;size++;</span><br><span class="line">  SDL_CondSignal(f-&gt;cond);</span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>frame_queue_peek_writable返回写指针指向的数组成员，在返回之前函数会先检查队列是否已满，由于是循环队列，队列已满的意思就是队列中所有成员都已被写入数据切这些数据都还未被读取，如果此时未经检查直接写入新的数据，那么当前数组中最早被写入的数据就会被覆盖。检查的手段也很简单，只需要检查size是否大于或等于max_size即可。当队列中有可写空间时，返回写指针指向的数据成员。写入成功后需要将写指针向前移动一位，如果移动后的索引值超过了最大索引值，就将写指针的索引设为0，从而实现对数组的循环写入。接下来将size加1,并发送通知唤醒等待条件变量的线程，由于size值在读写线程中都会被修改，所以需要在加锁的情况下更新。</p><p>写操作的逻辑简单总结就是，找到可写位置，写入数据，更新未读节点数量，然后发送通知唤醒还在等待的线程。</p><p>相比写操作，读操作的逻辑相对复杂，主要是因为涉及到保留上一帧这一操作，我们看一下具体代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Frame *<span class="title function_">frame_queue_peek</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;f-&gt;<span class="built_in">queue</span>[(f-&gt;rindex + f-&gt;rindex_shown) % f-&gt;max_size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Frame *<span class="title function_">frame_queue_peek_next</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;f-&gt;<span class="built_in">queue</span>[(f-&gt;rindex + f-&gt;rindex_shown + <span class="number">1</span>) % f-&gt;max_size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Frame *<span class="title function_">frame_queue_peek_last</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;f-&gt;<span class="built_in">queue</span>[f-&gt;rindex];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> Frame *<span class="title function_">frame_queue_peek_readable</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* wait until we have a readable a new frame */</span></span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  <span class="keyword">while</span> (f-&gt;size - f-&gt;rindex_shown &lt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">      !f-&gt;pktq-&gt;abort_request) &#123;</span><br><span class="line">    SDL_CondWait(f-&gt;cond, f-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;pktq-&gt;abort_request)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;f-&gt;<span class="built_in">queue</span>[(f-&gt;rindex + f-&gt;rindex_shown) % f-&gt;max_size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是读取函数，三个简单的读取函数分别用来读取当前结点，读取下一个节点以及读取上一个节点，还有一个实现更复杂的读取可读节点，该函数与普通的读取当前节点的函数的不同点在于frame_queue_peek_readable是读取还未读取的节点，而frame_queue_peek则只是读取当前节点而不检查当前节点是否已经被读取过。读取未读节点需要满足两个条件：1、队列中存在未读节点；2、关联的PacketQueue没有终止。如果条件1未被满足，函数会阻塞直到被条件变量的通知唤醒；如果条件2未被满足，函数返回NULL；如果两者都被满足，则返回当前节点，使用与普通读取函数相同的操作。</p><p>我们注意到，计算当前节点索引的方式有些特别，是用rindex+rindex_shown的和对max_size取模，所以严格来说rindex并不是读指针的索引值，rindex+rindex_shown才是。那么rindex_shown又是什么值呢？我们先看下面的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">frame_queue_next</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;keep_last &amp;&amp; !f-&gt;rindex_shown) &#123;</span><br><span class="line">    f-&gt;rindex_shown = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  frame_queue_unref_item(&amp;f-&gt;<span class="built_in">queue</span>[f-&gt;rindex]);</span><br><span class="line">  <span class="keyword">if</span> (++f-&gt;rindex == f-&gt;max_size)</span><br><span class="line">    f-&gt;rindex = <span class="number">0</span>;</span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  f-&gt;size--;</span><br><span class="line">  SDL_CondSignal(f-&gt;cond);</span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与写操作写入数据成功后直接更新写指针以及size值不同，读操作在更新读指针以及size值之前需要对已读节点的数据进行释放，也就是调用frame_queue_unref_item函数。在此之前，函数先判断keep_last的值，当程序要求保留上一帧时，即keep_last的值为1时，如果rindex_shown此时的值为0，它将被设置为1。</p><p>我们再回过头去看几个读函数的操作，用rindex+rindex_shown作为真正的读指针，而更新读指针销毁数据时却使用rindex，如果rindex_shown为零也就是不需要保留上一帧时，rindex等于rindex_shown，程序执行的操作就是读完一帧然后销毁刚读完的这一帧。而当rindex_shown为1时，真正的读指针是指向rindex的下一个节点的数据，那么相对于读操作来讲，刚读完一帧数据并且移动读指针时，销毁的其实是刚读的这一帧的上一帧数据，刚读过的这一帧数据得以保留。</p><p>我们再来看一下frame_queue_peek_readable函数中判断当前队列中是否存在未读结点使用的判断条件是</p><p><code>f-&gt;size - f-&gt;rindex_shown &lt;= 0</code></p><p>我们再来带入一下两种情况，当rindex_shown等于0即不需要保留上一帧数据时，判断条件相当于size&lt;&#x3D;0，这很好理解。当rindex_shown等于1即需要保留上一帧数据是，判断条件相当于size&lt;&#x3D;1,这是因为size表示的是未读结点的数量，而当rindex_shown等于1时，上一帧的数据是已读未擦除状态，所以在这种情况下当size等于1时，剩下的这一帧数据已经被读过了。</p><p>剩下两个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">frame_queue_nb_remaining</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> f-&gt;size - f-&gt;rindex_shown;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int64_t</span> <span class="title function_">frame_queue_last_pos</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  Frame *fp = &amp;f-&gt;<span class="built_in">queue</span>[f-&gt;rindex];</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;rindex_shown &amp;&amp; fp-&gt;serial == f-&gt;pktq-&gt;serial)</span><br><span class="line">    <span class="keyword">return</span> fp-&gt;pos;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>frame_queue_nb_remaining返回队列中未被读取的值，为什么用size-rindex_shown，因为如果有保留帧，那么跟rindex同步更新的size值一定会比实际的未读取的节点数量值大1。</p><p>frame_queue_last_pos返回上一帧的位置，只有队列有保留帧的时候该函数才会返回上一帧的位置，否则返回-1。</p><p>ffplay中需要保留上一帧的流有视频流和音频流。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（三）：PacketQueue</title>
      <link href="/2022/11/29/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9APacketQueue/"/>
      <url>/2022/11/29/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9APacketQueue/</url>
      
        <content type="html"><![CDATA[<p>ffmpeg库解析音视频数据的顺序是先解封装（demuxing）再解码（decoding），其中解封装是从原始数据中分离出不同的数据流，如音频流，视频流等。解码是将从音视频流中读取的压缩数据解析成音视频输出设备可以识别的数据格式，音频如PCM，视频如YUV420P等。ffmpeg相关库的实现中，负责保存压缩数据的数据结构为struct AVPacket，负责保存解码后数据的数据结构为struct AVFrame。ffplay为存放这两种类型的数据创建了两个队列，存放AVPacket的队列就是本章介绍的PacketQueue，存放AVFrame的队列是我们下一章要介绍的FrameQueue；</p><p>先来看一下PacketQueue相关的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyAVPacketList</span> &#123;</span></span><br><span class="line">  AVPacket *pkt;<span class="comment">//压缩的包数据</span></span><br><span class="line">  <span class="type">int</span> serial;<span class="comment">//包序列号，跟所在的包序列的序列号一致</span></span><br><span class="line">&#125; MyAVPacketList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PacketQueue</span> &#123;</span></span><br><span class="line">  AVFifoBuffer *pkt_list;<span class="comment">//先进先出队列</span></span><br><span class="line">  <span class="type">int</span> nb_packets;<span class="comment">//队列中包的数量</span></span><br><span class="line">  <span class="type">int</span> size;<span class="comment">//队列大小</span></span><br><span class="line">  <span class="type">int64_t</span> duration;<span class="comment">//队列中数据的播放持续时间</span></span><br><span class="line">  <span class="type">int</span> abort_request;<span class="comment">//结束请求</span></span><br><span class="line">  <span class="type">int</span> serial;<span class="comment">//序列号，用于标识一段连续数据</span></span><br><span class="line">  SDL_mutex *mutex;<span class="comment">//线程互斥量</span></span><br><span class="line">  SDL_cond *cond;<span class="comment">//线程条件变量</span></span><br><span class="line">&#125; PacketQueue;</span><br></pre></td></tr></table></figure><p>PacketQueue结构体中各个参数的含义已经在注释中写明，PacketQueue的操作函数有以下几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_put_private</span><span class="params">(PacketQueue *q, AVPacket *pkt)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_put</span><span class="params">(PacketQueue *q, AVPacket *pkt)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_put_nullpacket</span><span class="params">(PacketQueue *q, AVPacket *pkt, <span class="type">int</span> stream_index)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_init</span><span class="params">(PacketQueue *q)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">packet_queue_flush</span><span class="params">(PacketQueue *q)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">packet_queue_destroy</span><span class="params">(PacketQueue *q)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">packet_queue_abort</span><span class="params">(PacketQueue *q)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">packet_queue_start</span><span class="params">(PacketQueue *q)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_get</span><span class="params">(PacketQueue *q, AVPacket *pkt, <span class="type">int</span> block, <span class="type">int</span> *serial)</span>;</span><br></pre></td></tr></table></figure><p>packet_queue_init用memset函数将结构体所在内存以0初始化，这样可以将结构体中int类型的值初始化为0。然后创建一个fifo队列和用于线程同步的互斥量以及条件变量，最后将abort_request设置为1表示队列当前状态不可用；</p><p>packet_queue_flush函数将队列中数据清空，serial值加1，这些操作都在上锁状态下执行，相同的serial值表明这些数据是一段连续的内容，flush操作清空并丢弃了队列中还未被读取的数据，所以通过serial加1来表示接下来的数据跟之前的数据表示的已经不是连续的内容了；</p><p>packet_queue_destory调用flush函数清空数据，然后销毁fifo队列，以及互斥量和条件变量；</p><p>packet_queue_abort在上锁状态下将abort_request设置为1，并调用SDL_ConSignal()函数通知条件变量；</p><p>packet_queue_start函数在上锁状态下将abort_request设置为0，serial加1；</p><p>packet_queue_get是唯一的读取函数接受四个参数，第一个参数q指定PacketQueue，第二个参数pkt是一个指向AVPacket的指针，用于存储从q中读出的数据，第三个参数表示是否为阻塞模式，如果为0，那么当队列中没有数据时，函数会立即返回，否则将会调用SDL_CondWait()等待直到队列中有数据。第四个参数是一个传入的int变量地址，从fifo队列中读取的MyAVPacketList类型数据包含AVPacket类型的数据和一个序列号，这个序列号会被传给第四个参数指定的int变量。</p><p>packet_queue_put_private函数负责将参数pkt指向的AVPacket类型的数据连同队列q的序列号一起包装成一个MyAVPacketList类型数据写入fifo队列，然后将nb_packets加1，size加上MyAVPacketList的大小和其指向的AVPacket的大小，duration加上AVPacket的duration。写入成功后调用SDL_CondSignal()通知条件变量。该函数是执行具体写入动作的函数，只是供packet_queue_put函数调用，所以函数中没有上锁。</p><p>packet_queue_put检查参数pkt指定的数据是否为null，不为null时才在上锁状态下调用packet_queue_put_private执行真正的写入。</p><p>packet_queue_put_nullpacket用于向队列中写入一个没有数据的AVPecket包，设置了pkg的stream_index后直接调用packet_queue_put。该函数存在的意义是一个空包可以作为一个刷新包通知解码器已经到达流结束的位置了，解码器读到刷新包后会将缓存的帧数据返回。</p><p>分析完所有函数的功能，我们做一个简短的总结。PacketQueue中维护了一个fifo队列，队列中存储MyAVPacketList类型数据而不直接存储AVPacket类型数据的原因是需要为每个包添加一个序列号，这个序列号在包被放入队列时会被设置为队列的序列号，序列号用于标识一段连续的内容，如果两个包的序列号不同，说明他们所表示的内容时间上不连续。需要互斥量和条件变量的原因是队列的读写操作分别在不同线程，需要线程同步。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（二）：VideoState结构体</title>
      <link href="/2022/11/29/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AVideoState%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2022/11/29/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AVideoState%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p>VideoState结构体是ffplay源码里最重要也是最庞大的一个结构体，可以说是“包罗万象”，整个源码读下来给人的感觉就是只要是需要在函数间传递的参数，都会被放进这个结构体，然后相关的函数之间传VideoState的指针就好。这样做的好处是不用费力为每个函数想不同的参数名，后期增删参数时只需要修改VideoState结构体以及使用到该参数的某几行代码而不用修改所有相关函数的调用。坏处就是代码的耦合度太高了，不过对于单个源文件写完所有功能的ffplay来说，这并不算是什么大问题。</p><p>VideoState结构体的注释如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VideoState</span> &#123;</span><br><span class="line">  SDL_Thread *read_tid;<span class="comment">//读线程id</span></span><br><span class="line">  <span class="type">const</span> AVInputFormat *iformat;<span class="comment">//输入文件格式</span></span><br><span class="line">  <span class="type">int</span> abort_request;<span class="comment">//为1时，读线程退出</span></span><br><span class="line">  <span class="type">int</span> force_refresh;<span class="comment">//强制刷新标志位</span></span><br><span class="line">  <span class="type">int</span> paused;<span class="comment">//播放暂停标志位</span></span><br><span class="line">  <span class="type">int</span> last_paused;<span class="comment">//上一次设置的paused标志位</span></span><br><span class="line">  <span class="type">int</span> queue_attachments_req;<span class="comment">//请求流中的附加信息（如封面图片）的标志位</span></span><br><span class="line">  <span class="type">int</span> seek_req;<span class="comment">//查找请求</span></span><br><span class="line">  <span class="type">int</span> seek_flags;<span class="comment">//指定查找行为的标志位</span></span><br><span class="line">  <span class="type">int64_t</span> seek_pos;<span class="comment">//查找位置</span></span><br><span class="line">  <span class="type">int64_t</span> seek_rel;<span class="comment">//查找粒度</span></span><br><span class="line">  <span class="type">int</span> read_pause_return;<span class="comment">//保存av_read_pause()函数的返回值</span></span><br><span class="line">  AVFormatContext *ic;</span><br><span class="line">  <span class="type">int</span> realtime;<span class="comment">//是否是实时流</span></span><br><span class="line"></span><br><span class="line">  Clock audclk;<span class="comment">//音频流时钟</span></span><br><span class="line">  Clock vidclk;<span class="comment">//视频流时钟</span></span><br><span class="line">  Clock extclk;<span class="comment">//外部时钟</span></span><br><span class="line"></span><br><span class="line">  FrameQueue pictq;<span class="comment">//视频流的帧队列</span></span><br><span class="line">  FrameQueue subpq;<span class="comment">//字幕流的帧队列</span></span><br><span class="line">  FrameQueue sampq;<span class="comment">//音频流的帧队列</span></span><br><span class="line"></span><br><span class="line">  Decoder auddec;<span class="comment">//音频解码器</span></span><br><span class="line">  Decoder viddec;<span class="comment">//视频解码器</span></span><br><span class="line">  Decoder subdec;<span class="comment">//字幕解码器</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> audio_stream;<span class="comment">//音频流序号</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> av_sync_type;<span class="comment">//音视频同步模式</span></span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> audio_clock;<span class="comment">//音频时钟数值</span></span><br><span class="line">  <span class="type">int</span> audio_clock_serial;<span class="comment">//音频时钟序列号</span></span><br><span class="line">  <span class="type">double</span> audio_diff_cum; <span class="comment">/* used for AV difference average computation */</span></span><br><span class="line">  <span class="type">double</span> audio_diff_avg_coef;</span><br><span class="line">  <span class="type">double</span> audio_diff_threshold;</span><br><span class="line">  <span class="type">int</span> audio_diff_avg_count;<span class="comment">//以上几个值用于计算音频重采样的样本数</span></span><br><span class="line">  AVStream *audio_st;<span class="comment">//指向音频流的指针</span></span><br><span class="line">  PacketQueue audioq;<span class="comment">//音频流的包队列</span></span><br><span class="line">  <span class="type">int</span> audio_hw_buf_size;<span class="comment">//硬件支持的音频缓冲区大小</span></span><br><span class="line">  <span class="type">uint8_t</span> *audio_buf;<span class="comment">//指向储存音频数据的缓冲区</span></span><br><span class="line">  <span class="type">uint8_t</span> *audio_buf1;<span class="comment">//指向储存音频数据的缓冲区</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> audio_buf_size; <span class="comment">/* in bytes */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> audio_buf1_size;<span class="comment">//缓冲区大小</span></span><br><span class="line">  <span class="type">int</span> audio_buf_index; <span class="comment">/* 音频缓冲区读取位置 in bytes */</span></span><br><span class="line">  <span class="type">int</span> audio_write_buf_size;<span class="comment">//音频缓冲区中可写区域的大小</span></span><br><span class="line">  <span class="type">int</span> audio_volume;<span class="comment">//音量值</span></span><br><span class="line">  <span class="type">int</span> muted;<span class="comment">//是否静音</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">AudioParams</span> audio_src;<span class="comment">//音频参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_AVFILTER</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">AudioParams</span> audio_filter_src;<span class="comment">//滤镜处理后的音频参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">AudioParams</span> audio_tgt;<span class="comment">//硬件支持的音频参数</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">SwrContext</span> *swr_ctx;<span class="comment">//音频重采样上下文</span></span><br><span class="line">  <span class="type">int</span> frame_drops_early;<span class="comment">//解码过程中的丢帧数</span></span><br><span class="line">  <span class="type">int</span> frame_drops_late;<span class="comment">//渲染过程中的丢帧数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">ShowMode</span> &#123;</span><br><span class="line">    SHOW_MODE_NONE = <span class="number">-1</span>, SHOW_MODE_VIDEO = <span class="number">0</span>, SHOW_MODE_WAVES, SHOW_MODE_RDFT, SHOW_MODE_NB</span><br><span class="line">  &#125; show_mode;<span class="comment">//显示模式，分为视频模式，波形图模式以及频谱图</span></span><br><span class="line">  <span class="type">int16_t</span> sample_array[SAMPLE_ARRAY_SIZE];<span class="comment">//音频样本数组</span></span><br><span class="line">  <span class="type">int</span> sample_array_index;<span class="comment">//样本数组的读取位置</span></span><br><span class="line">  <span class="type">int</span> last_i_start;</span><br><span class="line">  RDFTContext *rdft;<span class="comment">//实时傅里叶变换上下文</span></span><br><span class="line">  <span class="type">int</span> rdft_bits;</span><br><span class="line">  FFTSample *rdft_data;</span><br><span class="line">  <span class="type">int</span> xpos;</span><br><span class="line">  <span class="type">double</span> last_vis_time;</span><br><span class="line">  SDL_Texture *vis_texture;<span class="comment">//用于渲染音频图像的纹理结构体指针</span></span><br><span class="line">  SDL_Texture *sub_texture;<span class="comment">//用于渲染字幕的纹理结构体指针</span></span><br><span class="line">  SDL_Texture *vid_texture;<span class="comment">//用于渲染视频的纹理结构体指针</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> subtitle_stream;<span class="comment">//字幕流序号</span></span><br><span class="line">  AVStream *subtitle_st;<span class="comment">//指向字幕流的指针</span></span><br><span class="line">  PacketQueue subtitleq;<span class="comment">//字幕流的包队列</span></span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> frame_timer;<span class="comment">//帧计时器</span></span><br><span class="line">  <span class="type">double</span> frame_last_returned_time;</span><br><span class="line">  <span class="type">double</span> frame_last_filter_delay;</span><br><span class="line">  <span class="type">int</span> video_stream;<span class="comment">//视频流序号</span></span><br><span class="line">  AVStream *video_st;<span class="comment">//视频流指针</span></span><br><span class="line">  PacketQueue videoq;<span class="comment">//视频流包队列</span></span><br><span class="line">  <span class="type">double</span> max_frame_duration; <span class="comment">//单个帧最大的持续时间   // maximum duration of a frame - above this, we consider the jump a timestamp discontinuity</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">SwsContext</span> *img_convert_ctx;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">SwsContext</span> *sub_convert_ctx;</span><br><span class="line">  <span class="type">int</span> eof;<span class="comment">//文件结束标志位</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *filename;<span class="comment">//文件名</span></span><br><span class="line">  <span class="type">int</span> width, height, xleft, ytop;<span class="comment">//窗口的位置和大小</span></span><br><span class="line">  <span class="type">int</span> step;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_AVFILTER</span></span><br><span class="line">  <span class="type">int</span> vfilter_idx;</span><br><span class="line">  AVFilterContext *in_video_filter;   <span class="comment">// the first filter in the video chain</span></span><br><span class="line">  AVFilterContext *out_video_filter;  <span class="comment">// the last filter in the video chain</span></span><br><span class="line">  AVFilterContext *in_audio_filter;   <span class="comment">// the first filter in the audio chain</span></span><br><span class="line">  AVFilterContext *out_audio_filter;  <span class="comment">// the last filter in the audio chain</span></span><br><span class="line">  AVFilterGraph *agraph;              <span class="comment">// audio filter graph</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> last_video_stream, last_audio_stream, last_subtitle_stream;<span class="comment">//上一次使用的流，用于循环播放</span></span><br><span class="line"></span><br><span class="line">  SDL_cond *continue_read_thread;<span class="comment">//控制读线程是否继续读的条件变量</span></span><br><span class="line">&#125; VideoState;</span><br></pre></td></tr></table></figure><p>结构体中某些参数单从注释上很难理解其具体含义，所以在之后的源码分析中我们会反复回来看这个结构体的内容。</p><p>在分析具体代码逻辑之前，我们需要知道ffplay中用到的两个队列的用法：PacketQueue，FrameQueue。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（一）：main函数</title>
      <link href="/2022/11/27/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Amain%E5%87%BD%E6%95%B0/"/>
      <url>/2022/11/27/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Amain%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>ffplay源码的main函数逻辑较为简单，根据任务划分主要做了如下几件事：</p><p>1、解析参数</p><p>2、初始化相关库</p><p>3、创建SDL窗口及其对应的渲染器</p><p>4、打开流</p><p>5、开启主循环</p><p>其中解析参数这一步调用的函数是根据ffmpeg的参数规则专门编写的，具体实现在cmdutils.c中。这部分实现是ffmpeg，ffplay和ffplay三个项目共用的。当我们单独分析ffplay源码时，我们不需要知道具体的实现细节，只需要知道这一步是修改ffplay.c源文件开头定义的用于表示用户行为的静态变量就可以了，具体的变量可以在后面分析源码的时候遇到了再回头看对应的参数。</p><p>用户可以定义的静态变量有以下这些：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">static const AVInputFormat *file_iformat;//对应-f参数指定的文件格式，默认是自动判断不需要手动指定</span><br><span class="line">static const char *input_filename;//输入文件名</span><br><span class="line">static const char *window_title;//主窗口标题</span><br><span class="line">static int default_width  = 640;//主窗口默认宽度</span><br><span class="line">static int default_height = 480;//主窗口默认高度</span><br><span class="line">static int screen_width  = 0;</span><br><span class="line">static int screen_height = 0;//屏幕默认宽高，没有对应参数</span><br><span class="line">static int screen_left = SDL_WINDOWPOS_CENTERED;//设置窗口左方的的x坐标，默认居中，对应参数-left</span><br><span class="line">static int screen_top = SDL_WINDOWPOS_CENTERED;//设置窗口上方的y坐标，默认居中，对应参数-top</span><br><span class="line">static int audio_disable;//关闭音频，对应参数-an</span><br><span class="line">static int video_disable;//关闭视频，对应参数-vn</span><br><span class="line">static int subtitle_disable;//关闭字幕，对应参数-sn</span><br><span class="line">static const char* wanted_stream_spec[AVMEDIA_TYPE_NB] = &#123;0&#125;;//用户设置的期望使用的流，对应参数-ast,-vst,-sst</span><br><span class="line">static int seek_by_bytes = -1;//按字节seek，对应参数-bytes</span><br><span class="line">static float seek_interval = 10;//查找间隔(步长)，对应参数-seek_interval</span><br><span class="line">static int display_disable;//关闭显示，对应参数-nodisp</span><br><span class="line">static int borderless;//窗口无边框，对应参数-noborder</span><br><span class="line">static int alwaysontop;//窗口置顶，对应参数-alwaysontop</span><br><span class="line">static int startup_volume = 100;//初始音量，对应参数-volume</span><br><span class="line">static int show_status = -1;//是否打印状态信息，对应参数-stats</span><br><span class="line">static int av_sync_type = AV_SYNC_AUDIO_MASTER;//音视频同步模式，对应参数-sync</span><br><span class="line">static int64_t start_time = AV_NOPTS_VALUE;//开始时间，对应参数-ss</span><br><span class="line">static int64_t duration = AV_NOPTS_VALUE;//持续时长，对应参数-t，这两个参数用于播放指定时间段的内容</span><br><span class="line">static int fast = 0;//允许使用非标准的加速解码手段，对应参数-fast</span><br><span class="line">static int genpts = 0;//生成时间戳，对应参数-genpts</span><br><span class="line">static int lowres = 0;//低分辨率解码</span><br><span class="line">static int decoder_reorder_pts = -1;//让解码器对pts重新排序，对应参数-drp</span><br><span class="line">static int autoexit;//播放结束自动退出，对应参数-autoexit</span><br><span class="line">static int exit_on_keydown;//按键退出播放，对应参数-exitonkeydown</span><br><span class="line">static int exit_on_mousedown;//按下鼠标退出播放，对应参数-exitonmousedown</span><br><span class="line">static int loop = 1;//循环播放，对应参数-loop</span><br><span class="line">static int framedrop = -1;//是否允许cpu性能达不到要求时丢帧，对应参数-framedrop</span><br><span class="line">static int infinite_buffer = -1;//是否限制输入缓冲区大小，对应参数-infbuf</span><br><span class="line">static enum ShowMode show_mode = SHOW_MODE_NONE;//显示模式</span><br><span class="line">static const char *audio_codec_name;//音频解码器名称，对应参数-acodec</span><br><span class="line">static const char *subtitle_codec_name;//字幕解码器名称，对应参数-scodec</span><br><span class="line">static const char *video_codec_name;//视频解码器名称，对应参数-vcodec</span><br><span class="line">double rdftspeed = 0.02;//rdft速度，对应参数-rdftspeed</span><br><span class="line">static int64_t cursor_last_shown;</span><br><span class="line">static int cursor_hidden = 0;</span><br><span class="line">#if CONFIG_AVFILTER</span><br><span class="line">static const char **vfilters_list = NULL;</span><br><span class="line">static int nb_vfilters = 0;</span><br><span class="line">static char *afilters = NULL;</span><br><span class="line">#endif</span><br><span class="line">static int autorotate = 1;//自动旋转视频，对应参数-autorotate</span><br><span class="line">static int find_stream_info = 1;//查询流信息，对应参数-find_stream_info</span><br><span class="line">static int filter_nbthreads = 0;//filter线程数，对应参数-filter_threads</span><br><span class="line"></span><br><span class="line">/* current context */</span><br><span class="line">static int is_full_screen;//是否全屏，对应参数-fs</span><br></pre></td></tr></table></figure><p>带注释的完整main函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  int flags;//用于创建SDL窗口时指定flag</span><br><span class="line">  VideoState *is;</span><br><span class="line"></span><br><span class="line">  init_dynload();//当前只做一件事，在win32平台将当前工作目录从DLL搜索路径中移除</span><br><span class="line"></span><br><span class="line">  av_log_set_flags(AV_LOG_SKIP_REPEATED);//折叠重复日志</span><br><span class="line">  parse_loglevel(argc, argv, options);//解析loglevel</span><br><span class="line"></span><br><span class="line">  /* register all codecs, demux and protocols */</span><br><span class="line">#if CONFIG_AVDEVICE</span><br><span class="line">  avdevice_register_all();//初始化libavdeivce库并且注册所有输入输出设备</span><br><span class="line">#endif</span><br><span class="line">  avformat_network_init();//初始化网络库</span><br><span class="line"></span><br><span class="line">  //指定SIGINT和SIGTERM两个信号的处理函数</span><br><span class="line">  signal(SIGINT , sigterm_handler); /* Interrupt (ANSI).    */</span><br><span class="line">  signal(SIGTERM, sigterm_handler); /* Termination (ANSI).  */</span><br><span class="line"></span><br><span class="line">  show_banner(argc, argv, options);//打印程序和库的信息</span><br><span class="line"></span><br><span class="line">  parse_options(NULL, argc, argv, options, opt_input_file);//解析参数</span><br><span class="line"></span><br><span class="line">  /*必须有输入文件，否则退出*/</span><br><span class="line">  if (!input_filename) &#123;</span><br><span class="line">    show_usage();</span><br><span class="line">    av_log(NULL, AV_LOG_FATAL, &quot;An input file must be specified\n&quot;);</span><br><span class="line">    av_log(NULL, AV_LOG_FATAL,</span><br><span class="line">           &quot;Use -h to get full help or, even better, run &#x27;man %s&#x27;\n&quot;, program_name);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  /*判断是否显示画面*/</span><br><span class="line">  if (display_disable) &#123;//display_disable通过命令行参数-nodisp设置</span><br><span class="line">    video_disable = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  flags = SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER;//默认加载SDL的video、audio和timer子系统</span><br><span class="line">  if (audio_disable)//audio_disable通过命令行参数-an设置</span><br><span class="line">    flags &amp;= ~SDL_INIT_AUDIO;</span><br><span class="line">  else &#123;</span><br><span class="line">    /* Try to work around an occasional ALSA buffer underflow issue when the</span><br><span class="line">     * period size is NPOT due to ALSA resampling by forcing the buffer size. */</span><br><span class="line">    if (!SDL_getenv(&quot;SDL_AUDIO_ALSA_SET_BUFFER_SIZE&quot;))</span><br><span class="line">      SDL_setenv(&quot;SDL_AUDIO_ALSA_SET_BUFFER_SIZE&quot;,&quot;1&quot;, 1);</span><br><span class="line">  &#125;</span><br><span class="line">  if (display_disable)</span><br><span class="line">    flags &amp;= ~SDL_INIT_VIDEO;</span><br><span class="line">  if (SDL_Init (flags)) &#123;//用配置好的flags初始化SDL</span><br><span class="line">    av_log(NULL, AV_LOG_FATAL, &quot;Could not initialize SDL - %s\n&quot;, SDL_GetError());</span><br><span class="line">    av_log(NULL, AV_LOG_FATAL, &quot;(Did you set the DISPLAY variable?)\n&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  //忽略事件</span><br><span class="line">  SDL_EventState(SDL_SYSWMEVENT, SDL_IGNORE);</span><br><span class="line">  SDL_EventState(SDL_USEREVENT, SDL_IGNORE);</span><br><span class="line"></span><br><span class="line">  if (!display_disable) &#123;</span><br><span class="line">    int flags = SDL_WINDOW_HIDDEN;//配置SDL创建窗口的标志位</span><br><span class="line">    if (alwaysontop)</span><br><span class="line">#if SDL_VERSION_ATLEAST(2,0,5)</span><br><span class="line">      flags |= SDL_WINDOW_ALWAYS_ON_TOP;</span><br><span class="line">#else</span><br><span class="line">    av_log(NULL, AV_LOG_WARNING, &quot;Your SDL version doesn&#x27;t support SDL_WINDOW_ALWAYS_ON_TOP. Feature will be inactive.\n&quot;);</span><br><span class="line">#endif</span><br><span class="line">    if (borderless)</span><br><span class="line">      flags |= SDL_WINDOW_BORDERLESS;</span><br><span class="line">    else</span><br><span class="line">      flags |= SDL_WINDOW_RESIZABLE;</span><br><span class="line"></span><br><span class="line">#ifdef SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR</span><br><span class="line">    SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, &quot;0&quot;);</span><br><span class="line">#endif</span><br><span class="line">    window = SDL_CreateWindow(program_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, default_width, default_height, flags);//创建SDL窗口</span><br><span class="line">    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, &quot;linear&quot;);//设置默认的图片缩放质量为线性</span><br><span class="line">    if (window) &#123;</span><br><span class="line">      renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);//从窗口创建渲染器</span><br><span class="line">      if (!renderer) &#123;</span><br><span class="line">        av_log(NULL, AV_LOG_WARNING, &quot;Failed to initialize a hardware accelerated renderer: %s\n&quot;, SDL_GetError());</span><br><span class="line">        renderer = SDL_CreateRenderer(window, -1, 0);</span><br><span class="line">      &#125;</span><br><span class="line">      if (renderer) &#123;</span><br><span class="line">        if (!SDL_GetRendererInfo(renderer, &amp;renderer_info))//打印渲染器信息</span><br><span class="line">          av_log(NULL, AV_LOG_VERBOSE, &quot;Initialized %s renderer.\n&quot;, renderer_info.name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!window || !renderer || !renderer_info.num_texture_formats) &#123;//打印失败信息</span><br><span class="line">      av_log(NULL, AV_LOG_FATAL, &quot;Failed to create window or renderer: %s&quot;, SDL_GetError());</span><br><span class="line">      do_exit(NULL);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  is = stream_open(input_filename, file_iformat);//打开视频/音频/字幕流</span><br><span class="line">  if (!is) &#123;</span><br><span class="line">    av_log(NULL, AV_LOG_FATAL, &quot;Failed to initialize VideoState!\n&quot;);</span><br><span class="line">    do_exit(NULL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  event_loop(is);//开启SDL事件循环</span><br><span class="line"></span><br><span class="line">  /* never returns */</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码篇幅上看，main函数中绝大多数代码是用来配置SDL_init()和SDL_CreateWindow()这两个函数的标志位flags的。</p><p>其中SDL_Init()函数是用来初始化SDL库的，在使用任何SDL库函数之前必须先调用这个函数。SDL_Init接受一个Uint32类型的flags参数用来初始化SDL子系统，如SDL_INIT_AUDIO表示音频子系统，SDL_INIT_VIDEO表示视频子系统等，可以通过位或操作组合多个标志位来初始化多个子系统的目的，如SDL_INIT_AUDIO|SDL_INIT_VIDEO表示初始化音频子系统和视频子系统。SDL_Init()可用的标志位及其含义如下：</p><p>SDL_INIT_TIMER: timer subsystem<br>SDL_INIT_AUDIO: audio subsystem<br>SDL_INIT_VIDEO: video subsystem; automatically initializes the events subsystem<br>SDL_INIT_JOYSTICK: joystick subsystem; automatically initializes the events subsystem<br>SDL_INIT_HAPTIC: haptic (force feedback) subsystem<br>SDL_INIT_GAMECONTROLLER: controller subsystem; automatically initializes the joystick subsystem<br>SDL_INIT_EVENTS: events subsystem<br>SDL_INIT_EVERYTHING: all of the above subsystems<br>SDL_INIT_NOPARACHUTE: compatibility; this flag is ignored</p><p>完成SDL库的初始化后，接着开始创建主窗口以及对应的渲染器，主要使用SDL_CreateWindow()和SDL_CreateRenderer()这两个函数，创建成功以及打印完相关信息后，main函数中的可以归属为”初始化任务”的代码就结束了。</p><p>接下来的代码更简单直接，只是调用了stream_open()和event_loop()这两个函数。从函数名推断stream_open()用来打开流，event_loop()用来处理事件循环。事实也正是如此，不过有亿点不同的是：stream_open()不仅完成了打开流的工作，还完成了所有流的读取以及音频流向音频设备的输出；event_loop()除了处理SDL的事件循环，还负责视频流以及字幕流向显示设备的输出。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
