<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>元对象系统</title>
      <link href="/2022/12/06/%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/12/06/%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>QT的元对象系统提供了对象间通信的信号槽机制，运行时类型信息，和动态属性。<br>元对象系统有三个组成部分：<br>QObject：为所有需要使用元对象系统的类提供的一个基类；<br>Q_OBJECT：在QObject子类私有部分声明（一般是类声明的第一行），声明这个宏可以为当前类提供元对象系统特性，比如动态属性，信号槽等；<br>Meta-Object Compiler(MOC):为每个QObject子类提供必要的代码以实现元对象特性。</p><p>moc工具读取C++源文件，如果发现类中包含了Q_OBJECT宏，就另外生成一个C++源文件，在这个源文件中有对应类的元对象代码。这些生成的源文件可以直接通过#include导入原有的源文件中，或者有更常见的做法，就是编译后链接至指定的类实现。<br>元对象系统提供了以下功能：<br>1.信号槽，QT元对象系统的引入，主要就是为了提供这个机制；<br>2.QObject::metaObject()可以返回类对应的元对象；<br>3.QMetaObject::className()可以在运行时返回类名，这一功能不需要C++编译器支持RTTI；<br>4.QObject::inherits()判断一个对象是否是一个QObject对象树上某一个类的实例；<br>5.QObject::tr()提供字符串国际化；<br>6.QObject::setProperty()和 QObject::property() 动态设定和获取属性名；<br>7.QMetaObject::newInstance()构造一个类的实例。</p><p>元对象系统为QObject类及其子类提供了了动态类型转换函数qobject_cast(),效果类似标准C++的dynamic_cast().它不需要以来RTTI并且在动态链接库间也能正常工作。该函数如果成功则返回一个尖括号中指定的指针类型，如果失败则返回一个nullptr。<br>例如有一个QWidget的子类MyWidget声明了Q_OBJECT宏：<br><code>QObject *obj = new MyWidget;</code><br><code>QWidget *widget = qobject_cast&lt;QWidget *&gt;(obj);</code><br><code>MyWidget *myWidget = qobject_cast&lt;MyWidget *&gt;(obj);</code></p><p>第一次转型成功，因为obj实际指向的就是一个QWidget的派生类对象。<br>第二次转型成功，因为类型转换后得到的widget实际指向的是一个MyWidget实例，所以从<em>widget转型至</em>MyWidget也是成功的。qobjcet_cast()并不区分内置的qt类型和自定义类型。<br>但是以下的转换是失败的：<br><code>QLabel *label = qobject_cast&lt;QLabel *&gt;(obj);</code></p><p>QLable和MyWidget虽然都派生自QWidget，但是两者没有直接的派生关系，所以不能动态转换。<br>理论上是可以从QObject基类派生出一个子类，但是不声明Q_OBJECT宏的，这样moc就不会为这个类生成相应的代码，这个类的实例也就不能使用元对象系统的特性。从元系统的角度，认为这个类和它最近的拥有元系统代码（声明了Q_OBJECT宏）的父类是等同的。也就意味着，如果调用QMetaOjbect::className(),函数返回的是最近的拥有元系统特性的父类的名称。这可能会带来一些麻烦。<br>所以不管是否使用元系统特性，QT官方都建议凡是QObject的子类，都要声明Q_OBJECT宏。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS系统下QT连接mysql数据库</title>
      <link href="/2022/12/06/MacOS%E7%B3%BB%E7%BB%9F%E4%B8%8BQT%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/12/06/MacOS%E7%B3%BB%E7%BB%9F%E4%B8%8BQT%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>MACOS版本：12.3.1</p><p>Qt版本：5.15.2</p><p>1.安装mysql数据库，我的电脑上的安装目录为&#x2F;usr&#x2F;local&#x2F;mysql</p><p>2.准备一个测试程序打印一下当前qt加载的数据库驱动：</p><p>main.cpp</p><p><code>#include &lt;QApplication&gt;</code><br><code>#include &lt;QSqlDatabase&gt;</code><br><code>#include &lt;QDebug&gt;</code><br><code>int main(int argc,char* argv[]) &#123;</code><br>  <code>QApplication app(argc,argv);</code><br>  <code>QStringList drivers = QSqlDatabase::drivers();</code><br>  <code>foreach(QString driver,drivers)</code> <br>  <code>qDebug()&lt;&lt;driver;</code><br>  <code>return app.exec();</code><br><code>&#125;</code></p><p>接下来编写CMakeLists.txt</p><p>qt连接数据库需要编译时引入sql组件</p><p><code>cmake_minimum_required(VERSION 3.0)</code><br><code>project(qt_sql_test) s</code><br><code>et(CMAKE_CXX_STANDARD 11)</code><br><code>set(CMAKE_AUTOMOC ON)</code><br><code>set(CMAKE_AUTOUIC ON)</code><br><code>set(CMAKE_AUTORCC ON)</code><br><code>set(CMAKE_PREFIX_PATH /Users/wenxinyuan/Qt/5.15.2/clang_64)</code><br><code>find_package(Qt5 COMPONENTS Core Widgets Sql REQUIRED)</code><br><code>link_libraries(</code><br><code>Qt5::Core</code><br><code>Qt5::Widgets</code><br><code>Qt5::Sql</code><br><code>)</code><br><code>aux_source_directory(./srcs)</code><br><code>add_executable(qt_sql_test $&#123;srcs&#125;)</code></p><p>需要注意的是第9行，如果没有这一行，那么使用cmake构建的时候就会得到类似下面这样的提示：</p><blockquote><p>CMake Error at CMakeLists.txt:10 (find_package):<br>  By not providing “FindQt5.cmake” in CMAKE_MODULE_PATH this project has<br>  asked CMake to find a package configuration file provided by “Qt5”, but<br>  CMake did not find one.</p><p>  Could not find a package configuration file provided by “Qt5” with any of<br>  the following names:</p><p>Qt5Config.cmake<br>qt5-config.cmake</p><p>  Add the installation prefix of “Qt5” to CMAKE_PREFIX_PATH or set “Qt5_DIR”<br>  to a directory containing one of the above files.  If “Qt5” provides a<br>  separate development package or SDK, be sure it has been installed.</p></blockquote><p>所以我们按照提示设置下qt的安装目录，这个安装目录就是bin文件夹所在的目录</p><p>输出的结果如下：</p><p>“QSQLITE”</p><p>“QODBC”</p><p>“QODBC3”</p><p>“QPSQL”</p><p>“QPSQL7”</p><p>以上结果说明当前的qt中没有mysql的驱动，这就需要我们自行编译安装mysql的驱动。</p><p>qt官网中5.15版本的文档提供了编译mysql驱动以及安装插件的方法，链接如下:</p><p><a href="https://doc.qt.io/qt-5/sql-driver.html#driverwithqt">https://doc.qt.io/qt-5/sql-driver.html#driverwithqt</a></p><p>但是按照官网的方法在我的电脑上没有成功，我也找不到原因，所以我使用另一种方案</p><p>首先进入mysql驱动的源码目录,在我的电脑上，这个目录是</p><p>&#x2F;Users&#x2F;wenxinyuan&#x2F;QT&#x2F;5.15.2&#x2F;Src&#x2F;qtbase&#x2F;src&#x2F;plugins&#x2F;sqldrivers&#x2F;mysql</p><p>这个目录中有一个名称为mysql.pro的文件，打开文件做一下修改：</p><p><code>TARGET = qsqlmysql</code></p><p><code>HEADERS += $$PWD/qsql_mysql_p.h</code><br><code>SOURCES += $$PWD/qsql_mysql.cpp $$PWD/main.cpp</code></p><p><code>#QMAKE_USE += mysql //将原本的这一行注释掉</code><br><code>INCLUDEPATH+=/usr/local/mysql/include //添加mysql的include目录</code><br><code>LIBS+= -L /usr/local/mysql/lib -lmysqlclient //添加mysql的lib目录</code></p><p><code>OTHER_FILES += mysql.json</code></p><p><code>PLUGIN_CLASS_NAME = QMYSQLDriverPlugin</code><br><code>include(../qsqldriverbase.pri)</code></p><p>修改保存后就可以执行qmake进行构建：</p><p>&#x2F;Users&#x2F;wenxinyuan&#x2F;Qt&#x2F;5.15.2&#x2F;clang_64&#x2F;bin&#x2F;qmake  mysql.pro</p><p>由于我没有设置环境变量，所以使用了qmake的完整路径。</p><p>构建过程中没有输出，最后会生成一个新的Makefile文件。直接执行，make进行编译</p><p>编译生成的文件放在下面的目录,注意跟源码目录的差别。</p><p>&#x2F;Users&#x2F;wenxinyuan&#x2F;Qt&#x2F;5.15.2&#x2F;Src&#x2F;qtbase&#x2F;plugins&#x2F;sqldrivers</p><p>我们直接执行make install进行安装</p><p>编译好的库文件会被安装到目录</p><p>&#x2F;Users&#x2F;wenxinyuan&#x2F;Qt&#x2F;5.15.2&#x2F;clang_64&#x2F;plugins&#x2F;sqldrivers</p><p>中。至此我们已经完成的mysql驱动的编译以及安装。使用文章开头的程序重新检测输出如下：</p><p>“QSQLITE”</p><p>“QMARIADB”</p><p>“QMYSQL”</p><p>“QMYSQL3”</p><p>“QODBC”</p><p>“QODBC3”</p><p>“QPSQL”</p><p>“QPSQL7”</p><p>说明qt已经可以检测到mysql的驱动了。</p><p>接下来我们连接一下本地的数据库进行测试，连接数据库代码如下：</p><p><code>#include &lt;QApplication&gt;</code><br><code>#include &lt;QSqlDatabase&gt;</code><br><code>#include &lt;QDebug&gt;</code></p><p><code>int main(int argc,char* argv[])</code><br><code>&#123;</code><br>    <code>QApplication app(argc,argv);</code><br>    <code>QSqlDatabase db = QSqlDatabase::addDatabase(&quot;QMYSQL&quot;);</code><br>    <code>db.setHostName(&quot;localhost&quot;);</code><br>    <code>db.setDatabaseName(&quot;test1&quot;);</code><br>    <code>db.setUserName(&quot;xinyuan&quot;);</code><br>    <code>db.setPassword(&quot;123456&quot;);</code><br>    <code>bool ret = db.open();</code><br>    <code>qDebug()&lt;&lt;ret;</code><br>    <code>return app.exec();</code><br><code>&#125;</code></p><p>编译后运行输出结果如下：</p><p>QSqlDatabase: QMYSQL driver not loaded QSqlDatabase: available drivers: QSQLITE QMARIADB QMYSQL QMYSQL3 QODBC QODBC3 QPSQL QPSQL7 false</p><p>可以看到虽然qt已经识别到mysql的驱动，但是连接还是失败了。</p><p>为了排查原因，我们设置下环境变量<strong>QT_DEBUG_PLUGINS</strong>&#x3D;1,并重新运行看一下debug信息：</p><p>export QT_DEBUG_PLUGINS&#x3D;1</p><p>运行后输出的信息很多，我们提取最后的有用信息：</p><p>Reason: tried: ‘&#x2F;Users&#x2F;wenxinyuan&#x2F;sources&#x2F;qtsql&#x2F;build&#x2F;..&#x2F;Frameworks&#x2F;libmysqlclient.21.dylib’ (no such file), ‘&#x2F;Users&#x2F;wenxinyuan&#x2F;Qt&#x2F;5.15.2&#x2F;clang_64&#x2F;plugins&#x2F;sqldrivers&#x2F;..&#x2F;..&#x2F;lib&#x2F;libmysqlclient.21.dylib’ (no such file), ‘&#x2F;Users&#x2F;wenxinyuan&#x2F;sources&#x2F;qtsql&#x2F;build&#x2F;..&#x2F;Frameworks&#x2F;libmysqlclient.21.dylib’ (no such file), ‘&#x2F;Users&#x2F;wenxinyuan&#x2F;Qt&#x2F;5.15.2&#x2F;clang_64&#x2F;plugins&#x2F;sqldrivers&#x2F;..&#x2F;..&#x2F;lib&#x2F;libmysqlclient.21.dylib’ (no such file), ‘&#x2F;Users&#x2F;wenxinyuan&#x2F;sources&#x2F;qtsql&#x2F;build&#x2F;..&#x2F;Frameworks&#x2F;libmysqlclient.21.dylib’ (no such file), ‘&#x2F;Users&#x2F;wenxinyuan&#x2F;Qt&#x2F;5.15.2&#x2F;clang_64&#x2F;lib&#x2F;QtCore.framework&#x2F;Versions&#x2F;5&#x2F;Frameworks&#x2F;libmysqlclient.21.dylib’ (no such file), ‘&#x2F;Users&#x2F;wenxinyuan&#x2F;Qt&#x2F;5.15.2&#x2F;clang_64&#x2F;lib&#x2F;libmysqlclient.21.dylib’ (no such file), ‘&#x2F;usr&#x2F;local&#x2F;lib&#x2F;libmysqlclient.21.dylib’ (no such file), ‘&#x2F;usr&#x2F;lib&#x2F;libmysqlclient.21.dylib’ (no such file))</p><p>可以看到无法加载驱动的原因是相关的mysql的库找不到，那解决方案就很简单了，只需要在CMakeLists.txt文件中添加下相关的库目录就行了，在我的环境下，添加如下命令即可：</p><p>link_directories(     </p><p>&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;lib</p><p>​          )</p><p>重新编译运行后，db.open()返回值为true，成功连接上数据库；</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程学习笔记：使用std::async()创建异步任务</title>
      <link href="/2022/12/06/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8async()%E5%88%9B%E5%BB%BA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
      <url>/2022/12/06/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8async()%E5%88%9B%E5%BB%BA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>C++标准库提供了一个高层接口用于创建异步任务：std::async()，跟std::thread构造函数一样，该函数同样可以接受任何可调用类型对象作为参数，函数返回一个future<T>类型的对象，future<T>是一个模板类，类型参数T表示任务函数返回值的类型，如果任务函数没有返回值，则T为void。使用std::async()创建异步任务的方法如下：</p><p><code>void print_once()&#123;</code><br>    <code>this_thread::sleep_for(chrono::seconds(1));</code><br>    <code>cout&lt;&lt;&quot;hello world from thread： &quot;&lt;&lt;std::this_thread::get_id()&lt;&lt;endl;</code><br><code>&#125;;</code><br><code>int main()&#123;</code><br>  <code>std::future&lt;void&gt; res = std::async(print_once);</code><br>  <code>res.wait();</code><br>  <code>return 0;</code><br><code>&#125;</code></p><p>使用std::async()创建异步任务与使用std::thread创建线程有一个重要的差异，就是前者并不保证任务函数一定在单独的线程中执行，也就是说std::async()并不保证一定会创建一个新的线程，自然也不能保证创建异步任务后任务函数会立刻开始执行。那如果调用线程需要确保异步任务执行结束或者需要获取异步任务的执行结果呢？答案是使用std::async()返回的future对象调用wait()或get()，wait()函数会阻塞直到异步任务执行完毕，get()函数会阻塞直到异步任务执行完毕并从获取任务函数的返回值。wait()函数和get()函数会强制启动future关联的线程并等待线程执行结束。</p><p>到这里我们已经可以发现使用std::async()的第一个好处了：我们可以获取任务函数的执行结果！当我们使用std::thread创建线程时，线程创建后就独立运行，如果任务函数有返回值，即便线程执行结束，我们也没有办法通过线程对象获取到任务函数的返回值，只能通过传入引用或者修改共享内存等方法来获取线程的执行结果。但是使用std::async()我们只需要对其返回的future执行get()就可以轻松获取线程的执行结果！future还有一个强大的功能，传递异常！当我们使用std::thread创建线程时，如果线程中的函数抛出异常，会发生什么呢？我们来模拟一下这种情况，先写个简单的测试函数，抛出一个异常：</p><p><code>int func()&#123;</code><br>  <code>throw logic_error(&quot;error&quot;);</code><br><code>&#125;</code></p><p>我们像往常一样使用try-catch块将调用函数的地方包起来，看看会发生什么：</p><p><code>try&#123;</code><br>  <code>std::thread t(func);</code><br>  <code>t.join();</code><br><code>&#125;catch (exception &amp;e)&#123;</code><br>  <code>cout&lt;&lt;e.what()&lt;&lt;endl;</code><br><code>&#125;</code></p><p>代码执行后报错：libc++abi: terminating with uncaught exception of type std::logic_error: error。</p><p>怎么会这样呢？这是因为如果将异常从任务函数向上传递给std::thread的构造函数，异常并不会被传递给创建线程的主线程，所以在主线程中当然不会捕获到任何异常，所以未处理的异常会导致std::terminate()被调用，整个程序就会被终止。因为一个线程的异常导致整个程序被异常终止通常不是我们想要的结果，理想的结果是只有发生异常的线程被终止，其他线程不受影响。要想达成这样的目的，我们可以在任务函数中将所有异常处理掉，不让异常向上传递，但是实际开发时，你不能保证所有的任务函数都出自同一个程序员之手，甚至不能保证所有函数你都能看到源码，所以也不能保证这些任务函数都会有自己的异常处理代码；第二种方法是在创建线程时使用try-catch块包裹住任务函数：</p><p><code>std::thread t([]&#123;try&#123;func();&#125;catch(exception &amp;e)&#123;cout&lt;&lt;e.what()&lt;&lt;endl ;&#125;&#125;);</code></p><p>这种方式明显比第一种方式优雅许多。那么使用std::async()创建的异步任务怎么处理异常呢？答案是使用try-catch将get()调用包裹起来,甚至如果你不想处理异常，你都可以不写任何异常处理代码，也不会导致程序异常终止！当然这种做法是不提倡的。</p><p><code>auto res = std::async(func);</code><br><code>try&#123;</code><br>  <code>res.get();</code><br><code>&#125;catch (exception &amp;e)&#123;</code><br>  <code>cout&lt;&lt;e.what()&lt;&lt;endl;</code><br><code>&#125;</code></p><p>我们用auto来修饰std::async()的返回值，这是一种常用的简化代码的方式，我们不必去记住每个任务函数的返回类型。异步任务中的异常信息会被保存在一个shared state对象当中，该对象是引用计数的。当对返回值future调用get()时，保存在shared state中的异常会被重新抛出，我们就可以在try-catch块中捕捉异常了。</p><p>在文章的开头我们说过，使用std::async()创建的异步任务可能并不会创建一个新的线程单独运行，也不保证在函数调用后异步任务立刻就开始执行，只是保证在对future调用的wait()或get()函数返回时，异步任务已经执行完毕。这种行为就像是我们为我们将来可能使用的某个结果安排了一个异步任务，标准库保证我们在需要这个结果的时候异步任务会执行完并将结果返回给我们，如果我们以后不需要这个结果了，那么我们提前安排的异步任务可能根本就不会执行。那么我们能手动控制这种行为吗？答案是肯定的。std::async()函数的第一个参数用于指定发射（Launch）策略，当没有手动指定的时候（就像之前我们的用法），会启用默认策略。标准库提供的策略有三种：</p><ol><li><p>std::launch::deferred：任务函数会在当前线程中执行并会延迟执行直到wait()或get()被调用；</p></li><li><p>std::launch::async：任务函数会在独立线程中立即执行；</p></li><li><p>std::launch::deferred|std::launch::async：选择哪种执行方式交给具体实现。</p></li></ol><p>默认的策略是第三种，所以如果我们期望异步任务一定要在单独线程中执行时，应该明确指定Launch策略为std::launch::async：</p><p><code>auto res = std::async(std::launch::async,func);</code></p><p>当我们指定策略为std::launch::async时，即便我们未来没有对res调用wait()或get(),在res离开作用域被销毁之前，主线程也会等待直到异步任务执行结束。相反如果我们指定策略为std::launch::deffered，在我们调用wait()和get()之前，任务函数根本就不会被执行。</p><p>使用默认策略会将选择权交给标准库，标准库会根据全局的线程使用情况来选择使用哪种策略。这就带来一个问题，就是当你使用默认策略的时候，你并不知道任务函数会在当前线程还是新线程中执行，如果函数涉及到一些thread_local类型数据的修改，就会导致你不知道究竟是哪个线程的数据被修改了。另外假如你想要等待某个异步任务执行成功，写了如下代码：</p><p><code>auto res = std::async(func);</code></p><p><code>while(res.wait_for(1000ms)!=std::future_status::ready)&#123;</code></p><p><code>...</code></p><p><code>&#125;</code></p><p>你可能会被永远困在循环中！因为如果自动选定的策略是deferred，那么wait_for()函数的返回结果永远都会是std::future_status::defferred。wait_for()函数会等待一段时间并返回future的状态，当任务函数执行完毕后，future会被设置为ready，该状态被保存在future关联的shared state对象当中，类似的函数还有wait_until(),与wait()函数不同，wait_for()和wait_until()只会返回future的状态，并不会强制启动异步任务。</p><p>参考书目：《Effective.Modern.C++》、《C++Concurrency in Action 2nd Edition》、《C++标准库第二版》、《Primer C++ 第五版》</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（八）：音视频同步</title>
      <link href="/2022/12/05/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5/"/>
      <url>/2022/12/05/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>ffplay的音视频同步模式有三种，音频流为主，视频流为主，外部时钟为主，定义在一个枚举类型中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  AV_SYNC_AUDIO_MASTER,</span><br><span class="line">  AV_SYNC_VIDEO_MASTER,</span><br><span class="line">  AV_SYNC_EXTERNAL_CLOCK,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>语音视频同步相关的还有一个结构体Clock，它与PacketQueue是绑定的，表示某一个流的时钟：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Clock</span> &#123;</span></span><br><span class="line">  <span class="type">double</span> pts;           <span class="comment">/* clock base */</span></span><br><span class="line">  <span class="type">double</span> pts_drift;     <span class="comment">/* clock base minus time at which we updated the clock */</span></span><br><span class="line">  <span class="type">double</span> last_updated;<span class="comment">//上次更新的时间</span></span><br><span class="line">  <span class="type">double</span> speed;<span class="comment">//时钟速度</span></span><br><span class="line">  <span class="type">int</span> serial;<span class="comment">//时钟的序列号 /* clock is based on a packet with this serial */</span></span><br><span class="line">  <span class="type">int</span> paused;<span class="comment">//暂停标志位</span></span><br><span class="line">  <span class="type">int</span> *queue_serial;<span class="comment">//指向时钟绑定的包队列的序列号</span></span><br><span class="line">&#125; Clock;</span><br></pre></td></tr></table></figure><p>时钟用来记录各个流的播放时间点，这里需要注意的是pts_drift这个值，它用来表示更新时钟时pts相对于当前系统时间点的偏移量。有了这个值，我们获取任意时间点的时钟，只需要获取系统时间再加上这个偏移量即可；但是这种计算方式有一个前提，就是时钟的速度是恒定的，由于Clock中表示速度的speed字段是会改变的，所以计算实际的时间点时，还需要减去速度差带来的误差，所以最终获取时钟的算法就变成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> time = av_gettime_relative() / <span class="number">1000000.0</span>;</span><br><span class="line"><span class="keyword">return</span> c-&gt;pts_drift + time - (time - c-&gt;last_updated) * (<span class="number">1.0</span> - c-&gt;speed);</span><br></pre></td></tr></table></figure><p>音频流的时钟会在callback调用的时候更新，视频流的时钟会在video_refresh函数中读取新一帧的时候更新，两者的逻辑都是先更新本身的时钟，然后再将外部时钟与自身的时钟同步。</p><p>我们先来分析默认的AV_SYNC_AUDIO_MASTER情形。这种情况下音频流的时钟为主时钟，所以对于音频流来讲只要按照顺序将解析好的数据发送给音频设备正常播放就行了，与此同时，每解析一帧音频数据，音频流的时钟都会更新，更新后的时钟也会同步到外部时钟。对于视频流来说，需要播放时同步音频流的时钟，如果视频流的时钟快于主时钟，那么就需要通过重复播放视频帧来等待音频流，相反如果视频流的时钟慢于主时钟，那就要丢帧去追赶音频流。视频同步音频的算法我们在之前分析视频播放的时候已经看过，我们现在重温一遍：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">double</span> <span class="title function_">compute_target_delay</span><span class="params">(<span class="type">double</span> delay, VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> sync_threshold, diff = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* update delay to follow master synchronisation source */</span></span><br><span class="line">  <span class="keyword">if</span> (get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER) &#123;</span><br><span class="line">    <span class="comment">/* if video is slave, we try to correct big delays by</span></span><br><span class="line"><span class="comment">       duplicating or deleting a frame */</span></span><br><span class="line">    <span class="comment">//如果不是音频同步视频，通过复制帧或者丢帧来修正延时</span></span><br><span class="line">    diff = get_clock(&amp;is-&gt;vidclk) - get_master_clock(is);<span class="comment">//视频流是时钟和主时钟的差值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* skip or repeat frame. We take into account the</span></span><br><span class="line"><span class="comment">       delay to compute the threshold. I still don&#x27;t know</span></span><br><span class="line"><span class="comment">       if it is the best guess */</span></span><br><span class="line">    sync_threshold = FFMAX(AV_SYNC_THRESHOLD_MIN, FFMIN(AV_SYNC_THRESHOLD_MAX, delay));<span class="comment">//算一个时间差阈值，如果delay在最大和最小阈值范围内，取delay，过大了，去最大阈值，过小了取最小阈值</span></span><br><span class="line">    <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; is-&gt;max_frame_duration) &#123;</span><br><span class="line">      <span class="keyword">if</span> (diff &lt;= -sync_threshold)<span class="comment">//视频流慢太多了，delay需要减小，这样下一帧能更快显示（跳帧）</span></span><br><span class="line">        delay = FFMAX(<span class="number">0</span>, delay + diff);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold &amp;&amp; delay &gt; AV_SYNC_FRAMEDUP_THRESHOLD)<span class="comment">//（重复帧）</span></span><br><span class="line">        delay = delay + diff;<span class="comment">//视频流快太多了，并且延时超过了复制一帧的最大阈值。这个阈值的意思是，如果上一帧的持续时间超过了这个值，就不应该通过重复帧来进行同步</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold)</span><br><span class="line">        delay = <span class="number">2</span> * delay;<span class="comment">//视频流快太多，且上一帧的持续时间没超过阈值，将延迟增加一倍</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  av_log(<span class="literal">NULL</span>, AV_LOG_TRACE, <span class="string">&quot;video: delay=%0.3f A-V=%f\n&quot;</span>,</span><br><span class="line">         delay, -diff);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> delay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的主要思想是根据视频流时钟与主时钟的差值来计算当前帧的实际显示时间，如果当前时钟慢了，就缩小显示时间，反之就延长显示时间。计算时会有一个阈值，在这个阈值的正负值范围内，认为音视频是同步的，不需要校正。在这一步计算出当前帧的显示时间后，如果计算的结果是延长显示时间，那么相应的帧的显示时间会被拉长以达到等待音频流的目的。如果就算的结果是缩短显示时间，甚至显示时间被缩短到最小的0，那么会根据相应的算法进行丢帧以达到追赶音频流的目的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">is-&gt;frame_timer += delay;<span class="comment">//上述条件未满足，先将timer设置为上一帧结束的时间，这个值现在表示的是当前帧的显示时间</span></span><br><span class="line">      <span class="keyword">if</span> (delay &gt; <span class="number">0</span> &amp;&amp; time - is-&gt;frame_timer &gt; AV_SYNC_THRESHOLD_MAX)<span class="comment">//如果跟当前时间差超过时间同步最大阈值，将时间点设置为当前时间</span></span><br><span class="line">        is-&gt;frame_timer = time;<span class="comment">//如果不执行这一步，结果就是连续好多帧的结束时间都会小于当前时间点，如果设置可以丢帧，就会导致连续丢好多帧，造成视频的不连续，比如暂停一段时间后再恢复播放，这个值就需要更新</span></span><br><span class="line"></span><br><span class="line">SDL_LockMutex(is-&gt;pictq.mutex);</span><br><span class="line"><span class="keyword">if</span> (!isnan(vp-&gt;pts))<span class="comment">//使用当前帧的数据更新视频流时钟</span></span><br><span class="line">    update_video_pts(is, vp-&gt;pts, vp-&gt;pos, vp-&gt;serial);</span><br><span class="line">SDL_UnlockMutex(is-&gt;pictq.mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (frame_queue_nb_remaining(&amp;is-&gt;pictq) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Frame *nextvp = frame_queue_peek_next(&amp;is-&gt;pictq);</span><br><span class="line">        duration = vp_duration(is, vp, nextvp);<span class="comment">//当前帧的显示时长</span></span><br><span class="line">        <span class="keyword">if</span>(!is-&gt;step &amp;&amp; (framedrop&gt;<span class="number">0</span> || (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &amp;&amp; time &gt; is-&gt;frame_timer + duration)&#123;</span><br><span class="line">          is-&gt;frame_drops_late++;<span class="comment">//如果当前时间点晚于当前帧结束的时间点，就丢弃一帧，按照现实逻辑，其实丢弃的是上一帧</span></span><br><span class="line">          frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">          <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>丢帧的逻辑很简单，就是计算下一帧的结束时间，如果这个时间比当前系统时间还小，那就执行丢帧动作。</p><p>接下来我们再来分析AV_SYNC_VIDEO_MASTER的情况，从上面的两段函数中可以看出，当视频流为主时，每一帧的显示时间不需要修正，后面的丢帧动作也不会执行，此时视频流会按照自己的时钟播放。同样的，无论是否是视频流为主的情况，视频帧没解析一帧，都会更新视频流的时钟，并同步到外部时钟。</p><p>与视频流重复帧等待，丢帧追赶的逻辑相似，音频流是通过增减样本数的方式同步主时钟的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">synchronize_audio</span><span class="params">(VideoState *is, <span class="type">int</span> nb_samples)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> wanted_nb_samples = nb_samples;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* if not master, then we try to remove or add samples to correct the clock */</span></span><br><span class="line">  <span class="keyword">if</span> (get_master_sync_type(is) != AV_SYNC_AUDIO_MASTER) &#123;</span><br><span class="line">    <span class="type">double</span> diff, avg_diff;</span><br><span class="line">    <span class="type">int</span> min_nb_samples, max_nb_samples;</span><br><span class="line"></span><br><span class="line">    diff = get_clock(&amp;is-&gt;audclk) - get_master_clock(is);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">      is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef * is-&gt;audio_diff_cum;</span><br><span class="line">      <span class="keyword">if</span> (is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) &#123;</span><br><span class="line">        <span class="comment">/* not enough measures to have a correct estimate */</span></span><br><span class="line">        is-&gt;audio_diff_avg_count++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* estimate the A-V difference */</span></span><br><span class="line">        avg_diff = is-&gt;audio_diff_cum * (<span class="number">1.0</span> - is-&gt;audio_diff_avg_coef);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) &#123;</span><br><span class="line">          wanted_nb_samples = nb_samples + (<span class="type">int</span>)(diff * is-&gt;audio_src.freq);</span><br><span class="line">          min_nb_samples = ((nb_samples * (<span class="number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX) / <span class="number">100</span>));</span><br><span class="line">          max_nb_samples = ((nb_samples * (<span class="number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) / <span class="number">100</span>));</span><br><span class="line">          wanted_nb_samples = av_clip(wanted_nb_samples, min_nb_samples, max_nb_samples);</span><br><span class="line">        &#125;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_TRACE, <span class="string">&quot;diff=%f adiff=%f sample_diff=%d apts=%0.3f %f\n&quot;</span>,</span><br><span class="line">               diff, avg_diff, wanted_nb_samples - nb_samples,</span><br><span class="line">               is-&gt;audio_clock, is-&gt;audio_diff_threshold);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* too big difference : may be initial PTS errors, so</span></span><br><span class="line"><span class="comment">         reset A-V filter */</span></span><br><span class="line">      is-&gt;audio_diff_avg_count = <span class="number">0</span>;</span><br><span class="line">      is-&gt;audio_diff_cum       = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> wanted_nb_samples;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到，与视频同步每一帧都进行修正不同，音频流每AUDIO_DIFF_AVG_NB帧进行一次修正。AUDIO_DIFF_AVG_NB的默认值是20，对于每一帧，计算音频时钟和主时钟的差值，当没有达到20帧时，通过加权算法累计总的偏移量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef * is-&gt;audio_diff_cum;</span><br></pre></td></tr></table></figure><p>其中audio_diff_avg_coef是加权系数。</p><p>当累计20帧时，计算出平均偏移量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avg_diff = is-&gt;audio_diff_cum * (<span class="number">1.0</span> - is-&gt;audio_diff_avg_coef);</span><br></pre></td></tr></table></figure><p>然后根据这个偏移量与阈值的关系计算实际的样本数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) &#123;</span><br><span class="line">         wanted_nb_samples = nb_samples + (<span class="type">int</span>)(diff * is-&gt;audio_src.freq);</span><br><span class="line">         min_nb_samples = ((nb_samples * (<span class="number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX) / <span class="number">100</span>));</span><br><span class="line">         max_nb_samples = ((nb_samples * (<span class="number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) / <span class="number">100</span>));</span><br><span class="line">         wanted_nb_samples = av_clip(wanted_nb_samples, min_nb_samples, max_nb_samples);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>阈值audio_diff_threshold是硬件缓存样本容量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is-&gt;audio_diff_threshold = (<span class="type">double</span>)(is-&gt;audio_hw_buf_size) / is-&gt;audio_tgt.bytes_per_sec;</span><br></pre></td></tr></table></figure><p>计算样本数的逻辑其实神简单，只是计算平均偏移量的那个算法以及加权系数的选择我着实是无法理解，网上也搜不到相关的解释，希望有知道的朋友能不吝赐教。</p><p>现在就剩下最后一种AV_SYNC_EXTERNAL_CLOCK，其实从compute_target_delay和synchronize_audio代码中的判断条件我们很容易知道，两者都是使用不等式判断，而不是等式判断，所以我们就能推断出，同步外部时钟就是上述两种情况的结合，只不过这次的主时钟变成了外部时钟。不过有一点比较有意思的是，不论是音频流还是视频流，都会将外部时钟与自己的时钟同步，那么这种模式到底有什么用呢？我的理解是，这种模式相当于音视频流互相同步。回顾音视频处理数据的代码，将外部时钟与当前流时钟同步的操作都是在执行完同步算法之后。此时ffplay就认为当前流的时钟是同步的，更新外部时钟是为了消除剩下的一丁点”误差“。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程学习笔记：async()与thread对比</title>
      <link href="/2022/12/05/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Aasync()%E4%B8%8Ethread%E5%AF%B9%E6%AF%94/"/>
      <url>/2022/12/05/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Aasync()%E4%B8%8Ethread%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<p>通过std::thread类创建的线程，用户拥有最大的自由度，同时也需要承担相应的风险，我们先来看看使用std::thread创建线程后我们需要面临什么。</p><p>首先，通过非默认构造函数成功创建出线程对象后，我们必须保证在线程对象离开作用域被销毁之前对其调用join()或detach(),否则会造成程序终止。以join()为例，我们必须保证在任何情况下线程对象在销毁前都能调用join()函数，包括异常处理。这需要特别的细心以及不小的工作量，同时可能产生大量重复的代码。幸好C++的RAII机制可以减轻我们的负担，RAII是Resource Acquisition Is Initialization的缩写，即“资源获取即初始化”，是C++的一项技术，它将资源的获取放在类的构造函数中，资源的释放放在类的析构函数中，这样，资源的获取和释放就与类对象的生命周期绑定了，这样做可以有效的避免内存泄漏。我们可以将线程放入一个类中，然后将join放在类的析构函数中，这样只要离开了类实例的作用域，当类实例销毁时就会调用join()。一个简单的线程包裹类的实现如下所示：</p><p><code>class thread_guard&#123;</code><br>  <code>thread t;</code><br> <code>public:</code><br>  <code>explicit thread_guard(thread _t):t(std::move(_t))&#123;</code><br>    <code>if(!t.joinable())</code><br>      <code>throw std::logic_error(&quot;No thread&quot;);</code><br>  <code>&#125;</code><br>  <code>thread_guard(const thread_guard&amp;)=delete;</code><br>  <code>thread_guard&amp; operator=(const thread_guard&amp;)=delete;</code><br>  <code>~thread_guard()&#123;</code><br>    <code>t.join();</code><br>  <code>&#125;</code><br><code>&#125;;</code></p><p>我们先来看不使用包裹类的时候我们应该怎样写：</p><p><code>int func()&#123;</code><br>  <code>throw logic_error(&quot;error&quot;);</code><br><code>&#125;</code><br><code>int main()&#123;</code><br>  <code>std::thread t(print_once);</code><br>  <code>try&#123;</code><br>    <code>func();</code><br>    <code>t.join();</code><br>  <code>&#125;catch (exception &amp;e)&#123;</code><br>    <code>cout&lt;&lt;e.what()&lt;&lt;endl;</code><br>    <code>t.join();</code><br>    <code>return -1;</code><br>  <code>&#125;</code><br>  <code>return 0;</code><br><code>&#125;</code></p><p>我们用func()函数模拟异常，可以看到t.join()出现在了两处地方，如果func()不只会抛出一个异常，或者有多个类似func()这样会抛出异常的函数，我们就需要在每个异常处理的代码块中调用t.join()，一不小心漏掉一个就会导致程序的异常退出，而这种错误往往不是那么容易发现，因为测试的时候可能无法模拟所有异常的场景。而使用thread_guard后，代码就会变得很简单：</p><p><code>int main()&#123;</code><br>  <code>thread_guard(std::thread(print_once));</code><br>  <code>try&#123;</code><br>    <code>func();</code><br>  <code>&#125;catch (exception &amp;e)&#123;</code><br>    <code>cout&lt;&lt;e.what()&lt;&lt;endl;</code><br>    <code>return -1;</code><br>  <code>&#125;</code><br>  <code>return 0;</code><br><code>&#125;</code></p><p>线程的join()交给运行时环境去处理，不论是从任何正常逻辑退出程序还是发生了任何异常，只要离开了thread_guard对象的作用域，就会对线程对象调用join()。detach()的操作也可以使用类似的方式，不过detach()由于分离线程，所以一般在创建了线程对象后直接调用，所以不太需要用到这种方式。</p><p>现在我们已经不用担心因为线程没有被join或detach而导致程序异常退出了，我们创建了一个线程去执行我们的计算函数，然后就可以一遍做其他事情一遍等线程执行结束获取计算结果了。等等！我们怎么获取计算结果？std::thread只负责帮我们创建线程，但是线程执行结束后的返回值我们怎么获取呢？没有一个方法可以帮我们获取任务函数的返回值！所以只能靠我们自己在函数执行结束后将结果写入共享内存中，那我们就需要使用锁来避免数据竞争，无形中又增加了代码量。如果在我们的任务函数的执行过程中产生了异常，我们还需要确保异常在线程中被处理，如果任务函数直接抛出异常，异常不但不会被传递到线程外，还会导致线程终止，从而导致整个程序异常终止。我们又增加了一些代码来处理异常：（，这些事情都做完了，没有其他的事情需要操心了吧？</p><p>更棘手的还在后面，我们将系统层面的线程称作软件线程，将CPU实际执行计算时使用的线程叫做硬件线程。而软件线程的资源是有限的，如果我们新建线程的时候软件线程的数量达到了系统限制的最大数量，那么就会创建失败并抛出std::system_error异常，而且这个异常是强制抛出的，即便你使用了noexcept修饰词。处理这种情况我们要么等待其他线程执行结束释放资源，这也是靠运气的，万一其他线程也在等待这个新建线程的执行结果呢：），要么直接将任务安排在当前线程完成，但如果当前线程是个GUI线程，这种做法会导致界面未响应的问题。</p><p>好，我增加硬件，修改系统参数，调大软件线程的最大数量，把软件线程资源用尽的可能性降到最低，是不是就没问题了呢？不是！即便软件线程的数量是无限的，但是硬件线程的数量终究是有限的，那么当就绪状态的软件线程的数量超过了硬件线程的数量，这时就会发生超订（oversubscription）。线程调度器会为每一个就绪的线程在cpu上分配时间片，当一个线程的时间片结束，另一个线程的时间片开始时，就会发生上下文的切换，这种切换会增加系统开销，尤其是同一个线程的两个相邻的时间片在不同的CPU内核上执行时，上一个时间片缓存的数据全部作废，这个时间片的数据需要重新写入现在这个核的缓存，写入的时候很可能还会覆盖掉其他线程未使用的缓存数据，那么其他线程下一个时间片时就要重新写入数据。避免超订是很困难的一件事，即使你可以在软件层面尽可能的进行优化，但是不同cpu的硬件线程数和缓存也不一样，你不可能照顾到所有情况。而且厉害到可以优化线程调度器的大佬估计也不会看这篇文章：）。</p><p>可能很多体量很小的程序极少遇到上面说的那些情况，但是人总是要进步的，你不可能永远只维护那么几百行代码两三个线程的小程序，问题总是要解决的。那么这么多难题摆在面前，我们该从哪里开始着手解决呢？当然是把问题交给更厉害的人去解决呀：）。std::async()就是我们最容易找到的更厉害的那个”人“。使用std::async()创建异步任务，我们不需要担心线程join和detach的事情，而且我们还能从返回值future中获取到任务函数的返回值以及任务函数执行中发生的异常信息，并且即使发生了异常，也只是异常所在的线程终止，并不会导致整个程序的终止。虽然仍旧无法完全避免超订，但是将线程的调度交给运行时调度器去做大多数情况下会比程序员自己做的更好，因为运行时调度器管理着所有进程中的线程，它会比人更清楚硬件的使用情况，从而做出最优的选择，如果系统线程耗尽了或者发生了超订，std::async()可以选择让任务函数在当前线程中执行，或者延后执行。使用std::async()并不会使线程耗尽或者超订的问题消失，只是将这种情况的处理从程序员的手中接管过去并且利用自身对全局的掌握选择当前的最优解，如果这些事都交给程序员去解决，很可能还会导致负载均衡的问题。并且随着标准库的发展，更好的线程调度算法会被应用，如果程序使用std::async()管理线程，到时候会自动从这些发展中受益。如果不是有着非使用std::thread不可的原因，干嘛不用std::async()呢？</p><p>非使用std::thread不可的原因来了，C++的并发库是基于不同平台的底层API实现的，如windows的线程库和POSIX的线程库pthread。当我们需要使用一些C++并发库没有提供的功能时（如线程优先级），就需要用到底层API，相应的我们需要获得底层平台的线程句柄，std::thread类的native_handle成员函数就可以实现这一操作，而future是没有类似功能的。还有一种情况是你需要对你的线程有绝对的掌控，一般是针对特定的硬件环境开发的专属程序，或者你想自己实现一个线程池。</p><p>参考书目：《Effective.Modern.C++》、《C++Concurrency in Action 2nd Edition》、《C++标准库第二版》、《Primer C++ 第五版》</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程学习笔记：使用std::thread类创建线程</title>
      <link href="/2022/12/05/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8thread%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/12/05/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BD%BF%E7%94%A8thread%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>自C++11开始，标准库增加了多线程的支持，使用标准库创建线程有两种方式：</p><p>1.使用std::thread类创建线程实例</p><p>2.使用std::async函数创建异步任务</p><p>我们先从第一种开始介绍。无论是哪种创建方式，C++支持的可调用类型都可以作为参数传入，例如函数，函数指针，函数对象，lambda表达式，bind创建的对象以及function类型等。我们先准备几个可调用对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_per_second</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;hello world from thread：&quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>()&lt;&lt;endl;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_once</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;hello world from thread： &quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>()&lt;&lt;endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;hello world from thread：&quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>()&lt;&lt;endl;</span><br><span class="line">      this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两个print函数和一个重载了函数调用运算符的类，函数和重载的函数调用运算符执行的操作也很简单，只是输出一行带有线程id的信息，get_id是命名空间this_thread提供的一个全局函数，作用是返回当前线程的id。</p><p>现在我们创建第一个线程，创建方式也很简单，我们使用print_once的函数名作为阐述传给std::thread的构造函数就能得到一个线程实例，并且实例创建完成后，线程自动开始运行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(print_once)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行这段代码，发现并没有按照我们预期运行，反而是被终止了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libc++abi: terminating</span><br><span class="line">信号: SIGABRT (signal SIGABRT)</span><br></pre></td></tr></table></figure><p>产生这种错误的原因是C++标准规定，线程对象在销毁前一定要调用join()或detach()，否则会导致程序被终止（terminated）调用join()会使程序阻塞在调用点直到线程执行结束，相当于等待线程完成；调用detach()则是将线程与主线程分离，分离后的线程会独自运行直到线程调用的函数返回或主程序退出。</p><p>对于一个线程实例只能调用一次join()或detach()，多次调用会导致程序抛出异常。为了判断线程对象是否可以调用join()或detach()，标准库提供了一个joinable()函数返回一个表示线程对象joinable状态的bool值。当joinable()的返回值为true时，才可以对线程对象调用join()或detach();</p><p>我们修改刚才的代码，在主线程中等待t1结束：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(print_once)</span></span>;</span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样代码就正常运行了，当然这里也可以调用detach()，只不过这样一来，如果print_once执行的是某种耗时操作，例如等待几秒后再打印信息，那么在程序退出之前，该信息就无法打印出来了。</p><p>还有一点需要注意的是标准规定的是在线程对象销毁之前一定要对其调用join()或detach()，这就可能造成一个比较有意思的现象，看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(print_once)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(print_per_second)</span></span>;</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码只对t2调用了join()，但是对t1却没有调用，这段代码编译运行后并没有报错。原因是t2线程执行的函数是一个无限循环的函数，主线程会一直等待在t2.join()这个调用点不退出，所以t1就是始终在作用域，不会被销毁，所以也不会因为没有对其调用join()而导致程序终止。想要验证这一点也很简单，只需要将t2.join()改成t2.detach()即可。t2线程被分离，主线程不等待t2结束直接退出，t1在离开作用域之前没有调用join()或detach()，导致程序异常退出。代码比较简单，就不展示了。</p><p>另外一点需要注意的是使用std::thread默认构造函数创建的对象是unjoinable的，也就是说使用如下代码创建的线程对象不能调用join()或detach()，否则程序会抛出异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::thread t1;</span><br></pre></td></tr></table></figure><p>在上面的例子中我们已经使用print_once和print_per_second函数名作为参数传递给std::thread的构造函数创建出了线程对象，使用函数名作为参数会默认传递函数的指针。一开始我们已经说过，std::thread的构造函数可以接受所有可调用对象作为参数，所以作为重载了函数调用运算符的类的实例自然也可以作为参数传递给std::thread以构造线程对象，具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Task task;</span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(task)</span></span>;</span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们也可以使用匿名对象作为参数，不过这种情况需要注意，使用下面的写法是不行的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(Task())</span></span>;</span><br></pre></td></tr></table></figure><p>这种写法会让编译器认为这是一个函数声明，该函数的参数为一个没有参数且返回Task类型队形的函数指针，函数返回一个std::thread类型的对象。为了让编译器认为这是线程实例的初始化而不是一个函数声明，可以使用下面两种写法中的一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">((Task()))</span></span>;</span><br><span class="line">std::thread t1&#123;<span class="built_in">Task</span>()&#125;;</span><br></pre></td></tr></table></figure><p>第一种写法是在外面多加一个括号，阻止将改行代码解释为函数声明；第二种写法是利用统一初始化语法完成实例的创建。</p><p>C++11新增了对lambda表达式的支持，编译器在解释lambda表达式时，会将其翻译成一个匿名类的匿名对象，该匿名类中含所有一个重载的函数调用运算符，所以lambda表达式也可以作为参数传递给线程的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">([]()&#123;cout&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;endl;&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>C++11新增了一个function模板，可以用来存储任何可调用对象，相应的，具体的function类型也是可调用对象，也可以作为线程构造函数的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">void</span>()&gt; func = print_once;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br></pre></td></tr></table></figure><p>函数模板bind也返回一个可调用对象，也可以作为线程构造函数的参数，代码就不写了，有兴趣的可以自行了解。</p><p>参考书目：《Effective.Modern.C++》、《C++Concurrency in Action 2nd Edition》、《C++标准库第二版》、《Primer C++ 第五版》</p>]]></content>
      
      
      <categories>
          
          <category> C++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（七）：视频播放</title>
      <link href="/2022/12/04/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/"/>
      <url>/2022/12/04/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<p>在分析读线程的时候我们已经知道ffplay音频流的播放是通过SDL音频播放回调函数获取数据写入设备从而达到播放目的的，另外SDL音频的播放大部分情况下是在单独的线程中完成的。与之相对的，音频流和字幕流的播放则在主线程中完成。ffplay在event_loop()函数中完成画面显示和事件处理的工作。</p><p>event_loop函数只有一个无限for循环，按照功能可以划分为两部分：1.SDL事件处理；2.视频流和字幕流显示。本章我们先介绍视频流和字幕流的显示。event_loop函数的for循环每次都调用一个叫做refresh_loop_wait_event函数，函数代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">refresh_loop_wait_event</span><span class="params">(VideoState *is, SDL_Event *event)</span> &#123;</span><br><span class="line">  <span class="type">double</span> remaining_time = <span class="number">0.0</span>;<span class="comment">//当前帧剩余的显示时间</span></span><br><span class="line">  SDL_PumpEvents();</span><br><span class="line">  <span class="keyword">while</span> (!SDL_PeepEvents(event, <span class="number">1</span>, SDL_GETEVENT, SDL_FIRSTEVENT, SDL_LASTEVENT)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cursor_hidden &amp;&amp; av_gettime_relative() - cursor_last_shown &gt; CURSOR_HIDE_DELAY) &#123;</span><br><span class="line">      SDL_ShowCursor(<span class="number">0</span>);</span><br><span class="line">      cursor_hidden = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (remaining_time &gt; <span class="number">0.0</span>)</span><br><span class="line">      av_usleep((<span class="type">int64_t</span>)(remaining_time * <span class="number">1000000.0</span>));<span class="comment">//当前帧剩余显示时间结束再开始下一帧的显示</span></span><br><span class="line">    remaining_time = REFRESH_RATE;<span class="comment">//初始值为0.01秒</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;show_mode != SHOW_MODE_NONE &amp;&amp; (!is-&gt;paused || is-&gt;force_refresh))</span><br><span class="line">      video_refresh(is, &amp;remaining_time);</span><br><span class="line">    SDL_PumpEvents();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了便于理解我们先简单介绍一下SDL的事件框架原理，SDL库维护一个事件队列，当有新的事件如键盘输入或鼠标事件等到达时，通过调用SDL_PumpEvents()函数可以将这些事件收集起来放入事件队列。当用户想要处理事件时，可以调用SDL_PeepEvents()并设置SDL_GETEVENT标志位从事件队列中获取事件，该函数的返回值为获取到的事件数。SDL还有通过SDL_PollEvent()函数获取事件的方式，不在本文的讨论范围。</p><p>了解了SDL事件原理，我们再来分析代码就很容易理解了，while循环不断从事件队列中读取事件，一旦读取到事件，循环就会退出，接着函数返回到event_loop，进行接下来对具体sdl事件的处理。如果当前事件队列中没有事件，就调用video_refresh()显示一帧画面，该函数的第二个参数是一个double类型变量的指针，这是一个in-out类型的参数，变量的值用来存储当前帧剩余的显示时间。video_refresh函数的主要功能可以分为两步，针对音频的图形化显示以及针对视频和字幕的显示，两者最后都是调用video_display()函数。对音频流的处理比较简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!display_disable &amp;&amp; is-&gt;show_mode != SHOW_MODE_VIDEO &amp;&amp; is-&gt;audio_st) &#123;</span><br><span class="line">    time = av_gettime_relative() / <span class="number">1000000.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;force_refresh || is-&gt;last_vis_time + rdftspeed &lt; time) &#123;</span><br><span class="line">      video_display(is);</span><br><span class="line">      is-&gt;last_vis_time = time;</span><br><span class="line">    &#125;</span><br><span class="line">    *remaining_time = FFMIN(*remaining_time, is-&gt;last_vis_time + rdftspeed - time);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>视频流的处理则较为复杂，涉及到帧的重复和跳帧操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is-&gt;video_st) &#123;</span><br><span class="line">   retry:</span><br><span class="line">   <span class="keyword">if</span> (frame_queue_nb_remaining(&amp;is-&gt;pictq) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// nothing to do, no picture to display in the queue</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="type">double</span> last_duration, duration, delay;</span><br><span class="line">     Frame *vp, *lastvp;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* dequeue the picture */</span></span><br><span class="line">     lastvp = frame_queue_peek_last(&amp;is-&gt;pictq);<span class="comment">//获取上一帧</span></span><br><span class="line">     vp = frame_queue_peek(&amp;is-&gt;pictq);<span class="comment">//获取当前帧</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (vp-&gt;serial != is-&gt;videoq.serial) &#123;<span class="comment">//如果当前视频帧内容跟视频队列中最新的内容不连续，舍弃当前帧重新读</span></span><br><span class="line">       frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">       <span class="keyword">goto</span> retry;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (lastvp-&gt;serial != vp-&gt;serial)<span class="comment">//如果上一帧跟当前帧不是连续内容，将帧计时器调整为当前时间，表示重新开始计时</span></span><br><span class="line">       is-&gt;frame_timer = av_gettime_relative() / <span class="number">1000000.0</span>;<span class="comment">//帧计时器，用于一段连续的帧数据，每当开始一段新的帧数据时，设置为当前时间点。</span></span><br><span class="line">     <span class="keyword">if</span> (is-&gt;paused)</span><br><span class="line">       <span class="keyword">goto</span> display;<span class="comment">//display显示的其实是&quot;上一帧数据&quot;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/* compute nominal last_duration */</span></span><br><span class="line">     last_duration = vp_duration(is, lastvp, vp);<span class="comment">//通过pts计算上一帧的持续时间</span></span><br><span class="line">     delay = compute_target_delay(last_duration, is);<span class="comment">//根据上一帧的显示时长计算一个延时，这个时间是上一帧真正的显示时间</span></span><br><span class="line"></span><br><span class="line">     time= av_gettime_relative()/<span class="number">1000000.0</span>;<span class="comment">//当前系统时间</span></span><br><span class="line">     <span class="keyword">if</span> (time &lt; is-&gt;frame_timer + delay) &#123;<span class="comment">//还在上一帧的显示时间段，显示上一帧</span></span><br><span class="line">       *remaining_time = FFMIN(is-&gt;frame_timer + delay - time, *remaining_time);</span><br><span class="line">       <span class="keyword">goto</span> display;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     is-&gt;frame_timer += delay;<span class="comment">//上述条件未满足，先将timer设置为上一帧结束的时间，这个值现在表示的是当前帧的显示时间</span></span><br><span class="line">     <span class="keyword">if</span> (delay &gt; <span class="number">0</span> &amp;&amp; time - is-&gt;frame_timer &gt; AV_SYNC_THRESHOLD_MAX)<span class="comment">//如果跟当前时间差超过时间同步最大阈值，将时间点设置为当前时间</span></span><br><span class="line">       is-&gt;frame_timer = time;<span class="comment">//如果不执行这一步，结果就是连续好多帧的结束时间都会小于当前时间点，如果设置可以丢帧，就会导致连续丢好多帧，造成视频的不连续，比如暂停一段时间后再恢复播放，这个值就需要更新</span></span><br><span class="line"></span><br><span class="line">     SDL_LockMutex(is-&gt;pictq.mutex);</span><br><span class="line">     <span class="keyword">if</span> (!isnan(vp-&gt;pts))<span class="comment">//使用当前帧的数据更新视频流时钟</span></span><br><span class="line">       update_video_pts(is, vp-&gt;pts, vp-&gt;pos, vp-&gt;serial);</span><br><span class="line">     SDL_UnlockMutex(is-&gt;pictq.mutex);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (frame_queue_nb_remaining(&amp;is-&gt;pictq) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">       Frame *nextvp = frame_queue_peek_next(&amp;is-&gt;pictq);</span><br><span class="line">       duration = vp_duration(is, vp, nextvp);<span class="comment">//当前帧的显示时长</span></span><br><span class="line">       <span class="keyword">if</span>(!is-&gt;step &amp;&amp; (framedrop&gt;<span class="number">0</span> || (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &amp;&amp; time &gt; is-&gt;frame_timer + duration)&#123;</span><br><span class="line">         is-&gt;frame_drops_late++;<span class="comment">//如果当前时间点晚于当前帧结束的时间点，就丢弃一帧，按照现实逻辑，其实丢弃的是上一帧</span></span><br><span class="line">         frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">         <span class="keyword">goto</span> retry;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (is-&gt;subtitle_st) &#123;<span class="comment">//如果当前时间点已经超过了字幕帧数据的结束时间点，清除字幕画面</span></span><br><span class="line">       <span class="keyword">while</span> (frame_queue_nb_remaining(&amp;is-&gt;subpq) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         sp = frame_queue_peek(&amp;is-&gt;subpq);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (frame_queue_nb_remaining(&amp;is-&gt;subpq) &gt; <span class="number">1</span>)</span><br><span class="line">           sp2 = frame_queue_peek_next(&amp;is-&gt;subpq);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           sp2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (sp-&gt;serial != is-&gt;subtitleq.serial</span><br><span class="line">             || (is-&gt;vidclk.pts &gt; (sp-&gt;pts + ((<span class="type">float</span>) sp-&gt;sub.end_display_time / <span class="number">1000</span>)))</span><br><span class="line">             || (sp2 &amp;&amp; is-&gt;vidclk.pts &gt; (sp2-&gt;pts + ((<span class="type">float</span>) sp2-&gt;sub.start_display_time / <span class="number">1000</span>))))</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="keyword">if</span> (sp-&gt;uploaded) &#123;</span><br><span class="line">             <span class="type">int</span> i;</span><br><span class="line">             <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sp-&gt;sub.num_rects; i++) &#123;</span><br><span class="line">               AVSubtitleRect *sub_rect = sp-&gt;sub.rects[i];</span><br><span class="line">               <span class="type">uint8_t</span> *pixels;</span><br><span class="line">               <span class="type">int</span> pitch, j;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!SDL_LockTexture(is-&gt;sub_texture, (SDL_Rect *)sub_rect, (<span class="type">void</span> **)&amp;pixels, &amp;pitch)) &#123;</span><br><span class="line">                 <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; sub_rect-&gt;h; j++, pixels += pitch)</span><br><span class="line">                   <span class="built_in">memset</span>(pixels, <span class="number">0</span>, sub_rect-&gt;w &lt;&lt; <span class="number">2</span>);</span><br><span class="line">                 SDL_UnlockTexture(is-&gt;sub_texture);</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           frame_queue_next(&amp;is-&gt;subpq);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">     is-&gt;force_refresh = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (is-&gt;step &amp;&amp; !is-&gt;paused)</span><br><span class="line">       stream_toggle_pause(is);</span><br><span class="line">   &#125;</span><br><span class="line">   display:</span><br><span class="line">   <span class="comment">/* display picture */</span></span><br><span class="line">   <span class="keyword">if</span> (!display_disable &amp;&amp; is-&gt;force_refresh &amp;&amp; is-&gt;show_mode == SHOW_MODE_VIDEO &amp;&amp; is-&gt;pictq.rindex_shown)</span><br><span class="line">     video_display(is);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码中有一个关键函数computer_target_delay()用于计算一帧画面实际的显示时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">double</span> <span class="title function_">compute_target_delay</span><span class="params">(<span class="type">double</span> delay, VideoState *is)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> sync_threshold, diff = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* update delay to follow master synchronisation source */</span></span><br><span class="line">  <span class="keyword">if</span> (get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER) &#123;</span><br><span class="line">    <span class="comment">/* if video is slave, we try to correct big delays by</span></span><br><span class="line"><span class="comment">       duplicating or deleting a frame */</span></span><br><span class="line">    <span class="comment">//如果不是音频同步视频，通过复制帧或者丢帧来修正延时</span></span><br><span class="line">    diff = get_clock(&amp;is-&gt;vidclk) - get_master_clock(is);<span class="comment">//视频流是时钟和主时钟的差值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* skip or repeat frame. We take into account the</span></span><br><span class="line"><span class="comment">       delay to compute the threshold. I still don&#x27;t know</span></span><br><span class="line"><span class="comment">       if it is the best guess */</span></span><br><span class="line">    sync_threshold = FFMAX(AV_SYNC_THRESHOLD_MIN, FFMIN(AV_SYNC_THRESHOLD_MAX, delay));<span class="comment">//算一个时间差阈值，如果delay在最大和最小阈值范围内，取delay，过大了，去最大阈值，过小了取最小阈值</span></span><br><span class="line">    <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; is-&gt;max_frame_duration) &#123;</span><br><span class="line">      <span class="keyword">if</span> (diff &lt;= -sync_threshold)<span class="comment">//视频流慢太多了，delay需要减小，最小为0，这样下一帧能更快显示（跳帧）</span></span><br><span class="line">        delay = FFMAX(<span class="number">0</span>, delay + diff);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold &amp;&amp; delay &gt; AV_SYNC_FRAMEDUP_THRESHOLD)<span class="comment">//（重复帧）</span></span><br><span class="line">        delay = delay + diff;<span class="comment">//视频流快太多了，并且延时超过了复制一帧的最大阈值。这个阈值的意思是，如果上一帧的持续时间超过了这个值，就不应该通过重复帧来进行同步</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold)</span><br><span class="line">        delay = <span class="number">2</span> * delay;<span class="comment">//视频流快太多，并且延迟没超过复制一帧的最大阈值，就将延迟增加一倍。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  av_log(<span class="literal">NULL</span>, AV_LOG_TRACE, <span class="string">&quot;video: delay=%0.3f A-V=%f\n&quot;</span>,</span><br><span class="line">         delay, -diff);</span><br><span class="line">  <span class="keyword">return</span> delay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里计算实际延时的算法中已经涉及到了音视频同步，函数中对于当前帧延时的重新计算是在视频同步音频或音视频同步外部时钟的前提下生效的。delay的值直接影响后续的丢帧操作。</p><p>音视频流画面的实际显示工作通过调用video_display函数完成，函数最终通过调用video_audio_display和video_image_display完成显示工作。video_image_display函数完成视频以及字幕的显示，使用SDL库函数完成画面的渲染，其中也涉及到了ffmpeg图像格式到sdl支持的图像格式的转换，sdl库的使用不在本文的讨论范围，这里就不展开分析了。video_audio_display函数负责音频流波形图和频域图的显示，算法暂时没看懂，对理解ffplay原理帮助也不大，后面有时间再回头分析。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（六）：解码线程</title>
      <link href="/2022/12/02/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E8%A7%A3%E7%A0%81%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/12/02/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E8%A7%A3%E7%A0%81%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>ffplay的音频流、视频流和字幕流的解码工作通过三个解码线程完成，解码线程通过decoder_start函数开启，分别调用audio_thread,video_thread,subtitle_thread三个函数，接下来我们逐个分析。</p><p>作为参考，先放上Decoder结构体中各个字段的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Decoder</span> &#123;</span></span><br><span class="line">  AVPacket *pkt;<span class="comment">//用于存储压缩数据</span></span><br><span class="line">  PacketQueue *<span class="built_in">queue</span>;<span class="comment">//关联的包队列</span></span><br><span class="line">  AVCodecContext *avctx;<span class="comment">//解码器上下文</span></span><br><span class="line">  <span class="type">int</span> pkt_serial;<span class="comment">//包的序列号</span></span><br><span class="line">  <span class="type">int</span> finished;<span class="comment">//当解码到流末尾时，这个值被设置为包序列号</span></span><br><span class="line">  <span class="type">int</span> packet_pending;<span class="comment">//当前解码器中有未决的包</span></span><br><span class="line">  SDL_cond *empty_queue_cond;<span class="comment">//读写同步的条件变量，等于VideoState中的continue_read_thread</span></span><br><span class="line">  <span class="type">int64_t</span> start_pts;<span class="comment">//流开始的时间</span></span><br><span class="line">  AVRational start_pts_tb;<span class="comment">//流的time_base</span></span><br><span class="line">  <span class="type">int64_t</span> next_pts;<span class="comment">//通过当前帧的pts和duration计算出的下一帧的pts，作为备份</span></span><br><span class="line">  AVRational next_pts_tb;<span class="comment">//下一帧的time_base，使用的是当前帧的time_base</span></span><br><span class="line">  SDL_Thread *decoder_tid;<span class="comment">//解码线程id</span></span><br><span class="line">&#125; Decoder;</span><br></pre></td></tr></table></figure><p>有四个相关的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">decoder_init</span><span class="params">(Decoder *d, AVCodecContext *avctx, PacketQueue *<span class="built_in">queue</span>, SDL_cond *empty_queue_cond)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">decoder_abort</span><span class="params">(Decoder *d, FrameQueue *fq)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">decoder_destory</span><span class="params">(Decoder *d)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">decoder_decode_frame</span><span class="params">(Decoder *d, AVFrame *frame, AVSubtitle *sub)</span>;</span><br></pre></td></tr></table></figure><p>前三个函数比较简单，不再展开分析，最后一个函数稍后会重点分析。</p><p>首先是音频解码函数audio_thread，去除滤镜处理的相关代码，函数代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">audio_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  VideoState *is = arg;</span><br><span class="line">  AVFrame *frame = av_frame_alloc();</span><br><span class="line">  Frame *af;</span><br><span class="line">  <span class="type">int</span> got_frame = <span class="number">0</span>;</span><br><span class="line">  AVRational tb;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!frame)</span><br><span class="line">    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((got_frame = decoder_decode_frame(&amp;is-&gt;auddec, frame, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> the_end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (got_frame) &#123;</span><br><span class="line">      tb = (AVRational)&#123;<span class="number">1</span>, frame-&gt;sample_rate&#125;;</span><br><span class="line">       <span class="keyword">if</span> (!(af = frame_queue_peek_writable(&amp;is-&gt;sampq)))</span><br><span class="line">          <span class="keyword">goto</span> the_end;</span><br><span class="line"></span><br><span class="line">        af-&gt;pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);</span><br><span class="line">        af-&gt;pos = frame-&gt;pkt_pos;</span><br><span class="line">        af-&gt;serial = is-&gt;auddec.pkt_serial;</span><br><span class="line">        af-&gt;duration = av_q2d((AVRational)&#123;frame-&gt;nb_samples, frame-&gt;sample_rate&#125;);</span><br><span class="line"></span><br><span class="line">        av_frame_move_ref(af-&gt;frame, frame);</span><br><span class="line">        frame_queue_push(&amp;is-&gt;sampq);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (ret &gt;= <span class="number">0</span> || ret == AVERROR(EAGAIN) || ret == AVERROR_EOF);</span><br><span class="line">  the_end:</span><br><span class="line">  av_frame_free(&amp;frame);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑十分直观，在一个do-while循环中调用decocer_decode_frame()活的解码后的数据，存入一个AVFrame中，然后从FrameQueue中获取一个指向可写位置的指针af，将AVFrame中的数据写入af对应的字段，最后调用frame_queue_push移动FrameQueue的写指针。由于我们屏蔽掉了滤镜相关的函数，所以while的循环条件看起来有点奇怪，不过效果是一样的，在没有配置滤镜功能时就是一个简单的无线循环。</p><p>我们再来看一下视频解码线程video_thread，精简掉滤镜相关的代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">video_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  VideoState *is = arg;</span><br><span class="line">  AVFrame *frame = av_frame_alloc();</span><br><span class="line">  <span class="type">double</span> pts;</span><br><span class="line">  <span class="type">double</span> duration;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  AVRational tb = is-&gt;video_st-&gt;time_base;</span><br><span class="line">  AVRational frame_rate = av_guess_frame_rate(is-&gt;ic, is-&gt;video_st, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (!frame)</span><br><span class="line">    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    ret = get_video_frame(is, frame);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> the_end;</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">      duration = (frame_rate.num &amp;&amp; frame_rate.den ? av_q2d((AVRational)&#123;frame_rate.den, frame_rate.num&#125;) : <span class="number">0</span>);</span><br><span class="line">      pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);</span><br><span class="line">      ret = queue_picture(is, frame, pts, duration, frame-&gt;pkt_pos, is-&gt;viddec.pkt_serial);</span><br><span class="line">      av_frame_unref(frame);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> the_end;</span><br><span class="line">  &#125;</span><br><span class="line">  the_end:</span><br><span class="line">  av_frame_free(&amp;frame);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与音频不同，视频解码线程的处理函数将解码视频帧和将视频帧放入队列这两个步骤封装在了get_video_frame和</p><p>queue_picture两个函数中。我们先来看get_video_fream的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_video_frame</span><span class="params">(VideoState *is, AVFrame *frame)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> got_picture;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((got_picture = decoder_decode_frame(&amp;is-&gt;viddec, frame, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (got_picture) &#123;</span><br><span class="line">    <span class="type">double</span> dpts = NAN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE)</span><br><span class="line">      dpts = av_q2d(is-&gt;video_st-&gt;time_base) * frame-&gt;pts;</span><br><span class="line"></span><br><span class="line">    frame-&gt;sample_aspect_ratio = av_guess_sample_aspect_ratio(is-&gt;ic, is-&gt;video_st, frame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (framedrop&gt;<span class="number">0</span> || (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">        <span class="type">double</span> diff = dpts - get_master_clock(is);</span><br><span class="line">        <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD &amp;&amp;</span><br><span class="line">            diff - is-&gt;frame_last_filter_delay &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            is-&gt;viddec.pkt_serial == is-&gt;vidclk.serial &amp;&amp;</span><br><span class="line">            is-&gt;videoq.nb_packets) &#123;</span><br><span class="line">          is-&gt;frame_drops_early++;</span><br><span class="line">          av_frame_unref(frame);</span><br><span class="line">          got_picture = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> got_picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到获取到解码后的帧数据后，video_thread还额外加入了一个丢帧逻辑。framedrop如果用户不设置，那么默认值就是-1，用户设置后会有0和1两种情况。所以上面的条件的意思是当用户设置可以丢帧或者用户没设置这个参数但是当前的同步逻辑不是音频同步视频，就可以丢帧。ffplay的时间同步逻辑有三个选项：视频同步音频（AV_SYNC_AUDIO_MASTER），音频同步视频（AV_SYNC_VIDEO_MASTER），音视频同步外部时钟（AV_SYNC_EXTERNAL_CLOCK）。那么当程序允许丢帧时，什么时候才可以丢弃当前帧呢？程序首先计算了当前帧的显示时间点和主时钟的时间差diff，如果这个时间差还在可同步范围内，也就是小于AV_NOSYNC_THRESHOLD才进行接下来的判断。接下来判断diff是否小于上一帧的延时，frame_last_filter_delay，上一帧如果经过滤镜处理，会消耗额外的时间，这个时间计算出来被存入frame_last_filter_delay，如果diff小于这个值，说明当延时时间结束后，当前帧的显示时间点就已经过了，此时判断如果包序列号与时钟序列号是否相同，这里是为了保证在内容连续时才可丢帧；最后判断视频流包队列中如果还有包，则表示后续还有可显示的内容，那么当前帧就可以丢弃。所有条件满足后，丢帧数加一，释放当前帧的数据，将got_picture设置为0返回。这里是在解码成功放入FrameQueue之前丢帧的，所以对frame_drops_early增加一个计数，后面我们还会看到显示画面时的丢帧，那种情况是对frame_drops_late增加计数。</p><p>queue_picture函数的作用就是将数据放入FrameQueue，这里就不上代码了，单独抽离成一个函数可能只是因为需要设置的参数比较多，为了代码好看一点吧：）。</p><p>字幕流的解码线程subtitle_thread的实现更加简单，就是在一个无限循环中读取帧，然后将数据放入FrameQueue的合适位置；</p><p>到现在为止，还有有一个关键的函数我们还没有展开分析，就是decoder_decode_frame，这个函数用于从PacketQueue中读取包然后解码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">decoder_decode_frame</span><span class="params">(Decoder *d, AVFrame *frame, AVSubtitle *sub)</span> &#123;</span><br><span class="line">  <span class="type">int</span> ret = AVERROR(EAGAIN);</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">//音视频流解码</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//从PacketQueue中读包</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//字幕流解码</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数中有一个无限循环，循环中的代码按照任务划分可以分为三部分：1.音视频流解码；2.从PacketQueue中读包；3.字幕流解码。</p><p>音视频流的解码和字幕流的解码没有放在一起，是因为字幕流的解码方式与音视频流不同。我们先看音视频流的解码流程:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//音视频流解码</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;serial == d-&gt;pkt_serial) &#123;<span class="comment">//当前包的序列号与解码器中注册的包队列序列号一致时（内容连续）才进行解码</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;abort_request)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (d-&gt;avctx-&gt;codec_type) &#123;</span><br><span class="line">          <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">            ret = avcodec_receive_frame(d-&gt;avctx, frame);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (decoder_reorder_pts == <span class="number">-1</span>) &#123;<span class="comment">//解码器对pts重新排序，0表示关，1表示开，-1表示自动</span></span><br><span class="line">                frame-&gt;pts = frame-&gt;best_effort_timestamp;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!decoder_reorder_pts) &#123;</span><br><span class="line">                frame-&gt;pts = frame-&gt;pkt_dts;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">            ret = avcodec_receive_frame(d-&gt;avctx, frame);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              AVRational tb = (AVRational)&#123;<span class="number">1</span>, frame-&gt;sample_rate&#125;;<span class="comment">//计算音频流的time_base</span></span><br><span class="line">              <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE)</span><br><span class="line">                frame-&gt;pts = av_rescale_q(frame-&gt;pts, d-&gt;avctx-&gt;pkt_timebase, tb);</span><br><span class="line">              <span class="comment">//转换time_base,按照播放时time_base重新计算pts</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (d-&gt;next_pts != AV_NOPTS_VALUE)</span><br><span class="line">                frame-&gt;pts = av_rescale_q(d-&gt;next_pts, d-&gt;next_pts_tb, tb);</span><br><span class="line">              <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">                d-&gt;next_pts = frame-&gt;pts + frame-&gt;nb_samples;</span><br><span class="line">                d-&gt;next_pts_tb = tb;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret == AVERROR_EOF) &#123;</span><br><span class="line">          d-&gt;finished = d-&gt;pkt_serial;</span><br><span class="line">          avcodec_flush_buffers(d-&gt;avctx);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">while</span> (ret != AVERROR(EAGAIN));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ffmpeg的解码库用于音视频解码的函数是avcodec_send_packet()和avcodec_receive_frame(),前者用户向解码器发送一个AVPacket数据用于解码，后者从解码器中读取解码后生成的AVFrame数据。了解了音视频流解码的原理后，我们再结合注释看代码，就很好理解了，音视频流解码成功后都对帧的pts进行了设置。音频流的pts设置比较有意思，转换了一个时基，相当于时间单位，算出一个新的pts。在pts设置成功后，会计算下一帧的pts：next_pts，这个值用于当解析到的frame中不含pts时充当备份，每一帧对应的next_pts都是在解析上一帧的时候计算出来的。</p><p>剩下的代码是用来判断是否在此处退出函数的。第一种情况是已经解析到流末尾了，将当前包序列号赋值给finished然后清空解码器缓存。第二种情况是ret&gt;&#x3D;0，当成功解析一帧数据时，ret值会被设置等于0。</p><p>接下来分析第二部分读取包的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">do</span> &#123;<span class="comment">//从PacketQueue中读取新的包</span></span><br><span class="line">  <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;nb_packets == <span class="number">0</span>)</span><br><span class="line">    SDL_CondSignal(d-&gt;empty_queue_cond);<span class="comment">//如果包队列空了，通知等待的读线程可以继续读了</span></span><br><span class="line">  <span class="keyword">if</span> (d-&gt;packet_pending) &#123;<span class="comment">//有未决的包，所以本次循环不用再读新的包了</span></span><br><span class="line">    d-&gt;packet_pending = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> old_serial = d-&gt;pkt_serial;</span><br><span class="line">    <span class="keyword">if</span> (packet_queue_get(d-&gt;<span class="built_in">queue</span>, d-&gt;pkt, <span class="number">1</span>, &amp;d-&gt;pkt_serial) &lt; <span class="number">0</span>)<span class="comment">//从队列中读一个包</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (old_serial != d-&gt;pkt_serial) &#123;<span class="comment">//新读到的包跟之前解析的包不是连续的内容？</span></span><br><span class="line">      avcodec_flush_buffers(d-&gt;avctx);<span class="comment">//刷新解码器缓存</span></span><br><span class="line">      d-&gt;finished = <span class="number">0</span>;<span class="comment">//解码还没结束</span></span><br><span class="line">      d-&gt;next_pts = d-&gt;start_pts;<span class="comment">//更新用于备份的next_pts和next_pts_tb</span></span><br><span class="line">      d-&gt;next_pts_tb = d-&gt;start_pts_tb;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;serial == d-&gt;pkt_serial)<span class="comment">//再校验一次内容的连续性</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  av_packet_unref(d-&gt;pkt);<span class="comment">//如果读到的包序列号与解码器关联的队列序列号不一致，丢弃包内容，下个循环继续读</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>最后分析字幕流解码代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (d-&gt;avctx-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) &#123;<span class="comment">//字幕流解码</span></span><br><span class="line">      <span class="type">int</span> got_frame = <span class="number">0</span>;</span><br><span class="line">      ret = avcodec_decode_subtitle2(d-&gt;avctx, sub, &amp;got_frame, d-&gt;pkt);<span class="comment">//解析字幕流AVPacket</span></span><br><span class="line">      <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = AVERROR(EAGAIN);<span class="comment">//读取失败，下次循环重读</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (got_frame &amp;&amp; !d-&gt;pkt-&gt;data) &#123;</span><br><span class="line">          d-&gt;packet_pending = <span class="number">1</span>;<span class="comment">//拿到数据了，data空了，为了防止有未读出的数据，下次循环还用这个空包去刷新解码器，直到got_frame==0</span></span><br><span class="line">        &#125;</span><br><span class="line">        ret = got_frame ? <span class="number">0</span> : (d-&gt;pkt-&gt;data ? AVERROR(EAGAIN) : AVERROR_EOF);<span class="comment">//拿到数据，ret=0，下次循环函数就返回；如果没拿到数据，但是包的data不为空，下次循环不退出，重新读；//如果又没拿到数据，data也空了，说明到达流末尾了</span></span><br><span class="line">      &#125;</span><br><span class="line">      av_packet_unref(d-&gt;pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是其他流，就将AVPacket发送给解码器</span></span><br><span class="line">      <span class="keyword">if</span> (avcodec_send_packet(d-&gt;avctx, d-&gt;pkt) == AVERROR(EAGAIN)) &#123;</span><br><span class="line">        av_log(d-&gt;avctx, AV_LOG_ERROR, <span class="string">&quot;Receive_frame and send_packet both returned EAGAIN, which is an API violation.\n&quot;</span>);</span><br><span class="line">        d-&gt;packet_pending = <span class="number">1</span>;<span class="comment">//解码器里的数据还未被读出，下次循环不用再发送新包了</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        av_packet_unref(d-&gt;pkt);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>字幕流的解析通过avcodec_decode_subtitle2()函数完成，如果成功解析到数据，数据会被存放到第二个参数sub，第三个参数got_frame会被设置为非零值。某些解码器并不能实时输出所有解码后的数据，此时需要不停发送一个pkt-&gt;data为NULL的包去刷新。</p><p>由于音视频解码器和字幕解码器都可能存在解码器中的数据未读取完暂时不能接受新的AVPacket的情况，所以需要通过packet_pending这个标志位告诉程序下次循环用不用给解码器发送新的AVPacket。</p><p>到此decoder_decode_frame全部分析完毕，解码线程的所有逻辑也分析结束。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（五）：读线程</title>
      <link href="/2022/12/01/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%AF%BB%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/12/01/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%AF%BB%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>在分析main函数的时候我们已经提到过stream_open函数，本章我们开始对其进行分析。stream_open函数的源码结构一目了然，主要做了如下几件事：</p><p>1.创建一个VideoState结构体指针变量is，为其分配内存并以0初始化；</p><p>2.为创建好的结构体变量的成员赋初值，stream_open函数接受两个参数，第一个参数是文件名，第二个参数是用户指定的文件格式，也在这一步赋给相应的结构体成员；</p><p>3.初始化结构体变量中对应视频流，音频流，字幕流的三个FrameQueue，其中视频流和音频流的keep_last值被设置为1，这个值的具体作用我们上一章已经介绍过；</p><p>4.初始化结构体变量中对应视频流，音频流，字幕流的三个PacketQueue；</p><p>5.创建continue_read_thread这个用于读写同步的条件变量；</p><p>6.初始化三个流对应的clock时钟结构体；</p><p>7.设置音量；</p><p>8.打开read_thread线程。</p><p>可以看到stream_open函数主要做的事情就是创建并初始化VideoState结构体变量，初始化完成后打开read_thread线程，然后函数就退出了。从代码中看除了调用相应的函数初始化FrameQueue和PacketQueue以外，函数初始化了三个时钟结构体，分别对应三个流。ffplay为每个流分配了一个Clock结构体类型的变量，其中包含了时间，偏移量，时钟速度等等一些成员，所有成员类型都是double或int。时钟的作用在后面我们分析到音视频同步的时候会详细介绍，现在只需要知道stream_open函数中完成了三个流对应时钟的初始化即可。</p><p>接下来我们看一下read_thread主要做了哪些事。根据任务类型我们可以将read_thread的代码氛围三部分：打开文件，打开流，主循环读流。</p><p>首先我们看一下打开文件部分的代码，我精简掉了一些变量声明，错误检查，打印信息的代码，只保留了重要部分以方便阅读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> st_index[AVMEDIA_TYPE_NB];<span class="comment">//存储各个类型的流对应的序号</span></span><br><span class="line"> <span class="built_in">memset</span>(st_index, <span class="number">-1</span>, <span class="keyword">sizeof</span>(st_index));</span><br><span class="line"> pkt = av_packet_alloc();<span class="comment">//创建一个默认初始化的AVPacket</span></span><br><span class="line"> ic = avformat_alloc_context();<span class="comment">//创建一个默认初始化的AVFormatContext</span></span><br><span class="line"> ic-&gt;interrupt_callback.callback = decode_interrupt_cb;<span class="comment">//中断回调函数，当ffmpeg的io库在执行阻塞操作时，这个函数会被间歇性的调用，当函数的返回值为1时，io库会终止阻塞操作</span></span><br><span class="line"> ic-&gt;interrupt_callback.opaque = is;</span><br><span class="line"> <span class="keyword">if</span> (!av_dict_get(format_opts, <span class="string">&quot;scan_all_pmts&quot;</span>, <span class="literal">NULL</span>, AV_DICT_MATCH_CASE)) &#123;<span class="comment">//设置mpegts的scan_all_pmts选项，该选项的含义是扫描并组合所有ts流的Program Map Table</span></span><br><span class="line">   av_dict_set(&amp;format_opts, <span class="string">&quot;scan_all_pmts&quot;</span>, <span class="string">&quot;1&quot;</span>, AV_DICT_DONT_OVERWRITE);<span class="comment">//所以这里是针对mpegts封装单独设置的选项</span></span><br><span class="line">   scan_all_pmts_set = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> err = avformat_open_input(&amp;ic, is-&gt;filename, is-&gt;iformat, &amp;format_opts);<span class="comment">//打开文件，传入AVFormatContext变量，文件名和格式，以及保存选项信息的字典format_opts,文件打开后，format_opts会被擦除并且写入未被发现的选项</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (scan_all_pmts_set)</span><br><span class="line">   av_dict_set(&amp;format_opts, <span class="string">&quot;scan_all_pmts&quot;</span>, <span class="literal">NULL</span>, AV_DICT_MATCH_CASE);<span class="comment">//打开文件后将scan_all_pmts选项重置</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> ((t = av_dict_get(format_opts, <span class="string">&quot;&quot;</span>, <span class="literal">NULL</span>, AV_DICT_IGNORE_SUFFIX))) &#123;<span class="comment">//如果t不为NULL，说明打开文件时设置的选项中有不被支持的选项</span></span><br><span class="line">   av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Option %s not found.\n&quot;</span>, t-&gt;key);</span><br><span class="line">   ret = AVERROR_OPTION_NOT_FOUND;</span><br><span class="line">   <span class="keyword">goto</span> fail;</span><br><span class="line"> &#125;</span><br><span class="line"> is-&gt;ic = ic;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (genpts)</span><br><span class="line">   ic-&gt;flags |= AVFMT_FLAG_GENPTS;</span><br><span class="line"></span><br><span class="line"> av_format_inject_global_side_data(ic);<span class="comment">//将全局的side data注入到每个流的下一个AVPacket中</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (find_stream_info) &#123;<span class="comment">//校验用户指定的codec选项是否支持</span></span><br><span class="line">   AVDictionary **opts = setup_find_stream_info_opts(ic, codec_opts);</span><br><span class="line">   <span class="type">int</span> orig_nb_streams = ic-&gt;nb_streams;</span><br><span class="line"></span><br><span class="line">   err = avformat_find_stream_info(ic, opts);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; orig_nb_streams; i++)</span><br><span class="line">     av_dict_free(&amp;opts[i]);</span><br><span class="line">   av_freep(&amp;opts);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     av_log(<span class="literal">NULL</span>, AV_LOG_WARNING,</span><br><span class="line">            <span class="string">&quot;%s: could not find codec parameters\n&quot;</span>, is-&gt;filename);</span><br><span class="line">     ret = <span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">goto</span> fail;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (ic-&gt;pb)</span><br><span class="line">   ic-&gt;pb-&gt;eof_reached = <span class="number">0</span>; <span class="comment">// FIXME hack, ffplay maybe should not use avio_feof() to test for the end</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (seek_by_bytes &lt; <span class="number">0</span>)<span class="comment">//当封装格式允许时间戳不连续且不是ogg格式时，以byte查找，否则以时间查找</span></span><br><span class="line">   seek_by_bytes = !!(ic-&gt;iformat-&gt;flags &amp; AVFMT_TS_DISCONT) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;ogg&quot;</span>, ic-&gt;iformat-&gt;name);</span><br><span class="line"></span><br><span class="line"> is-&gt;max_frame_duration = (ic-&gt;iformat-&gt;flags &amp; AVFMT_TS_DISCONT) ? <span class="number">10.0</span> : <span class="number">3600.0</span>;<span class="comment">//每一帧最长时序时间，如果封装格式允许时间戳不连续时，为10秒，否则为3600秒。</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!window_title &amp;&amp; (t = av_dict_get(ic-&gt;metadata, <span class="string">&quot;title&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>)))</span><br><span class="line">   window_title = av_asprintf(<span class="string">&quot;%s - %s&quot;</span>, t-&gt;value, input_filename);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* if seeking requested, we execute it */</span></span><br><span class="line"> <span class="keyword">if</span> (start_time != AV_NOPTS_VALUE) &#123;</span><br><span class="line">   <span class="type">int64_t</span> timestamp;</span><br><span class="line"></span><br><span class="line">   timestamp = start_time;</span><br><span class="line">   <span class="comment">/* add the stream start time */</span></span><br><span class="line">   <span class="keyword">if</span> (ic-&gt;start_time != AV_NOPTS_VALUE)</span><br><span class="line">     timestamp += ic-&gt;start_time;</span><br><span class="line">   ret = avformat_seek_file(ic, <span class="number">-1</span>, INT64_MIN, timestamp, INT64_MAX, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;%s: could not seek to position %0.3f\n&quot;</span>,</span><br><span class="line">            is-&gt;filename, (<span class="type">double</span>)timestamp / AV_TIME_BASE);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> is-&gt;realtime = is_realtime(ic);<span class="comment">//是否是实时流</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (show_status)</span><br><span class="line">   av_dump_format(ic, <span class="number">0</span>, is-&gt;filename, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;<span class="comment">//判断用户指定的流是否可用，如果可用将流的序号设置到数组st_index相应的成员中</span></span><br><span class="line">   AVStream *st = ic-&gt;streams[i];</span><br><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">AVMediaType</span> <span class="title">type</span> =</span> st-&gt;codecpar-&gt;codec_type;</span><br><span class="line">   st-&gt;discard = AVDISCARD_ALL;</span><br><span class="line">   <span class="keyword">if</span> (type &gt;= <span class="number">0</span> &amp;&amp; wanted_stream_spec[type] &amp;&amp; st_index[type] == <span class="number">-1</span>)</span><br><span class="line">     <span class="keyword">if</span> (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) &gt; <span class="number">0</span>)</span><br><span class="line">       st_index[type] = i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; AVMEDIA_TYPE_NB; i++) &#123;</span><br><span class="line">   <span class="keyword">if</span> (wanted_stream_spec[i] &amp;&amp; st_index[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">     av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Stream specifier %s does not match any %s stream\n&quot;</span>, wanted_stream_spec[i], av_get_media_type_string(i));</span><br><span class="line">     st_index[i] = INT_MAX;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//结合用户指定的流查找出最好的流最为最终解析的流</span></span><br><span class="line"> <span class="keyword">if</span> (!video_disable)</span><br><span class="line">   st_index[AVMEDIA_TYPE_VIDEO] =</span><br><span class="line">       av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,</span><br><span class="line">                           st_index[AVMEDIA_TYPE_VIDEO], <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (!audio_disable)</span><br><span class="line">   st_index[AVMEDIA_TYPE_AUDIO] =</span><br><span class="line">       av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,</span><br><span class="line">                           st_index[AVMEDIA_TYPE_AUDIO],</span><br><span class="line">                           st_index[AVMEDIA_TYPE_VIDEO],</span><br><span class="line">                           <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (!video_disable &amp;&amp; !subtitle_disable)</span><br><span class="line">   st_index[AVMEDIA_TYPE_SUBTITLE] =</span><br><span class="line">       av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,</span><br><span class="line">                           st_index[AVMEDIA_TYPE_SUBTITLE],</span><br><span class="line">                           (st_index[AVMEDIA_TYPE_AUDIO] &gt;= <span class="number">0</span> ?</span><br><span class="line">                            st_index[AVMEDIA_TYPE_AUDIO] :</span><br><span class="line">                            st_index[AVMEDIA_TYPE_VIDEO]),</span><br><span class="line">                           <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> is-&gt;show_mode = show_mode;</span><br><span class="line"> <span class="keyword">if</span> (st_index[AVMEDIA_TYPE_VIDEO] &gt;= <span class="number">0</span>) &#123;<span class="comment">//从视频流中获取画面宽高，依次设置默认窗口大小</span></span><br><span class="line">   AVStream *st = ic-&gt;streams[st_index[AVMEDIA_TYPE_VIDEO]];</span><br><span class="line">   AVCodecParameters *codecpar = st-&gt;codecpar;</span><br><span class="line">   AVRational sar = av_guess_sample_aspect_ratio(ic, st, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">if</span> (codecpar-&gt;width)</span><br><span class="line">     set_default_window_size(codecpar-&gt;width, codecpar-&gt;height, sar);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注释已经说明了大部分代码的用途，这部分代码做的事主要是打开文件，获取流信息，结合用户指定的流说明符选取最优的流用于接下来的步骤。打开文件和获取流信息都是通过ffmpeg库函数实现的，没有复杂的逻辑，结合相关函数的注释很好理解。占用篇幅最大也是最不好理解的部分就是选取最优的流的相关操作。</p><p>首先定义了一个的数组:int st_index[AVMEDIA_TYPE_NB],这里涉及到一个枚举类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AVMediaType</span> &#123;</span></span><br><span class="line">    AVMEDIA_TYPE_UNKNOWN = <span class="number">-1</span>,  <span class="comment">///&lt; Usually treated as AVMEDIA_TYPE_DATA</span></span><br><span class="line">    AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    AVMEDIA_TYPE_AUDIO,</span><br><span class="line">    AVMEDIA_TYPE_DATA,          <span class="comment">///&lt; Opaque data information usually continuous</span></span><br><span class="line">    AVMEDIA_TYPE_SUBTITLE,</span><br><span class="line">    AVMEDIA_TYPE_ATTACHMENT,    <span class="comment">///&lt; Opaque data information usually sparse</span></span><br><span class="line">    AVMEDIA_TYPE_NB</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用媒体类型作为数组索引，数组元素为int，数组元素是如何被赋值的呢？看下面的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;<span class="comment">//判断用户指定的流是否可用，如果可用将流的序号设置到数组st_index相应的成员中</span></span><br><span class="line">  AVStream *st = ic-&gt;streams[i];</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">AVMediaType</span> <span class="title">type</span> =</span> st-&gt;codecpar-&gt;codec_type;</span><br><span class="line">  st-&gt;discard = AVDISCARD_ALL;</span><br><span class="line">  <span class="keyword">if</span> (type &gt;= <span class="number">0</span> &amp;&amp; wanted_stream_spec[type] &amp;&amp; st_index[type] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) &gt; <span class="number">0</span>)</span><br><span class="line">      st_index[type] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; AVMEDIA_TYPE_NB; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (wanted_stream_spec[i] &amp;&amp; st_index[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Stream specifier %s does not match any %s stream\n&quot;</span>, wanted_stream_spec[i], av_get_media_type_string(i));</span><br><span class="line">    st_index[i] = INT_MAX;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中有一个特殊的数组wanted_stream_spec[],从数组的定义上我们会发现，这个数组的大小也是AVMEDIA_TYPE_NB，数组元素类型是const char*。这个数组中存储的是用户指定的流说明符，如wanted_stream_spec[AVMEDIA_TYPE_AUDIO]的值为”1“表示用户指定使用第二个音频流，wanted_stream_spec[AVMEDIA_TYPE_VIDEO]的值为”2“表示用户指定使用第三个视频流等。使用avformat_match_stream_specifier函数进行匹配，如果程序解析出的流与用户指定的流匹配，那么就将st_index[type]设置为这个流的序号，例如通过-vst 1指定第二个视频流，而文件解析出的第二个视频流对应的序号i为3，那么st_index[AVMEDIA_TYPE_VIDEO]的值就会被设置为3，如果没有匹配到，比如文件中只有一个视频流的时候，相应的值就不会被设置。还有一个逻辑就是st_index[type]一旦被设置过就不会再对同类型的流进行比对了。</p><p>接下来会将wanted_stream_spec和st_index进行比对，如果相同索引位置前者有值，而后者的值还是默认值-1，则表示用户指定的流没有被匹配到，随后后者的值会被设置为INT_MAX。</p><p>通过以上步骤，有可能某一类型的流未被指定，例如上面说到的，用户使用-vst 1指定第二个视频流，但是文件中却只含有一个视频流，这种情况下st_index[AVMEDIA_TYPE_VIDEO]会被设置为INT_MAX。所以就需要将合适的流序号赋给他，ffplay使用的方式是调用av_find_best_stream函数来找到最佳匹配，它会根据传入的参数选择一个最接近用户期望的流。</p><p>至此，st_index[]中已经保存了最优的流的序号，接下来就是打开这些流开始读取数据了。打开流的代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (st_index[AVMEDIA_TYPE_AUDIO] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ret = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (st_index[AVMEDIA_TYPE_VIDEO] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (is-&gt;show_mode == SHOW_MODE_NONE)</span><br><span class="line">    is-&gt;show_mode = ret &gt;= <span class="number">0</span> ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (st_index[AVMEDIA_TYPE_SUBTITLE] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>stream_component_open函数的返回值0表示成功，负数表示打开失败，在打开视频流的时候对返回值进行了一下判断，并且设置相应的显示模式。除此之外，所有流的打开都是通过stream_component_open函数完成的。我们接下来分析stream_component_open函数都做了什么工作。</p><p>首先stream_component_open根据传进来的流序号从AVFormatContext中获取到对应的信息，并用这些信息结合用户指定的参数完成了解码器的创建。关键代码注释如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">avctx = avcodec_alloc_context3(<span class="literal">NULL</span>);<span class="comment">//以默认值创建一个AVCodecContext</span></span><br><span class="line">...</span><br><span class="line"> ret = avcodec_parameters_to_context(avctx, ic-&gt;streams[stream_index]-&gt;codecpar);<span class="comment">//将AVFormatContext中读取到的codec相关的参数复制给AVCodecContext对应的成员</span></span><br><span class="line"> ...</span><br><span class="line"> codec = avcodec_find_decoder(avctx-&gt;codec_id);<span class="comment">//根据codec_id查找解码器，codec_id是通过之前的avcodec_parameters_to_context函数从流的codecpar中获取到的</span></span><br><span class="line">...  </span><br><span class="line"> <span class="keyword">if</span> (forced_codec_name)<span class="comment">//如果用户指定了解码器名称，根据名称搜索解码器</span></span><br><span class="line">   codec = avcodec_find_decoder_by_name(forced_codec_name);</span><br><span class="line">...</span><br><span class="line"> avctx-&gt;codec_id = codec-&gt;id;<span class="comment">//更新最终获取到的解码器id</span></span><br><span class="line">...</span><br><span class="line"> <span class="keyword">if</span> ((ret = avcodec_open2(avctx, codec, &amp;opts)) &lt; <span class="number">0</span>) &#123;<span class="comment">//设置好解码器选项后打开解码器</span></span><br><span class="line">   <span class="keyword">goto</span> fail;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打开解码器后针对不同的流类型做不同的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (avctx-&gt;codec_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">      sample_rate    = avctx-&gt;sample_rate;</span><br><span class="line">        nb_channels    = avctx-&gt;channels;</span><br><span class="line">        channel_layout = avctx-&gt;channel_layout;</span><br><span class="line">      <span class="comment">/* prepare audio output */</span></span><br><span class="line">      <span class="keyword">if</span> ((ret = audio_open(is, channel_layout, nb_channels, sample_rate, &amp;is-&gt;audio_tgt)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">      is-&gt;audio_hw_buf_size = ret;</span><br><span class="line">      is-&gt;audio_src = is-&gt;audio_tgt;</span><br><span class="line">      is-&gt;audio_buf_size  = <span class="number">0</span>;</span><br><span class="line">      is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* init averaging filter */</span></span><br><span class="line">      is-&gt;audio_diff_avg_coef  = <span class="built_in">exp</span>(<span class="built_in">log</span>(<span class="number">0.01</span>) / AUDIO_DIFF_AVG_NB);</span><br><span class="line">      is-&gt;audio_diff_avg_count = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">/* since we do not have a precise anough audio FIFO fullness,</span></span><br><span class="line"><span class="comment">         we correct audio sync only if larger than this threshold */</span></span><br><span class="line">      is-&gt;audio_diff_threshold = (<span class="type">double</span>)(is-&gt;audio_hw_buf_size) / is-&gt;audio_tgt.bytes_per_sec;</span><br><span class="line"></span><br><span class="line">      is-&gt;audio_stream = stream_index;</span><br><span class="line">      is-&gt;audio_st = ic-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_init(&amp;is-&gt;auddec, avctx, &amp;is-&gt;audioq, is-&gt;continue_read_thread)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">      <span class="keyword">if</span> ((is-&gt;ic-&gt;iformat-&gt;flags &amp; (AVFMT_NOBINSEARCH | AVFMT_NOGENSEARCH | AVFMT_NO_BYTE_SEEK)) &amp;&amp; !is-&gt;ic-&gt;iformat-&gt;read_seek) &#123;</span><br><span class="line">        is-&gt;auddec.start_pts = is-&gt;audio_st-&gt;start_time;</span><br><span class="line">        is-&gt;auddec.start_pts_tb = is-&gt;audio_st-&gt;time_base;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_start(&amp;is-&gt;auddec, audio_thread, <span class="string">&quot;audio_decoder&quot;</span>, is)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      SDL_PauseAudioDevice(audio_dev, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">      is-&gt;video_stream = stream_index;</span><br><span class="line">      is-&gt;video_st = ic-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_init(&amp;is-&gt;viddec, avctx, &amp;is-&gt;videoq, is-&gt;continue_read_thread)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_start(&amp;is-&gt;viddec, video_thread, <span class="string">&quot;video_decoder&quot;</span>, is)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      is-&gt;queue_attachments_req = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_SUBTITLE:</span><br><span class="line">      is-&gt;subtitle_stream = stream_index;</span><br><span class="line">      is-&gt;subtitle_st = ic-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_init(&amp;is-&gt;subdec, avctx, &amp;is-&gt;subtitleq, is-&gt;continue_read_thread)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_start(&amp;is-&gt;subdec, subtitle_thread, <span class="string">&quot;subtitle_decoder&quot;</span>, is)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里我删除了音频滤镜的代码，因为滤镜只是改变了相关参数的值，在分析代码逻辑的时候暂时注释掉这部分代码比较不容易混淆。</p><p>从代码中我们很容易发现视频流和字幕流的处理逻辑是完全一致的，都是初始化一个Decoder然后开启解码线程，音频则要复杂的多，所以我们先从视频流和字幕流的处理开始分析，最后再分析音频流的处理。</p><p>我们暂时不需要关心Decoder的工作原理，只需要知道decoder_init函数用于初始化一个Decoder结构体变量，而Decoder是对AVCodecContext的封装，加入了一些其他参数。而decoder_start所做的工作就是开启流对应的PacketQueue，表示已经可以向队列中写入数据了。然后开启对应的解码线程，如视频流是video_thread，字幕流是subtitle_thread。各个流对应的解码线程执行的具体工作我们会在后面的章节中详细分析。</p><p>接着是音频流的处理，从代码中我们可以发现，音频流的处理与视频流和字幕流最大的不同是在执行decoder_init之前，先是调用了一个名为audio_open的函数，然后设置了VideoState中很多相应的音频参数。我们先来看audio_open函数做了什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">audio_open</span><span class="params">(<span class="type">void</span> *opaque, <span class="type">int64_t</span> wanted_channel_layout, <span class="type">int</span> wanted_nb_channels, <span class="type">int</span> wanted_sample_rate, <span class="keyword">struct</span> AudioParams *audio_hw_params)</span></span><br><span class="line">&#123;</span><br><span class="line">  SDL_AudioSpec wanted_spec, spec;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *env;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> next_nb_channels[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> next_sample_rates[] = &#123;<span class="number">0</span>, <span class="number">44100</span>, <span class="number">48000</span>, <span class="number">96000</span>, <span class="number">192000</span>&#125;;</span><br><span class="line">  <span class="type">int</span> next_sample_rate_idx = FF_ARRAY_ELEMS(next_sample_rates) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  env = SDL_getenv(<span class="string">&quot;SDL_AUDIO_CHANNELS&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (env) &#123;</span><br><span class="line">    wanted_nb_channels = atoi(env);</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!wanted_channel_layout || wanted_nb_channels != av_get_channel_layout_nb_channels(wanted_channel_layout)) &#123;</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);</span><br><span class="line">    wanted_channel_layout &amp;= ~AV_CH_LAYOUT_STEREO_DOWNMIX;</span><br><span class="line">  &#125;</span><br><span class="line">  wanted_nb_channels = av_get_channel_layout_nb_channels(wanted_channel_layout);</span><br><span class="line">  wanted_spec.channels = wanted_nb_channels;</span><br><span class="line">  wanted_spec.freq = wanted_sample_rate;</span><br><span class="line">  <span class="keyword">if</span> (wanted_spec.freq &lt;= <span class="number">0</span> || wanted_spec.channels &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Invalid sample rate or channel count!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (next_sample_rate_idx &amp;&amp; next_sample_rates[next_sample_rate_idx] &gt;= wanted_spec.freq)</span><br><span class="line">    next_sample_rate_idx--;</span><br><span class="line">  wanted_spec.format = AUDIO_S16SYS;</span><br><span class="line">  wanted_spec.silence = <span class="number">0</span>;</span><br><span class="line">  wanted_spec.samples = FFMAX(SDL_AUDIO_MIN_BUFFER_SIZE, <span class="number">2</span> &lt;&lt; av_log2(wanted_spec.freq / SDL_AUDIO_MAX_CALLBACKS_PER_SEC));</span><br><span class="line">  wanted_spec.callback = sdl_audio_callback;</span><br><span class="line">  wanted_spec.userdata = opaque;</span><br><span class="line">  <span class="keyword">while</span> (!(audio_dev = SDL_OpenAudioDevice(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;wanted_spec, &amp;spec, SDL_AUDIO_ALLOW_FREQUENCY_CHANGE | SDL_AUDIO_ALLOW_CHANNELS_CHANGE))) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;SDL_OpenAudio (%d channels, %d Hz): %s\n&quot;</span>,</span><br><span class="line">           wanted_spec.channels, wanted_spec.freq, SDL_GetError());</span><br><span class="line">    wanted_spec.channels = next_nb_channels[FFMIN(<span class="number">7</span>, wanted_spec.channels)];</span><br><span class="line">    <span class="keyword">if</span> (!wanted_spec.channels) &#123;</span><br><span class="line">      wanted_spec.freq = next_sample_rates[next_sample_rate_idx--];</span><br><span class="line">      wanted_spec.channels = wanted_nb_channels;</span><br><span class="line">      <span class="keyword">if</span> (!wanted_spec.freq) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">&quot;No more combinations to try, audio open failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(wanted_spec.channels);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (spec.format != AUDIO_S16SYS) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">           <span class="string">&quot;SDL advised audio format %d is not supported!\n&quot;</span>, spec.format);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (spec.channels != wanted_spec.channels) &#123;</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(spec.channels);</span><br><span class="line">    <span class="keyword">if</span> (!wanted_channel_layout) &#123;</span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">             <span class="string">&quot;SDL advised channel count %d is not supported!\n&quot;</span>, spec.channels);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  audio_hw_params-&gt;fmt = AV_SAMPLE_FMT_S16;</span><br><span class="line">  audio_hw_params-&gt;freq = spec.freq;</span><br><span class="line">  audio_hw_params-&gt;channel_layout = wanted_channel_layout;</span><br><span class="line">  audio_hw_params-&gt;channels =  spec.channels;</span><br><span class="line">  audio_hw_params-&gt;frame_size = av_samples_get_buffer_size(<span class="literal">NULL</span>, audio_hw_params-&gt;channels, <span class="number">1</span>, audio_hw_params-&gt;fmt, <span class="number">1</span>);</span><br><span class="line">  audio_hw_params-&gt;bytes_per_sec = av_samples_get_buffer_size(<span class="literal">NULL</span>, audio_hw_params-&gt;channels, audio_hw_params-&gt;freq, audio_hw_params-&gt;fmt, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (audio_hw_params-&gt;bytes_per_sec &lt;= <span class="number">0</span> || audio_hw_params-&gt;frame_size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;av_samples_get_buffer_size failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> spec.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先从入参开始看，channel_layout, nb_channels, sample_rate都是从解码器对应的AVCodecContext中获取的，分别代表音频的通道布局，通道数和采样率，&amp;is-&gt;audio_tgt是一个AudioParams结构体变量的地址，该变量用于存储硬件支持的音频参数。</p><p>函数一开始先对传入的通道布局和通道数进行匹配，结合环境变量计算出合适的通道布局和通道数，然后根据传入的采样率算出一个不大于它的符合标准的采样率。</p><p>接下来使用SDL库函数SDL_OpenAudioDevice()打开音频设备。这里简单说一下这个函数的原理，函数的第一个参数类型为const char*，用来指定设备ID，这里设置为NULL,表示自动选择，第二个函数类型为int，为0时表示打开设备用于播放，非零时表示打开设备用于录音，第三个参数类型是 const SDL_AudioSpec*，存储用户指定的音频参数，第四个参数类型是SDL_AudioSpec*，存储函数执行成功后实际设置的音频参数，最后一个参数是标志位，用于指定那些参数可以被修改，这里我们设置的是允许修改频率和通道数。该函数返回0表示失败，大于0表示成功并且返回值为音频设备id。如果打开设备不成功，函数会修改通道数和采样率并尝试重新打开设备，当经过计算后的采样率为0时，函数返回-1。打开设备成功后，相应的音频参数会被赋给audio_tgt相应的字段，然后函数返回音频缓冲区的大小值。还有一个我们不能忽视的函数，作为第三个参数SDL_AudioSpec中callback成员传入的sdl_audio_callback函数。sdl音频输出的工作原理是这样的，当成功打开音频设备时，音频输出是暂停的，需要手动调用SDL_PauseAudioDevice()函数让音频设备开始工作，当音频设备开始工作的时候会间歇的调用SDL_AudioSpec中的callback函数来”拉取“音频数据写入音频设备，所以callback函数的作用就是提供音频数据。我们看一下ffplay的sdl_audio_callback函数是怎么写的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sdl_audio_callback</span><span class="params">(<span class="type">void</span> *opaque, Uint8 *stream, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  VideoState *is = opaque;</span><br><span class="line">  <span class="type">int</span> audio_size, len1;</span><br><span class="line"></span><br><span class="line">  audio_callback_time = av_gettime_relative();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;<span class="comment">//如果程序当前缓冲区中没有数据，就解析一帧数据</span></span><br><span class="line">      audio_size = audio_decode_frame(is);</span><br><span class="line">      <span class="keyword">if</span> (audio_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* if error, just output silence */</span></span><br><span class="line">        is-&gt;audio_buf = <span class="literal">NULL</span>;</span><br><span class="line">        is-&gt;audio_buf_size = SDL_AUDIO_MIN_BUFFER_SIZE / is-&gt;audio_tgt.frame_size * is-&gt;audio_tgt.frame_size;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;show_mode != SHOW_MODE_VIDEO)<span class="comment">//如果当前的显示模式不是视频模式，将音频数据进行图形化显示</span></span><br><span class="line">          update_sample_display(is, (<span class="type">int16_t</span> *)is-&gt;audio_buf, audio_size);</span><br><span class="line">        is-&gt;audio_buf_size = audio_size;</span><br><span class="line">      &#125;</span><br><span class="line">      is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<span class="comment">//计算写入数据的长度</span></span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len)</span><br><span class="line">      len1 = len;</span><br><span class="line">    <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf &amp;&amp; is-&gt;audio_volume == SDL_MIX_MAXVOLUME)<span class="comment">//当不静音且audio_buf有效时才输出数据，如果音量为SDL_MIX_MAXVOLUME，直接输出数据</span></span><br><span class="line">      <span class="built_in">memcpy</span>(stream, (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">memset</span>(stream, <span class="number">0</span>, len1);</span><br><span class="line">      <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf)<span class="comment">//否则混合音频数据以AUDIO_S16SYS格式输出</span></span><br><span class="line">        SDL_MixAudioFormat(stream, (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, AUDIO_S16SYS, len1, is-&gt;audio_volume);</span><br><span class="line">    &#125;</span><br><span class="line">    len -= len1;</span><br><span class="line">    stream += len1;</span><br><span class="line">    is-&gt;audio_buf_index += len1;</span><br><span class="line">  &#125;</span><br><span class="line">  is-&gt;audio_write_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">  <span class="comment">/* Let&#x27;s assume the audio driver that is used by SDL has two periods. */</span></span><br><span class="line">  <span class="keyword">if</span> (!isnan(is-&gt;audio_clock)) &#123;<span class="comment">//更新时钟</span></span><br><span class="line">    set_clock_at(&amp;is-&gt;audclk, is-&gt;audio_clock - (<span class="type">double</span>)(<span class="number">2</span> * is-&gt;audio_hw_buf_size + is-&gt;audio_write_buf_size) / is-&gt;audio_tgt.bytes_per_sec, is-&gt;audio_clock_serial, audio_callback_time / <span class="number">1000000.0</span>);</span><br><span class="line">    sync_clock_to_slave(&amp;is-&gt;extclk, &amp;is-&gt;audclk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>callback的函数签名是统一的，opaque是用户数据，本程序中我们设置的是VideoState，stream表示音频数据缓冲区，len表示缓冲区大小。从代码中我们可以看到由于sdl音频这种通过回调函数”拉取“数据的方式，程序需要在callback中提供音频数据，所以音频数据从FrameQueue中的读取从此时就开始了，这一点跟视频流和字幕流都不一样，后两者是在主循环中需要显示画面的时候才从FrameQueue中读取的，而且是在主线程中操作。</p><p>还有一个关键函数audio_decode_frame(),作用是从FrameQueue中读取一帧数据然后解析成音频数据。因为其中涉及到音视频同步，所以我准备在后面分析音视频同步的时候详细分析这部分代码，目前就只需要知道这个函数的功能就可以了。</p><p>audio_open分析完了，我们再来看音频流处理剩下的代码，之前我们提到过，SDL打开音频设备后，设备默认是暂停的，需要手动取消暂停设备才会开始通过callback函数获取数据播放音频。这样做的目的是为了打开音频设备后让程序有时间做一些数据的初始化工作的。接下来的代码就是做一些播放前的准备操作，包括一些参数的赋值或初始化以及开启音频解码线程。在做完这些操作后，调用SDL_PauseAudioDevice(audio_dev, 0)解除音频设备的静音状态，其中audio_dev是SDL_OpenAudioDevice函数的返回值。</p><p>stream_component_open函数到此就分析完了，read_thread剩下的代码是一个无限循环，主要工作就是使用av_read_frame()从流读取包再放入PacketQueue。我们看一下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*针对网络流的开启或关闭操作*/</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;seek_req) &#123;<span class="comment">//seek到指定位置，此操作会刷新PacketQueue，导致serial+1，并且如果是暂停状态下seek，seek完成后会更新一帧画面</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;queue_attachments_req) &#123;<span class="comment">//如果视频流保存的是附加数据，如专辑封面等，读取数据后放入队列，然后放入空包以此告诉解码器已经到达当前流结尾</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果队列已满，暂时不要读取更多数据，等待最长10ms，就开始下一个循环 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*播放完后判断是直接退出还是循环播放*/</span></span><br><span class="line">    ... </span><br><span class="line">    ret = av_read_frame(ic, pkt);<span class="comment">//读取一个AVPacket</span></span><br><span class="line">  <span class="comment">/*如果读取失败，判断是到达了文件结尾还是io错误，如果到达了文件结尾，就往队列里放空包并设置标志位</span></span><br><span class="line"><span class="comment">  如果是io错误，则选择退出程序或结束线程，否则就等待最长10ms，继续下一次循环*/</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 判断数据是否在用户指定的播放时间范围内，如果不在就丢弃 */</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;audio_stream &amp;&amp; pkt_in_play_range) &#123;</span><br><span class="line">      packet_queue_put(&amp;is-&gt;audioq, pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;video_stream &amp;&amp; pkt_in_play_range</span><br><span class="line">        &amp;&amp; !(is-&gt;video_st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC)) &#123;</span><br><span class="line">      packet_queue_put(&amp;is-&gt;videoq, pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;subtitle_stream &amp;&amp; pkt_in_play_range) &#123;</span><br><span class="line">      packet_queue_put(&amp;is-&gt;subtitleq, pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      av_packet_unref(pkt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码经过精简，精简掉的代码功能已经通过注释写明，这里比较难理解的是判断数据是否在播放范围的判断条件，我们详细分析一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stream_start_time = ic-&gt;streams[pkt-&gt;stream_index]-&gt;start_time;</span><br><span class="line">    pkt_ts = pkt-&gt;pts == AV_NOPTS_VALUE ? pkt-&gt;dts : pkt-&gt;pts;</span><br><span class="line">    pkt_in_play_range = duration == AV_NOPTS_VALUE ||</span><br><span class="line">        (pkt_ts - (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : <span class="number">0</span>)) *</span><br><span class="line">            av_q2d(ic-&gt;streams[pkt-&gt;stream_index]-&gt;time_base) -</span><br><span class="line">            (<span class="type">double</span>)(start_time != AV_NOPTS_VALUE ? start_time : <span class="number">0</span>) / <span class="number">1000000</span></span><br><span class="line">            &lt;= ((<span class="type">double</span>)duration / <span class="number">1000000</span>);</span><br></pre></td></tr></table></figure><p>首先获取stream的开始时间stream_start_time，然后拿到该数据包的展示时间pkt_ts，如果pts不存在，就用解码时间dts代替。判断是否在播放范围是一个或操作，第一个条件很好理解，duration未定义时，一律认定在播放范围。第二个条件我们分开看，首先是展示时间pkt_ts减去流开始时间stream_start_time，这样我们可以认为我们获得了以stream_start_time为零点的一个时间点，我们用这个值减去start_time（start_time是用户设置的开始时间，这个时间也是一个以stream_start_time为零点的一个时间点）得到的结果是一个时间段，如果这个时间段的值小于duration，说明该数据展示的时间点早于start_time+duration得到的时间点，那么这个数据就在播放范围内，否则说明该数据展示的时间点晚于start_time+duration得到的时间点，我们并不需要播放这段数据，所以这段数据就被丢弃。那么有没有可能pkt_ts小于start_time呢？这样也能满足上述条件，但是这个数据也不在播放范围内。答案是不可能，因为这种情况发生的情况只会是发生了seek，seek操作的处理在读取数据之前已经完成，所以seek时间点之前的数据是不可能被读到的。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（四）：FrameQueue</title>
      <link href="/2022/11/30/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AFrameQueue/"/>
      <url>/2022/11/30/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AFrameQueue/</url>
      
        <content type="html"><![CDATA[<p>FrameQueue是用于保存AVFrame数据的队列，同样的为了能够增加额外的参数，AVFrame与其他额外参数被封装成一个新的结构体Frame，FrameQueue中保存的就是Frame类型的数据。Frame和FrameQueue结构体代码注释如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Frame</span> &#123;</span></span><br><span class="line">  AVFrame *frame;<span class="comment">//指向帧结构体变量的指针</span></span><br><span class="line">  AVSubtitle sub;<span class="comment">//字幕结构体变量</span></span><br><span class="line">  <span class="type">int</span> serial;<span class="comment">//序列号</span></span><br><span class="line">  <span class="type">double</span> pts;<span class="comment">//这一帧展示的时间点</span></span><br><span class="line">  <span class="type">double</span> duration;<span class="comment">//这一帧内容的持续时间</span></span><br><span class="line">  <span class="type">int64_t</span> pos;<span class="comment">//这一帧在输入文件中的位置</span></span><br><span class="line">  <span class="type">int</span> width;<span class="comment">//画面的宽度</span></span><br><span class="line">  <span class="type">int</span> height;<span class="comment">//画面的高度</span></span><br><span class="line">  <span class="type">int</span> format;<span class="comment">//格式</span></span><br><span class="line">  AVRational sar;<span class="comment">//横向像素点与纵向像素点数量的比值</span></span><br><span class="line">  <span class="type">int</span> uploaded;<span class="comment">//是否已经渲染到输出设备</span></span><br><span class="line">  <span class="type">int</span> flip_v;<span class="comment">//垂直翻转</span></span><br><span class="line">&#125; Frame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FrameQueue</span> &#123;</span></span><br><span class="line">  Frame <span class="built_in">queue</span>[FRAME_QUEUE_SIZE];<span class="comment">//保存Frame格式数据的数组</span></span><br><span class="line">  <span class="type">int</span> rindex;<span class="comment">//读指针</span></span><br><span class="line">  <span class="type">int</span> windex;<span class="comment">//写指针</span></span><br><span class="line">  <span class="type">int</span> size;<span class="comment">//未读帧数</span></span><br><span class="line">  <span class="type">int</span> max_size;<span class="comment">//队列中能保存的最大帧数</span></span><br><span class="line">  <span class="type">int</span> keep_last;<span class="comment">//是否保留上一帧</span></span><br><span class="line">  <span class="type">int</span> rindex_shown;<span class="comment">//用于标识保留帧</span></span><br><span class="line">  SDL_mutex *mutex;<span class="comment">//互斥量</span></span><br><span class="line">  SDL_cond *cond;<span class="comment">//用于读写同步的条件变量</span></span><br><span class="line">  PacketQueue *pktq;<span class="comment">//包队列指针</span></span><br><span class="line">&#125; FrameQueue;</span><br></pre></td></tr></table></figure><p>FrameQueue通过一个固定长度的数组以及两个读写指针实现了一个循环队列，当需要从队列中读取数据或向队列中写入数据时，队列会返回一个指向可读或可写位置的指针，然后调用者可以通过指针进行读写操作。</p><p>FrameQueue的操作函数有如下几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">frame_queue_unref_item</span><span class="params">(Frame *vp)</span></span><br><span class="line">&#123;</span><br><span class="line">  av_frame_unref(vp-&gt;frame);<span class="comment">//释放所有跟frame关联的buffer并重置frame中所有字段的值</span></span><br><span class="line">  avsubtitle_free(&amp;vp-&gt;sub);<span class="comment">//释放sub中分配的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数用于释放Frame结构体变量中的AVFrame和AVSubtitle成员变量关联的数据，注意只是释放关联的数据，而不是销毁结构体变量，这一步的作用是重置Frame。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">frame_queue_init</span><span class="params">(FrameQueue *f, PacketQueue *pktq, <span class="type">int</span> max_size, <span class="type">int</span> keep_last)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(FrameQueue));</span><br><span class="line">  <span class="keyword">if</span> (!(f-&gt;mutex = SDL_CreateMutex())) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;SDL_CreateMutex(): %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(f-&gt;cond = SDL_CreateCond())) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;SDL_CreateCond(): %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">  &#125;</span><br><span class="line">  f-&gt;pktq = pktq;<span class="comment">//关联PacketQueue</span></span><br><span class="line">  f-&gt;max_size = FFMIN(max_size, FRAME_QUEUE_SIZE);</span><br><span class="line">  f-&gt;keep_last = !!keep_last;<span class="comment">//keep_last的值为0或1</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; f-&gt;max_size; i++)<span class="comment">//初始化队列数据</span></span><br><span class="line">    <span class="keyword">if</span> (!(f-&gt;<span class="built_in">queue</span>[i].frame = av_frame_alloc()))</span><br><span class="line">      <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列的初始化函数，与PacketQueue一样，也是使用memset()将所有内置类型的变量初始化为0。然后创建用于线程同步的互斥量以及条件变量，关联PacketQueue，设置队列最大成员数量，keep_last通过一个小技巧将输入值转换为0或1，保证所有非零输入都被转换为1保存，最后使用av_frame_alloc()初始化所有数组成员，该函数会创建一个AVFrame并设置默认值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">frame_queue_destory</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; f-&gt;max_size; i++) &#123;</span><br><span class="line">    Frame *vp = &amp;f-&gt;<span class="built_in">queue</span>[i];</span><br><span class="line">    frame_queue_unref_item(vp);</span><br><span class="line">    av_frame_free(&amp;vp-&gt;frame);</span><br><span class="line">  &#125;</span><br><span class="line">  SDL_DestroyMutex(f-&gt;mutex);</span><br><span class="line">  SDL_DestroyCond(f-&gt;cond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销毁函数，销毁队列中所有数据，针对每个数组成员，先调用frame_queue_unref_item销毁关联数据，再调用av_frame_free销毁AVFrame本身，AVSubtitle由于分配在栈上，所以不需要手动销毁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">frame_queue_signal</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  SDL_CondSignal(f-&gt;cond);</span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送同步信号，唤醒等待条件变量的线程。</p><p>接下来是重头戏，队列的读写函数，我们先分析逻辑较为简单的写操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Frame *<span class="title function_">frame_queue_peek_writable</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* wait until we have space to put a new frame */</span></span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  <span class="keyword">while</span> (f-&gt;size &gt;= f-&gt;max_size &amp;&amp;</span><br><span class="line">      !f-&gt;pktq-&gt;abort_request) &#123;</span><br><span class="line">    SDL_CondWait(f-&gt;cond, f-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;pktq-&gt;abort_request)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;f-&gt;<span class="built_in">queue</span>[f-&gt;windex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">frame_queue_push</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (++f-&gt;windex == f-&gt;max_size)</span><br><span class="line">    f-&gt;windex = <span class="number">0</span>;</span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  f-&gt;size++;</span><br><span class="line">  SDL_CondSignal(f-&gt;cond);</span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>frame_queue_peek_writable返回写指针指向的数组成员，在返回之前函数会先检查队列是否已满，由于是循环队列，队列已满的意思就是队列中所有成员都已被写入数据切这些数据都还未被读取，如果此时未经检查直接写入新的数据，那么当前数组中最早被写入的数据就会被覆盖。检查的手段也很简单，只需要检查size是否大于或等于max_size即可。当队列中有可写空间时，返回写指针指向的数据成员。写入成功后需要将写指针向前移动一位，如果移动后的索引值超过了最大索引值，就将写指针的索引设为0，从而实现对数组的循环写入。接下来将size加1,并发送通知唤醒等待条件变量的线程，由于size值在读写线程中都会被修改，所以需要在加锁的情况下更新。</p><p>写操作的逻辑简单总结就是，找到可写位置，写入数据，更新未读节点数量，然后发送通知唤醒还在等待的线程。</p><p>相比写操作，读操作的逻辑相对复杂，主要是因为涉及到保留上一帧这一操作，我们看一下具体代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Frame *<span class="title function_">frame_queue_peek</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;f-&gt;<span class="built_in">queue</span>[(f-&gt;rindex + f-&gt;rindex_shown) % f-&gt;max_size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Frame *<span class="title function_">frame_queue_peek_next</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;f-&gt;<span class="built_in">queue</span>[(f-&gt;rindex + f-&gt;rindex_shown + <span class="number">1</span>) % f-&gt;max_size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Frame *<span class="title function_">frame_queue_peek_last</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;f-&gt;<span class="built_in">queue</span>[f-&gt;rindex];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> Frame *<span class="title function_">frame_queue_peek_readable</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* wait until we have a readable a new frame */</span></span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  <span class="keyword">while</span> (f-&gt;size - f-&gt;rindex_shown &lt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">      !f-&gt;pktq-&gt;abort_request) &#123;</span><br><span class="line">    SDL_CondWait(f-&gt;cond, f-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;pktq-&gt;abort_request)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;f-&gt;<span class="built_in">queue</span>[(f-&gt;rindex + f-&gt;rindex_shown) % f-&gt;max_size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是读取函数，三个简单的读取函数分别用来读取当前结点，读取下一个节点以及读取上一个节点，还有一个实现更复杂的读取可读节点，该函数与普通的读取当前节点的函数的不同点在于frame_queue_peek_readable是读取还未读取的节点，而frame_queue_peek则只是读取当前节点而不检查当前节点是否已经被读取过。读取未读节点需要满足两个条件：1、队列中存在未读节点；2、关联的PacketQueue没有终止。如果条件1未被满足，函数会阻塞直到被条件变量的通知唤醒；如果条件2未被满足，函数返回NULL；如果两者都被满足，则返回当前节点，使用与普通读取函数相同的操作。</p><p>我们注意到，计算当前节点索引的方式有些特别，是用rindex+rindex_shown的和对max_size取模，所以严格来说rindex并不是读指针的索引值，rindex+rindex_shown才是。那么rindex_shown又是什么值呢？我们先看下面的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">frame_queue_next</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;keep_last &amp;&amp; !f-&gt;rindex_shown) &#123;</span><br><span class="line">    f-&gt;rindex_shown = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  frame_queue_unref_item(&amp;f-&gt;<span class="built_in">queue</span>[f-&gt;rindex]);</span><br><span class="line">  <span class="keyword">if</span> (++f-&gt;rindex == f-&gt;max_size)</span><br><span class="line">    f-&gt;rindex = <span class="number">0</span>;</span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  f-&gt;size--;</span><br><span class="line">  SDL_CondSignal(f-&gt;cond);</span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与写操作写入数据成功后直接更新写指针以及size值不同，读操作在更新读指针以及size值之前需要对已读节点的数据进行释放，也就是调用frame_queue_unref_item函数。在此之前，函数先判断keep_last的值，当程序要求保留上一帧时，即keep_last的值为1时，如果rindex_shown此时的值为0，它将被设置为1。</p><p>我们再回过头去看几个读函数的操作，用rindex+rindex_shown作为真正的读指针，而更新读指针销毁数据时却使用rindex，如果rindex_shown为零也就是不需要保留上一帧时，rindex等于rindex_shown，程序执行的操作就是读完一帧然后销毁刚读完的这一帧。而当rindex_shown为1时，真正的读指针是指向rindex的下一个节点的数据，那么相对于读操作来讲，刚读完一帧数据并且移动读指针时，销毁的其实是刚读的这一帧的上一帧数据，刚读过的这一帧数据得以保留。</p><p>我们再来看一下frame_queue_peek_readable函数中判断当前队列中是否存在未读结点使用的判断条件是</p><p><code>f-&gt;size - f-&gt;rindex_shown &lt;= 0</code></p><p>我们再来带入一下两种情况，当rindex_shown等于0即不需要保留上一帧数据时，判断条件相当于size&lt;&#x3D;0，这很好理解。当rindex_shown等于1即需要保留上一帧数据是，判断条件相当于size&lt;&#x3D;1,这是因为size表示的是未读结点的数量，而当rindex_shown等于1时，上一帧的数据是已读未擦除状态，所以在这种情况下当size等于1时，剩下的这一帧数据已经被读过了。</p><p>剩下两个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">frame_queue_nb_remaining</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> f-&gt;size - f-&gt;rindex_shown;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int64_t</span> <span class="title function_">frame_queue_last_pos</span><span class="params">(FrameQueue *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  Frame *fp = &amp;f-&gt;<span class="built_in">queue</span>[f-&gt;rindex];</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;rindex_shown &amp;&amp; fp-&gt;serial == f-&gt;pktq-&gt;serial)</span><br><span class="line">    <span class="keyword">return</span> fp-&gt;pos;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>frame_queue_nb_remaining返回队列中未被读取的值，为什么用size-rindex_shown，因为如果有保留帧，那么跟rindex同步更新的size值一定会比实际的未读取的节点数量值大1。</p><p>frame_queue_last_pos返回上一帧的位置，只有队列有保留帧的时候该函数才会返回上一帧的位置，否则返回-1。</p><p>ffplay中需要保留上一帧的流有视频流和音频流。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（三）：PacketQueue</title>
      <link href="/2022/11/29/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9APacketQueue/"/>
      <url>/2022/11/29/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9APacketQueue/</url>
      
        <content type="html"><![CDATA[<p>ffmpeg库解析音视频数据的顺序是先解封装（demuxing）再解码（decoding），其中解封装是从原始数据中分离出不同的数据流，如音频流，视频流等。解码是将从音视频流中读取的压缩数据解析成音视频输出设备可以识别的数据格式，音频如PCM，视频如YUV420P等。ffmpeg相关库的实现中，负责保存压缩数据的数据结构为struct AVPacket，负责保存解码后数据的数据结构为struct AVFrame。ffplay为存放这两种类型的数据创建了两个队列，存放AVPacket的队列就是本章介绍的PacketQueue，存放AVFrame的队列是我们下一章要介绍的FrameQueue；</p><p>先来看一下PacketQueue相关的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyAVPacketList</span> &#123;</span></span><br><span class="line">  AVPacket *pkt;<span class="comment">//压缩的包数据</span></span><br><span class="line">  <span class="type">int</span> serial;<span class="comment">//包序列号，跟所在的包序列的序列号一致</span></span><br><span class="line">&#125; MyAVPacketList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PacketQueue</span> &#123;</span></span><br><span class="line">  AVFifoBuffer *pkt_list;<span class="comment">//先进先出队列</span></span><br><span class="line">  <span class="type">int</span> nb_packets;<span class="comment">//队列中包的数量</span></span><br><span class="line">  <span class="type">int</span> size;<span class="comment">//队列大小</span></span><br><span class="line">  <span class="type">int64_t</span> duration;<span class="comment">//队列中数据的播放持续时间</span></span><br><span class="line">  <span class="type">int</span> abort_request;<span class="comment">//结束请求</span></span><br><span class="line">  <span class="type">int</span> serial;<span class="comment">//序列号，用于标识一段连续数据</span></span><br><span class="line">  SDL_mutex *mutex;<span class="comment">//线程互斥量</span></span><br><span class="line">  SDL_cond *cond;<span class="comment">//线程条件变量</span></span><br><span class="line">&#125; PacketQueue;</span><br></pre></td></tr></table></figure><p>PacketQueue结构体中各个参数的含义已经在注释中写明，PacketQueue的操作函数有以下几个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_put_private</span><span class="params">(PacketQueue *q, AVPacket *pkt)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_put</span><span class="params">(PacketQueue *q, AVPacket *pkt)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_put_nullpacket</span><span class="params">(PacketQueue *q, AVPacket *pkt, <span class="type">int</span> stream_index)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_init</span><span class="params">(PacketQueue *q)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">packet_queue_flush</span><span class="params">(PacketQueue *q)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">packet_queue_destroy</span><span class="params">(PacketQueue *q)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">packet_queue_abort</span><span class="params">(PacketQueue *q)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">packet_queue_start</span><span class="params">(PacketQueue *q)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_get</span><span class="params">(PacketQueue *q, AVPacket *pkt, <span class="type">int</span> block, <span class="type">int</span> *serial)</span>;</span><br></pre></td></tr></table></figure><p>packet_queue_init用memset函数将结构体所在内存以0初始化，这样可以将结构体中int类型的值初始化为0。然后创建一个fifo队列和用于线程同步的互斥量以及条件变量，最后将abort_request设置为1表示队列当前状态不可用；</p><p>packet_queue_flush函数将队列中数据清空，serial值加1，这些操作都在上锁状态下执行，相同的serial值表明这些数据是一段连续的内容，flush操作清空并丢弃了队列中还未被读取的数据，所以通过serial加1来表示接下来的数据跟之前的数据表示的已经不是连续的内容了；</p><p>packet_queue_destory调用flush函数清空数据，然后销毁fifo队列，以及互斥量和条件变量；</p><p>packet_queue_abort在上锁状态下将abort_request设置为1，并调用SDL_ConSignal()函数通知条件变量；</p><p>packet_queue_start函数在上锁状态下将abort_request设置为0，serial加1；</p><p>packet_queue_get是唯一的读取函数接受四个参数，第一个参数q指定PacketQueue，第二个参数pkt是一个指向AVPacket的指针，用于存储从q中读出的数据，第三个参数表示是否为阻塞模式，如果为0，那么当队列中没有数据时，函数会立即返回，否则将会调用SDL_CondWait()等待直到队列中有数据。第四个参数是一个传入的int变量地址，从fifo队列中读取的MyAVPacketList类型数据包含AVPacket类型的数据和一个序列号，这个序列号会被传给第四个参数指定的int变量。</p><p>packet_queue_put_private函数负责将参数pkt指向的AVPacket类型的数据连同队列q的序列号一起包装成一个MyAVPacketList类型数据写入fifo队列，然后将nb_packets加1，size加上MyAVPacketList的大小和其指向的AVPacket的大小，duration加上AVPacket的duration。写入成功后调用SDL_CondSignal()通知条件变量。该函数是执行具体写入动作的函数，只是供packet_queue_put函数调用，所以函数中没有上锁。</p><p>packet_queue_put检查参数pkt指定的数据是否为null，不为null时才在上锁状态下调用packet_queue_put_private执行真正的写入。</p><p>packet_queue_put_nullpacket用于向队列中写入一个没有数据的AVPecket包，设置了pkg的stream_index后直接调用packet_queue_put。该函数存在的意义是一个空包可以作为一个刷新包通知解码器已经到达流结束的位置了，解码器读到刷新包后会将缓存的帧数据返回。</p><p>分析完所有函数的功能，我们做一个简短的总结。PacketQueue中维护了一个fifo队列，队列中存储MyAVPacketList类型数据而不直接存储AVPacket类型数据的原因是需要为每个包添加一个序列号，这个序列号在包被放入队列时会被设置为队列的序列号，序列号用于标识一段连续的内容，如果两个包的序列号不同，说明他们所表示的内容时间上不连续。需要互斥量和条件变量的原因是队列的读写操作分别在不同线程，需要线程同步。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（二）：VideoState结构体</title>
      <link href="/2022/11/29/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AVideoState%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2022/11/29/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AVideoState%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p>VideoState结构体是ffplay源码里最重要也是最庞大的一个结构体，可以说是“包罗万象”，整个源码读下来给人的感觉就是只要是需要在函数间传递的参数，都会被放进这个结构体，然后相关的函数之间传VideoState的指针就好。这样做的好处是不用费力为每个函数想不同的参数名，后期增删参数时只需要修改VideoState结构体以及使用到该参数的某几行代码而不用修改所有相关函数的调用。坏处就是代码的耦合度太高了，不过对于单个源文件写完所有功能的ffplay来说，这并不算是什么大问题。</p><p>VideoState结构体的注释如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VideoState</span> &#123;</span><br><span class="line">  SDL_Thread *read_tid;<span class="comment">//读线程id</span></span><br><span class="line">  <span class="type">const</span> AVInputFormat *iformat;<span class="comment">//输入文件格式</span></span><br><span class="line">  <span class="type">int</span> abort_request;<span class="comment">//为1时，读线程退出</span></span><br><span class="line">  <span class="type">int</span> force_refresh;<span class="comment">//强制刷新标志位</span></span><br><span class="line">  <span class="type">int</span> paused;<span class="comment">//播放暂停标志位</span></span><br><span class="line">  <span class="type">int</span> last_paused;<span class="comment">//上一次设置的paused标志位</span></span><br><span class="line">  <span class="type">int</span> queue_attachments_req;<span class="comment">//请求流中的附加信息（如封面图片）的标志位</span></span><br><span class="line">  <span class="type">int</span> seek_req;<span class="comment">//查找请求</span></span><br><span class="line">  <span class="type">int</span> seek_flags;<span class="comment">//指定查找行为的标志位</span></span><br><span class="line">  <span class="type">int64_t</span> seek_pos;<span class="comment">//查找位置</span></span><br><span class="line">  <span class="type">int64_t</span> seek_rel;<span class="comment">//查找粒度</span></span><br><span class="line">  <span class="type">int</span> read_pause_return;<span class="comment">//保存av_read_pause()函数的返回值</span></span><br><span class="line">  AVFormatContext *ic;</span><br><span class="line">  <span class="type">int</span> realtime;<span class="comment">//是否是实时流</span></span><br><span class="line"></span><br><span class="line">  Clock audclk;<span class="comment">//音频流时钟</span></span><br><span class="line">  Clock vidclk;<span class="comment">//视频流时钟</span></span><br><span class="line">  Clock extclk;<span class="comment">//外部时钟</span></span><br><span class="line"></span><br><span class="line">  FrameQueue pictq;<span class="comment">//视频流的帧队列</span></span><br><span class="line">  FrameQueue subpq;<span class="comment">//字幕流的帧队列</span></span><br><span class="line">  FrameQueue sampq;<span class="comment">//音频流的帧队列</span></span><br><span class="line"></span><br><span class="line">  Decoder auddec;<span class="comment">//音频解码器</span></span><br><span class="line">  Decoder viddec;<span class="comment">//视频解码器</span></span><br><span class="line">  Decoder subdec;<span class="comment">//字幕解码器</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> audio_stream;<span class="comment">//音频流序号</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> av_sync_type;<span class="comment">//音视频同步模式</span></span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> audio_clock;<span class="comment">//音频时钟数值</span></span><br><span class="line">  <span class="type">int</span> audio_clock_serial;<span class="comment">//音频时钟序列号</span></span><br><span class="line">  <span class="type">double</span> audio_diff_cum; <span class="comment">/* used for AV difference average computation */</span></span><br><span class="line">  <span class="type">double</span> audio_diff_avg_coef;</span><br><span class="line">  <span class="type">double</span> audio_diff_threshold;</span><br><span class="line">  <span class="type">int</span> audio_diff_avg_count;<span class="comment">//以上几个值用于计算音频重采样的样本数</span></span><br><span class="line">  AVStream *audio_st;<span class="comment">//指向音频流的指针</span></span><br><span class="line">  PacketQueue audioq;<span class="comment">//音频流的包队列</span></span><br><span class="line">  <span class="type">int</span> audio_hw_buf_size;<span class="comment">//硬件支持的音频缓冲区大小</span></span><br><span class="line">  <span class="type">uint8_t</span> *audio_buf;<span class="comment">//指向储存音频数据的缓冲区</span></span><br><span class="line">  <span class="type">uint8_t</span> *audio_buf1;<span class="comment">//指向储存音频数据的缓冲区</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> audio_buf_size; <span class="comment">/* in bytes */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> audio_buf1_size;<span class="comment">//缓冲区大小</span></span><br><span class="line">  <span class="type">int</span> audio_buf_index; <span class="comment">/* 音频缓冲区读取位置 in bytes */</span></span><br><span class="line">  <span class="type">int</span> audio_write_buf_size;<span class="comment">//音频缓冲区中可写区域的大小</span></span><br><span class="line">  <span class="type">int</span> audio_volume;<span class="comment">//音量值</span></span><br><span class="line">  <span class="type">int</span> muted;<span class="comment">//是否静音</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">AudioParams</span> audio_src;<span class="comment">//音频参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_AVFILTER</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">AudioParams</span> audio_filter_src;<span class="comment">//滤镜处理后的音频参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">AudioParams</span> audio_tgt;<span class="comment">//硬件支持的音频参数</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">SwrContext</span> *swr_ctx;<span class="comment">//音频重采样上下文</span></span><br><span class="line">  <span class="type">int</span> frame_drops_early;<span class="comment">//解码过程中的丢帧数</span></span><br><span class="line">  <span class="type">int</span> frame_drops_late;<span class="comment">//渲染过程中的丢帧数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">ShowMode</span> &#123;</span><br><span class="line">    SHOW_MODE_NONE = <span class="number">-1</span>, SHOW_MODE_VIDEO = <span class="number">0</span>, SHOW_MODE_WAVES, SHOW_MODE_RDFT, SHOW_MODE_NB</span><br><span class="line">  &#125; show_mode;<span class="comment">//显示模式，分为视频模式，波形图模式以及频谱图</span></span><br><span class="line">  <span class="type">int16_t</span> sample_array[SAMPLE_ARRAY_SIZE];<span class="comment">//音频样本数组</span></span><br><span class="line">  <span class="type">int</span> sample_array_index;<span class="comment">//样本数组的读取位置</span></span><br><span class="line">  <span class="type">int</span> last_i_start;</span><br><span class="line">  RDFTContext *rdft;<span class="comment">//实时傅里叶变换上下文</span></span><br><span class="line">  <span class="type">int</span> rdft_bits;</span><br><span class="line">  FFTSample *rdft_data;</span><br><span class="line">  <span class="type">int</span> xpos;</span><br><span class="line">  <span class="type">double</span> last_vis_time;</span><br><span class="line">  SDL_Texture *vis_texture;<span class="comment">//用于渲染音频图像的纹理结构体指针</span></span><br><span class="line">  SDL_Texture *sub_texture;<span class="comment">//用于渲染字幕的纹理结构体指针</span></span><br><span class="line">  SDL_Texture *vid_texture;<span class="comment">//用于渲染视频的纹理结构体指针</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> subtitle_stream;<span class="comment">//字幕流序号</span></span><br><span class="line">  AVStream *subtitle_st;<span class="comment">//指向字幕流的指针</span></span><br><span class="line">  PacketQueue subtitleq;<span class="comment">//字幕流的包队列</span></span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> frame_timer;<span class="comment">//帧计时器</span></span><br><span class="line">  <span class="type">double</span> frame_last_returned_time;</span><br><span class="line">  <span class="type">double</span> frame_last_filter_delay;</span><br><span class="line">  <span class="type">int</span> video_stream;<span class="comment">//视频流序号</span></span><br><span class="line">  AVStream *video_st;<span class="comment">//视频流指针</span></span><br><span class="line">  PacketQueue videoq;<span class="comment">//视频流包队列</span></span><br><span class="line">  <span class="type">double</span> max_frame_duration; <span class="comment">//单个帧最大的持续时间   // maximum duration of a frame - above this, we consider the jump a timestamp discontinuity</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">SwsContext</span> *img_convert_ctx;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">SwsContext</span> *sub_convert_ctx;</span><br><span class="line">  <span class="type">int</span> eof;<span class="comment">//文件结束标志位</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *filename;<span class="comment">//文件名</span></span><br><span class="line">  <span class="type">int</span> width, height, xleft, ytop;<span class="comment">//窗口的位置和大小</span></span><br><span class="line">  <span class="type">int</span> step;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_AVFILTER</span></span><br><span class="line">  <span class="type">int</span> vfilter_idx;</span><br><span class="line">  AVFilterContext *in_video_filter;   <span class="comment">// the first filter in the video chain</span></span><br><span class="line">  AVFilterContext *out_video_filter;  <span class="comment">// the last filter in the video chain</span></span><br><span class="line">  AVFilterContext *in_audio_filter;   <span class="comment">// the first filter in the audio chain</span></span><br><span class="line">  AVFilterContext *out_audio_filter;  <span class="comment">// the last filter in the audio chain</span></span><br><span class="line">  AVFilterGraph *agraph;              <span class="comment">// audio filter graph</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> last_video_stream, last_audio_stream, last_subtitle_stream;<span class="comment">//上一次使用的流，用于循环播放</span></span><br><span class="line"></span><br><span class="line">  SDL_cond *continue_read_thread;<span class="comment">//控制读线程是否继续读的条件变量</span></span><br><span class="line">&#125; VideoState;</span><br></pre></td></tr></table></figure><p>结构体中某些参数单从注释上很难理解其具体含义，所以在之后的源码分析中我们会反复回来看这个结构体的内容。</p><p>在分析具体代码逻辑之前，我们需要知道ffplay中用到的两个队列的用法：PacketQueue，FrameQueue。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffplay源码解析（一）：main函数</title>
      <link href="/2022/11/27/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Amain%E5%87%BD%E6%95%B0/"/>
      <url>/2022/11/27/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Amain%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>ffplay源码的main函数逻辑较为简单，根据任务划分主要做了如下几件事：</p><p>1、解析参数</p><p>2、初始化相关库</p><p>3、创建SDL窗口及其对应的渲染器</p><p>4、打开流</p><p>5、开启主循环</p><p>其中解析参数这一步调用的函数是根据ffmpeg的参数规则专门编写的，具体实现在cmdutils.c中。这部分实现是ffmpeg，ffplay和ffplay三个项目共用的。当我们单独分析ffplay源码时，我们不需要知道具体的实现细节，只需要知道这一步是修改ffplay.c源文件开头定义的用于表示用户行为的静态变量就可以了，具体的变量可以在后面分析源码的时候遇到了再回头看对应的参数。</p><p>用户可以定义的静态变量有以下这些：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">static const AVInputFormat *file_iformat;//对应-f参数指定的文件格式，默认是自动判断不需要手动指定</span><br><span class="line">static const char *input_filename;//输入文件名</span><br><span class="line">static const char *window_title;//主窗口标题</span><br><span class="line">static int default_width  = 640;//主窗口默认宽度</span><br><span class="line">static int default_height = 480;//主窗口默认高度</span><br><span class="line">static int screen_width  = 0;</span><br><span class="line">static int screen_height = 0;//屏幕默认宽高，没有对应参数</span><br><span class="line">static int screen_left = SDL_WINDOWPOS_CENTERED;//设置窗口左方的的x坐标，默认居中，对应参数-left</span><br><span class="line">static int screen_top = SDL_WINDOWPOS_CENTERED;//设置窗口上方的y坐标，默认居中，对应参数-top</span><br><span class="line">static int audio_disable;//关闭音频，对应参数-an</span><br><span class="line">static int video_disable;//关闭视频，对应参数-vn</span><br><span class="line">static int subtitle_disable;//关闭字幕，对应参数-sn</span><br><span class="line">static const char* wanted_stream_spec[AVMEDIA_TYPE_NB] = &#123;0&#125;;//用户设置的期望使用的流，对应参数-ast,-vst,-sst</span><br><span class="line">static int seek_by_bytes = -1;//按字节seek，对应参数-bytes</span><br><span class="line">static float seek_interval = 10;//查找间隔(步长)，对应参数-seek_interval</span><br><span class="line">static int display_disable;//关闭显示，对应参数-nodisp</span><br><span class="line">static int borderless;//窗口无边框，对应参数-noborder</span><br><span class="line">static int alwaysontop;//窗口置顶，对应参数-alwaysontop</span><br><span class="line">static int startup_volume = 100;//初始音量，对应参数-volume</span><br><span class="line">static int show_status = -1;//是否打印状态信息，对应参数-stats</span><br><span class="line">static int av_sync_type = AV_SYNC_AUDIO_MASTER;//音视频同步模式，对应参数-sync</span><br><span class="line">static int64_t start_time = AV_NOPTS_VALUE;//开始时间，对应参数-ss</span><br><span class="line">static int64_t duration = AV_NOPTS_VALUE;//持续时长，对应参数-t，这两个参数用于播放指定时间段的内容</span><br><span class="line">static int fast = 0;//允许使用非标准的加速解码手段，对应参数-fast</span><br><span class="line">static int genpts = 0;//生成时间戳，对应参数-genpts</span><br><span class="line">static int lowres = 0;//低分辨率解码</span><br><span class="line">static int decoder_reorder_pts = -1;//让解码器对pts重新排序，对应参数-drp</span><br><span class="line">static int autoexit;//播放结束自动退出，对应参数-autoexit</span><br><span class="line">static int exit_on_keydown;//按键退出播放，对应参数-exitonkeydown</span><br><span class="line">static int exit_on_mousedown;//按下鼠标退出播放，对应参数-exitonmousedown</span><br><span class="line">static int loop = 1;//循环播放，对应参数-loop</span><br><span class="line">static int framedrop = -1;//是否允许cpu性能达不到要求时丢帧，对应参数-framedrop</span><br><span class="line">static int infinite_buffer = -1;//是否限制输入缓冲区大小，对应参数-infbuf</span><br><span class="line">static enum ShowMode show_mode = SHOW_MODE_NONE;//显示模式</span><br><span class="line">static const char *audio_codec_name;//音频解码器名称，对应参数-acodec</span><br><span class="line">static const char *subtitle_codec_name;//字幕解码器名称，对应参数-scodec</span><br><span class="line">static const char *video_codec_name;//视频解码器名称，对应参数-vcodec</span><br><span class="line">double rdftspeed = 0.02;//rdft速度，对应参数-rdftspeed</span><br><span class="line">static int64_t cursor_last_shown;</span><br><span class="line">static int cursor_hidden = 0;</span><br><span class="line">#if CONFIG_AVFILTER</span><br><span class="line">static const char **vfilters_list = NULL;</span><br><span class="line">static int nb_vfilters = 0;</span><br><span class="line">static char *afilters = NULL;</span><br><span class="line">#endif</span><br><span class="line">static int autorotate = 1;//自动旋转视频，对应参数-autorotate</span><br><span class="line">static int find_stream_info = 1;//查询流信息，对应参数-find_stream_info</span><br><span class="line">static int filter_nbthreads = 0;//filter线程数，对应参数-filter_threads</span><br><span class="line"></span><br><span class="line">/* current context */</span><br><span class="line">static int is_full_screen;//是否全屏，对应参数-fs</span><br></pre></td></tr></table></figure><p>带注释的完整main函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flags;<span class="comment">//用于创建SDL窗口时指定flag</span></span><br><span class="line">  VideoState *is;</span><br><span class="line"></span><br><span class="line">  init_dynload();<span class="comment">//当前只做一件事，在win32平台将当前工作目录从DLL搜索路径中移除</span></span><br><span class="line"></span><br><span class="line">  av_log_set_flags(AV_LOG_SKIP_REPEATED);<span class="comment">//折叠重复日志</span></span><br><span class="line">  parse_loglevel(argc, argv, options);<span class="comment">//解析loglevel</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* register all codecs, demux and protocols */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_AVDEVICE</span></span><br><span class="line">  avdevice_register_all();<span class="comment">//初始化libavdeivce库并且注册所有输入输出设备</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  avformat_network_init();<span class="comment">//初始化网络库</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//指定SIGINT和SIGTERM两个信号的处理函数</span></span><br><span class="line">  signal(SIGINT , sigterm_handler); <span class="comment">/* Interrupt (ANSI).    */</span></span><br><span class="line">  signal(SIGTERM, sigterm_handler); <span class="comment">/* Termination (ANSI).  */</span></span><br><span class="line"></span><br><span class="line">  show_banner(argc, argv, options);<span class="comment">//打印程序和库的信息</span></span><br><span class="line"></span><br><span class="line">  parse_options(<span class="literal">NULL</span>, argc, argv, options, opt_input_file);<span class="comment">//解析参数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*必须有输入文件，否则退出*/</span></span><br><span class="line">  <span class="keyword">if</span> (!input_filename) &#123;</span><br><span class="line">    show_usage();</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;An input file must be specified\n&quot;</span>);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL,</span><br><span class="line">           <span class="string">&quot;Use -h to get full help or, even better, run &#x27;man %s&#x27;\n&quot;</span>, program_name);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*判断是否显示画面*/</span></span><br><span class="line">  <span class="keyword">if</span> (display_disable) &#123;<span class="comment">//display_disable通过命令行参数-nodisp设置</span></span><br><span class="line">    video_disable = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  flags = SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER;<span class="comment">//默认加载SDL的video、audio和timer子系统</span></span><br><span class="line">  <span class="keyword">if</span> (audio_disable)<span class="comment">//audio_disable通过命令行参数-an设置</span></span><br><span class="line">    flags &amp;= ~SDL_INIT_AUDIO;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Try to work around an occasional ALSA buffer underflow issue when the</span></span><br><span class="line"><span class="comment">     * period size is NPOT due to ALSA resampling by forcing the buffer size. */</span></span><br><span class="line">    <span class="keyword">if</span> (!SDL_getenv(<span class="string">&quot;SDL_AUDIO_ALSA_SET_BUFFER_SIZE&quot;</span>))</span><br><span class="line">      SDL_setenv(<span class="string">&quot;SDL_AUDIO_ALSA_SET_BUFFER_SIZE&quot;</span>,<span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (display_disable)</span><br><span class="line">    flags &amp;= ~SDL_INIT_VIDEO;</span><br><span class="line">  <span class="keyword">if</span> (SDL_Init (flags)) &#123;<span class="comment">//用配置好的flags初始化SDL</span></span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Could not initialize SDL - %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;(Did you set the DISPLAY variable?)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//忽略事件</span></span><br><span class="line">  SDL_EventState(SDL_SYSWMEVENT, SDL_IGNORE);</span><br><span class="line">  SDL_EventState(SDL_USEREVENT, SDL_IGNORE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!display_disable) &#123;</span><br><span class="line">    <span class="type">int</span> flags = SDL_WINDOW_HIDDEN;<span class="comment">//配置SDL创建窗口的标志位</span></span><br><span class="line">    <span class="keyword">if</span> (alwaysontop)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SDL_VERSION_ATLEAST(2,0,5)</span></span><br><span class="line">      flags |= SDL_WINDOW_ALWAYS_ON_TOP;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;Your SDL version doesn&#x27;t support SDL_WINDOW_ALWAYS_ON_TOP. Feature will be inactive.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (borderless)</span><br><span class="line">      flags |= SDL_WINDOW_BORDERLESS;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      flags |= SDL_WINDOW_RESIZABLE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR</span></span><br><span class="line">    SDL_SetHint(SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR, <span class="string">&quot;0&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    window = SDL_CreateWindow(program_name, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, default_width, default_height, flags);<span class="comment">//创建SDL窗口</span></span><br><span class="line">    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, <span class="string">&quot;linear&quot;</span>);<span class="comment">//设置默认的图片缩放质量为线性</span></span><br><span class="line">    <span class="keyword">if</span> (window) &#123;</span><br><span class="line">      renderer = SDL_CreateRenderer(window, <span class="number">-1</span>, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);<span class="comment">//从窗口创建渲染器</span></span><br><span class="line">      <span class="keyword">if</span> (!renderer) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;Failed to initialize a hardware accelerated renderer: %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">        renderer = SDL_CreateRenderer(window, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (renderer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!SDL_GetRendererInfo(renderer, &amp;renderer_info))<span class="comment">//打印渲染器信息</span></span><br><span class="line">          av_log(<span class="literal">NULL</span>, AV_LOG_VERBOSE, <span class="string">&quot;Initialized %s renderer.\n&quot;</span>, renderer_info.name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!window || !renderer || !renderer_info.num_texture_formats) &#123;<span class="comment">//打印失败信息</span></span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Failed to create window or renderer: %s&quot;</span>, SDL_GetError());</span><br><span class="line">      do_exit(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  is = stream_open(input_filename, file_iformat);<span class="comment">//打开视频/音频/字幕流</span></span><br><span class="line">  <span class="keyword">if</span> (!is) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Failed to initialize VideoState!\n&quot;</span>);</span><br><span class="line">    do_exit(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  event_loop(is);<span class="comment">//开启SDL事件循环</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* never returns */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码篇幅上看，main函数中绝大多数代码是用来配置SDL_init()和SDL_CreateWindow()这两个函数的标志位flags的。</p><p>其中SDL_Init()函数是用来初始化SDL库的，在使用任何SDL库函数之前必须先调用这个函数。SDL_Init接受一个Uint32类型的flags参数用来初始化SDL子系统，如SDL_INIT_AUDIO表示音频子系统，SDL_INIT_VIDEO表示视频子系统等，可以通过位或操作组合多个标志位来初始化多个子系统的目的，如SDL_INIT_AUDIO|SDL_INIT_VIDEO表示初始化音频子系统和视频子系统。SDL_Init()可用的标志位及其含义如下：</p><p>SDL_INIT_TIMER: timer subsystem<br>SDL_INIT_AUDIO: audio subsystem<br>SDL_INIT_VIDEO: video subsystem; automatically initializes the events subsystem<br>SDL_INIT_JOYSTICK: joystick subsystem; automatically initializes the events subsystem<br>SDL_INIT_HAPTIC: haptic (force feedback) subsystem<br>SDL_INIT_GAMECONTROLLER: controller subsystem; automatically initializes the joystick subsystem<br>SDL_INIT_EVENTS: events subsystem<br>SDL_INIT_EVERYTHING: all of the above subsystems<br>SDL_INIT_NOPARACHUTE: compatibility; this flag is ignored</p><p>完成SDL库的初始化后，接着开始创建主窗口以及对应的渲染器，主要使用SDL_CreateWindow()和SDL_CreateRenderer()这两个函数，创建成功以及打印完相关信息后，main函数中的可以归属为”初始化任务”的代码就结束了。</p><p>接下来的代码更简单直接，只是调用了stream_open()和event_loop()这两个函数。从函数名推断stream_open()用来打开流，event_loop()用来处理事件循环。事实也正是如此，不过有亿点不同的是：stream_open()不仅完成了打开流的工作，还完成了所有流的读取以及音频流向音频设备的输出；event_loop()除了处理SDL的事件循环，还负责视频流以及字幕流向显示设备的输出。</p>]]></content>
      
      
      <categories>
          
          <category> ffplay源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffplay </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
