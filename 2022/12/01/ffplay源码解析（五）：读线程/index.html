<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="ffplay源码解析">
    <meta name="description" content="好记性不如烂笔头">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>ffplay源码解析（五）：读线程 | wenxy的博客</title>
    <link rel="icon" type="image/png" href="/me.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">wenxy的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">wenxy的博客</div>
        <div class="logo-desc">
            
            好记性不如烂笔头
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/8.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">ffplay源码解析（五）：读线程</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="container content">

    
    <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/ffplay/">
                                <span class="chip bg-color">ffplay</span>
                            </a>
                        
                            <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">
                                <span class="chip bg-color">源码解析</span>
                            </a>
                        
                            <a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/">
                                <span class="chip bg-color">音视频</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-category">
                                ffplay源码解析
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-12-01
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2022-12-02
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    5.8k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    25 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        
        <!-- 代码块折行 -->
        <style type="text/css">
            code[class*="language-"], pre[class*="language-"] { white-space: pre-wrap !important; }
        </style>
        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>在分析main函数的时候我们已经提到过stream_open函数，本章我们开始对其进行分析。stream_open函数的源码结构一目了然，主要做了如下几件事：</p>
<p>1.创建一个VideoState结构体指针变量is，为其分配内存并以0初始化；</p>
<p>2.为创建好的结构体变量的成员赋初值，stream_open函数接受两个参数，第一个参数是文件名，第二个参数是用户指定的文件格式，也在这一步赋给相应的结构体成员；</p>
<p>3.初始化结构体变量中对应视频流，音频流，字幕流的三个FrameQueue，其中视频流和音频流的keep_last值被设置为1，这个值的具体作用我们上一章已经介绍过；</p>
<p>4.初始化结构体变量中对应视频流，音频流，字幕流的三个PacketQueue；</p>
<p>5.创建continue_read_thread这个用于读写同步的条件变量；</p>
<p>6.初始化三个流对应的clock时钟结构体；</p>
<p>7.设置音量；</p>
<p>8.打开read_thread线程。</p>
<p>可以看到stream_open函数主要做的事情就是创建并初始化VideoState结构体变量，初始化完成后打开read_thread线程，然后函数就退出了。从代码中看除了调用相应的函数初始化FrameQueue和PacketQueue以外，函数初始化了三个时钟结构体，分别对应三个流。ffplay为每个流分配了一个Clock结构体类型的变量，其中包含了时间，偏移量，时钟速度等等一些成员，所有成员类型都是double或int。时钟的作用在后面我们分析到音视频同步的时候会详细介绍，现在只需要知道stream_open函数中完成了三个流对应时钟的初始化即可。</p>
<p>接下来我们看一下read_thread主要做了哪些事。根据任务类型我们可以将read_thread的代码氛围三部分：打开文件，打开流，主循环读流。</p>
<p>首先我们看一下打开文件部分的代码，我精简掉了一些变量声明，错误检查，打印信息的代码，只保留了重要部分以方便阅读。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> st_index[AVMEDIA_TYPE_NB];<span class="comment">//存储各个类型的流对应的序号</span></span><br><span class="line"> <span class="built_in">memset</span>(st_index, <span class="number">-1</span>, <span class="keyword">sizeof</span>(st_index));</span><br><span class="line"> pkt = av_packet_alloc();<span class="comment">//创建一个默认初始化的AVPacket</span></span><br><span class="line"> ic = avformat_alloc_context();<span class="comment">//创建一个默认初始化的AVFormatContext</span></span><br><span class="line"> ic-&gt;interrupt_callback.callback = decode_interrupt_cb;<span class="comment">//中断回调函数，当ffmpeg的io库在执行阻塞操作时，这个函数会被间歇性的调用，当函数的返回值为1时，io库会终止阻塞操作</span></span><br><span class="line"> ic-&gt;interrupt_callback.opaque = is;</span><br><span class="line"> <span class="keyword">if</span> (!av_dict_get(format_opts, <span class="string">&quot;scan_all_pmts&quot;</span>, <span class="literal">NULL</span>, AV_DICT_MATCH_CASE)) &#123;<span class="comment">//设置mpegts的scan_all_pmts选项，该选项的含义是扫描并组合所有ts流的Program Map Table</span></span><br><span class="line">   av_dict_set(&amp;format_opts, <span class="string">&quot;scan_all_pmts&quot;</span>, <span class="string">&quot;1&quot;</span>, AV_DICT_DONT_OVERWRITE);<span class="comment">//所以这里是针对mpegts封装单独设置的选项</span></span><br><span class="line">   scan_all_pmts_set = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> err = avformat_open_input(&amp;ic, is-&gt;filename, is-&gt;iformat, &amp;format_opts);<span class="comment">//打开文件，传入AVFormatContext变量，文件名和格式，以及保存选项信息的字典format_opts,文件打开后，format_opts会被擦除并且写入未被发现的选项</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (scan_all_pmts_set)</span><br><span class="line">   av_dict_set(&amp;format_opts, <span class="string">&quot;scan_all_pmts&quot;</span>, <span class="literal">NULL</span>, AV_DICT_MATCH_CASE);<span class="comment">//打开文件后将scan_all_pmts选项重置</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> ((t = av_dict_get(format_opts, <span class="string">&quot;&quot;</span>, <span class="literal">NULL</span>, AV_DICT_IGNORE_SUFFIX))) &#123;<span class="comment">//如果t不为NULL，说明打开文件时设置的选项中有不被支持的选项</span></span><br><span class="line">   av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Option %s not found.\n&quot;</span>, t-&gt;key);</span><br><span class="line">   ret = AVERROR_OPTION_NOT_FOUND;</span><br><span class="line">   <span class="keyword">goto</span> fail;</span><br><span class="line"> &#125;</span><br><span class="line"> is-&gt;ic = ic;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (genpts)</span><br><span class="line">   ic-&gt;flags |= AVFMT_FLAG_GENPTS;</span><br><span class="line"></span><br><span class="line"> av_format_inject_global_side_data(ic);<span class="comment">//将全局的side data注入到每个流的下一个AVPacket中</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (find_stream_info) &#123;<span class="comment">//校验用户指定的codec选项是否支持</span></span><br><span class="line">   AVDictionary **opts = setup_find_stream_info_opts(ic, codec_opts);</span><br><span class="line">   <span class="type">int</span> orig_nb_streams = ic-&gt;nb_streams;</span><br><span class="line"></span><br><span class="line">   err = avformat_find_stream_info(ic, opts);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; orig_nb_streams; i++)</span><br><span class="line">     av_dict_free(&amp;opts[i]);</span><br><span class="line">   av_freep(&amp;opts);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     av_log(<span class="literal">NULL</span>, AV_LOG_WARNING,</span><br><span class="line">            <span class="string">&quot;%s: could not find codec parameters\n&quot;</span>, is-&gt;filename);</span><br><span class="line">     ret = <span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">goto</span> fail;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (ic-&gt;pb)</span><br><span class="line">   ic-&gt;pb-&gt;eof_reached = <span class="number">0</span>; <span class="comment">// FIXME hack, ffplay maybe should not use avio_feof() to test for the end</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (seek_by_bytes &lt; <span class="number">0</span>)<span class="comment">//当封装格式允许时间戳不连续且不是ogg格式时，以byte查找，否则以时间查找</span></span><br><span class="line">   seek_by_bytes = !!(ic-&gt;iformat-&gt;flags &amp; AVFMT_TS_DISCONT) &amp;&amp; <span class="built_in">strcmp</span>(<span class="string">&quot;ogg&quot;</span>, ic-&gt;iformat-&gt;name);</span><br><span class="line"></span><br><span class="line"> is-&gt;max_frame_duration = (ic-&gt;iformat-&gt;flags &amp; AVFMT_TS_DISCONT) ? <span class="number">10.0</span> : <span class="number">3600.0</span>;<span class="comment">//每一帧最长时序时间，如果封装格式允许时间戳不连续时，为10秒，否则为3600秒。</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!window_title &amp;&amp; (t = av_dict_get(ic-&gt;metadata, <span class="string">&quot;title&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>)))</span><br><span class="line">   window_title = av_asprintf(<span class="string">&quot;%s - %s&quot;</span>, t-&gt;value, input_filename);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* if seeking requested, we execute it */</span></span><br><span class="line"> <span class="keyword">if</span> (start_time != AV_NOPTS_VALUE) &#123;</span><br><span class="line">   <span class="type">int64_t</span> timestamp;</span><br><span class="line"></span><br><span class="line">   timestamp = start_time;</span><br><span class="line">   <span class="comment">/* add the stream start time */</span></span><br><span class="line">   <span class="keyword">if</span> (ic-&gt;start_time != AV_NOPTS_VALUE)</span><br><span class="line">     timestamp += ic-&gt;start_time;</span><br><span class="line">   ret = avformat_seek_file(ic, <span class="number">-1</span>, INT64_MIN, timestamp, INT64_MAX, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;%s: could not seek to position %0.3f\n&quot;</span>,</span><br><span class="line">            is-&gt;filename, (<span class="type">double</span>)timestamp / AV_TIME_BASE);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> is-&gt;realtime = is_realtime(ic);<span class="comment">//是否是实时流</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (show_status)</span><br><span class="line">   av_dump_format(ic, <span class="number">0</span>, is-&gt;filename, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;<span class="comment">//判断用户指定的流是否可用，如果可用将流的序号设置到数组st_index相应的成员中</span></span><br><span class="line">   AVStream *st = ic-&gt;streams[i];</span><br><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">AVMediaType</span> <span class="title">type</span> =</span> st-&gt;codecpar-&gt;codec_type;</span><br><span class="line">   st-&gt;discard = AVDISCARD_ALL;</span><br><span class="line">   <span class="keyword">if</span> (type &gt;= <span class="number">0</span> &amp;&amp; wanted_stream_spec[type] &amp;&amp; st_index[type] == <span class="number">-1</span>)</span><br><span class="line">     <span class="keyword">if</span> (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) &gt; <span class="number">0</span>)</span><br><span class="line">       st_index[type] = i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; AVMEDIA_TYPE_NB; i++) &#123;</span><br><span class="line">   <span class="keyword">if</span> (wanted_stream_spec[i] &amp;&amp; st_index[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">     av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Stream specifier %s does not match any %s stream\n&quot;</span>, wanted_stream_spec[i], av_get_media_type_string(i));</span><br><span class="line">     st_index[i] = INT_MAX;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//结合用户指定的流查找出最好的流最为最终解析的流</span></span><br><span class="line"> <span class="keyword">if</span> (!video_disable)</span><br><span class="line">   st_index[AVMEDIA_TYPE_VIDEO] =</span><br><span class="line">       av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,</span><br><span class="line">                           st_index[AVMEDIA_TYPE_VIDEO], <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (!audio_disable)</span><br><span class="line">   st_index[AVMEDIA_TYPE_AUDIO] =</span><br><span class="line">       av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,</span><br><span class="line">                           st_index[AVMEDIA_TYPE_AUDIO],</span><br><span class="line">                           st_index[AVMEDIA_TYPE_VIDEO],</span><br><span class="line">                           <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (!video_disable &amp;&amp; !subtitle_disable)</span><br><span class="line">   st_index[AVMEDIA_TYPE_SUBTITLE] =</span><br><span class="line">       av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,</span><br><span class="line">                           st_index[AVMEDIA_TYPE_SUBTITLE],</span><br><span class="line">                           (st_index[AVMEDIA_TYPE_AUDIO] &gt;= <span class="number">0</span> ?</span><br><span class="line">                            st_index[AVMEDIA_TYPE_AUDIO] :</span><br><span class="line">                            st_index[AVMEDIA_TYPE_VIDEO]),</span><br><span class="line">                           <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> is-&gt;show_mode = show_mode;</span><br><span class="line"> <span class="keyword">if</span> (st_index[AVMEDIA_TYPE_VIDEO] &gt;= <span class="number">0</span>) &#123;<span class="comment">//从视频流中获取画面宽高，依次设置默认窗口大小</span></span><br><span class="line">   AVStream *st = ic-&gt;streams[st_index[AVMEDIA_TYPE_VIDEO]];</span><br><span class="line">   AVCodecParameters *codecpar = st-&gt;codecpar;</span><br><span class="line">   AVRational sar = av_guess_sample_aspect_ratio(ic, st, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">if</span> (codecpar-&gt;width)</span><br><span class="line">     set_default_window_size(codecpar-&gt;width, codecpar-&gt;height, sar);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注释已经说明了大部分代码的用途，这部分代码做的事主要是打开文件，获取流信息，结合用户指定的流说明符选取最优的流用于接下来的步骤。打开文件和获取流信息都是通过ffmpeg库函数实现的，没有复杂的逻辑，结合相关函数的注释很好理解。占用篇幅最大也是最不好理解的部分就是选取最优的流的相关操作。</p>
<p>首先定义了一个的数组:int st_index[AVMEDIA_TYPE_NB],这里涉及到一个枚举类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AVMediaType</span> &#123;</span></span><br><span class="line">    AVMEDIA_TYPE_UNKNOWN = <span class="number">-1</span>,  <span class="comment">///&lt; Usually treated as AVMEDIA_TYPE_DATA</span></span><br><span class="line">    AVMEDIA_TYPE_VIDEO,</span><br><span class="line">    AVMEDIA_TYPE_AUDIO,</span><br><span class="line">    AVMEDIA_TYPE_DATA,          <span class="comment">///&lt; Opaque data information usually continuous</span></span><br><span class="line">    AVMEDIA_TYPE_SUBTITLE,</span><br><span class="line">    AVMEDIA_TYPE_ATTACHMENT,    <span class="comment">///&lt; Opaque data information usually sparse</span></span><br><span class="line">    AVMEDIA_TYPE_NB</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用媒体类型作为数组索引，数组元素为int，数组元素是如何被赋值的呢？看下面的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;<span class="comment">//判断用户指定的流是否可用，如果可用将流的序号设置到数组st_index相应的成员中</span></span><br><span class="line">  AVStream *st = ic-&gt;streams[i];</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">AVMediaType</span> <span class="title">type</span> =</span> st-&gt;codecpar-&gt;codec_type;</span><br><span class="line">  st-&gt;discard = AVDISCARD_ALL;</span><br><span class="line">  <span class="keyword">if</span> (type &gt;= <span class="number">0</span> &amp;&amp; wanted_stream_spec[type] &amp;&amp; st_index[type] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) &gt; <span class="number">0</span>)</span><br><span class="line">      st_index[type] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; AVMEDIA_TYPE_NB; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (wanted_stream_spec[i] &amp;&amp; st_index[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Stream specifier %s does not match any %s stream\n&quot;</span>, wanted_stream_spec[i], av_get_media_type_string(i));</span><br><span class="line">    st_index[i] = INT_MAX;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中有一个特殊的数组wanted_stream_spec[],从数组的定义上我们会发现，这个数组的大小也是AVMEDIA_TYPE_NB，数组元素类型是const char*。这个数组中存储的是用户指定的流说明符，如wanted_stream_spec[AVMEDIA_TYPE_AUDIO]的值为”1“表示用户指定使用第二个音频流，wanted_stream_spec[AVMEDIA_TYPE_VIDEO]的值为”2“表示用户指定使用第三个视频流等。使用avformat_match_stream_specifier函数进行匹配，如果程序解析出的流与用户指定的流匹配，那么就将st_index[type]设置为这个流的序号，例如通过-vst 1指定第二个视频流，而文件解析出的第二个视频流对应的序号i为3，那么st_index[AVMEDIA_TYPE_VIDEO]的值就会被设置为3，如果没有匹配到，比如文件中只有一个视频流的时候，相应的值就不会被设置。还有一个逻辑就是st_index[type]一旦被设置过就不会再对同类型的流进行比对了。</p>
<p>接下来会将wanted_stream_spec和st_index进行比对，如果相同索引位置前者有值，而后者的值还是默认值-1，则表示用户指定的流没有被匹配到，随后后者的值会被设置为INT_MAX。</p>
<p>通过以上步骤，有可能某一类型的流未被指定，例如上面说到的，用户使用-vst 1指定第二个视频流，但是文件中却只含有一个视频流，这种情况下st_index[AVMEDIA_TYPE_VIDEO]会被设置为INT_MAX。所以就需要将合适的流序号赋给他，ffplay使用的方式是调用av_find_best_stream函数来找到最佳匹配，它会根据传入的参数选择一个最接近用户期望的流。</p>
<p>至此，st_index[]中已经保存了最优的流的序号，接下来就是打开这些流开始读取数据了。打开流的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (st_index[AVMEDIA_TYPE_AUDIO] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ret = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (st_index[AVMEDIA_TYPE_VIDEO] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (is-&gt;show_mode == SHOW_MODE_NONE)</span><br><span class="line">    is-&gt;show_mode = ret &gt;= <span class="number">0</span> ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (st_index[AVMEDIA_TYPE_SUBTITLE] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>stream_component_open函数的返回值0表示成功，负数表示打开失败，在打开视频流的时候对返回值进行了一下判断，并且设置相应的显示模式。除此之外，所有流的打开都是通过stream_component_open函数完成的。我们接下来分析stream_component_open函数都做了什么工作。</p>
<p>首先stream_component_open根据传进来的流序号从AVFormatContext中获取到对应的信息，并用这些信息结合用户指定的参数完成了解码器的创建。关键代码注释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">avctx = avcodec_alloc_context3(<span class="literal">NULL</span>);<span class="comment">//以默认值创建一个AVCodecContext</span></span><br><span class="line">	...</span><br><span class="line"> ret = avcodec_parameters_to_context(avctx, ic-&gt;streams[stream_index]-&gt;codecpar);<span class="comment">//将AVFormatContext中读取到的codec相关的参数复制给AVCodecContext对应的成员</span></span><br><span class="line"> ...</span><br><span class="line"> codec = avcodec_find_decoder(avctx-&gt;codec_id);<span class="comment">//根据codec_id查找解码器，codec_id是通过之前的avcodec_parameters_to_context函数从流的codecpar中获取到的</span></span><br><span class="line">...  </span><br><span class="line"> <span class="keyword">if</span> (forced_codec_name)<span class="comment">//如果用户指定了解码器名称，根据名称搜索解码器</span></span><br><span class="line">   codec = avcodec_find_decoder_by_name(forced_codec_name);</span><br><span class="line">	...</span><br><span class="line"> avctx-&gt;codec_id = codec-&gt;id;<span class="comment">//更新最终获取到的解码器id</span></span><br><span class="line">...</span><br><span class="line"> <span class="keyword">if</span> ((ret = avcodec_open2(avctx, codec, &amp;opts)) &lt; <span class="number">0</span>) &#123;<span class="comment">//设置好解码器选项后打开解码器</span></span><br><span class="line">   <span class="keyword">goto</span> fail;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打开解码器后针对不同的流类型做不同的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (avctx-&gt;codec_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">      sample_rate    = avctx-&gt;sample_rate;</span><br><span class="line">        nb_channels    = avctx-&gt;channels;</span><br><span class="line">        channel_layout = avctx-&gt;channel_layout;</span><br><span class="line">      <span class="comment">/* prepare audio output */</span></span><br><span class="line">      <span class="keyword">if</span> ((ret = audio_open(is, channel_layout, nb_channels, sample_rate, &amp;is-&gt;audio_tgt)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">      is-&gt;audio_hw_buf_size = ret;</span><br><span class="line">      is-&gt;audio_src = is-&gt;audio_tgt;</span><br><span class="line">      is-&gt;audio_buf_size  = <span class="number">0</span>;</span><br><span class="line">      is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* init averaging filter */</span></span><br><span class="line">      is-&gt;audio_diff_avg_coef  = <span class="built_in">exp</span>(<span class="built_in">log</span>(<span class="number">0.01</span>) / AUDIO_DIFF_AVG_NB);</span><br><span class="line">      is-&gt;audio_diff_avg_count = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">/* since we do not have a precise anough audio FIFO fullness,</span></span><br><span class="line"><span class="comment">         we correct audio sync only if larger than this threshold */</span></span><br><span class="line">      is-&gt;audio_diff_threshold = (<span class="type">double</span>)(is-&gt;audio_hw_buf_size) / is-&gt;audio_tgt.bytes_per_sec;</span><br><span class="line"></span><br><span class="line">      is-&gt;audio_stream = stream_index;</span><br><span class="line">      is-&gt;audio_st = ic-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_init(&amp;is-&gt;auddec, avctx, &amp;is-&gt;audioq, is-&gt;continue_read_thread)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">      <span class="keyword">if</span> ((is-&gt;ic-&gt;iformat-&gt;flags &amp; (AVFMT_NOBINSEARCH | AVFMT_NOGENSEARCH | AVFMT_NO_BYTE_SEEK)) &amp;&amp; !is-&gt;ic-&gt;iformat-&gt;read_seek) &#123;</span><br><span class="line">        is-&gt;auddec.start_pts = is-&gt;audio_st-&gt;start_time;</span><br><span class="line">        is-&gt;auddec.start_pts_tb = is-&gt;audio_st-&gt;time_base;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_start(&amp;is-&gt;auddec, audio_thread, <span class="string">&quot;audio_decoder&quot;</span>, is)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      SDL_PauseAudioDevice(audio_dev, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">      is-&gt;video_stream = stream_index;</span><br><span class="line">      is-&gt;video_st = ic-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_init(&amp;is-&gt;viddec, avctx, &amp;is-&gt;videoq, is-&gt;continue_read_thread)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_start(&amp;is-&gt;viddec, video_thread, <span class="string">&quot;video_decoder&quot;</span>, is)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      is-&gt;queue_attachments_req = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AVMEDIA_TYPE_SUBTITLE:</span><br><span class="line">      is-&gt;subtitle_stream = stream_index;</span><br><span class="line">      is-&gt;subtitle_st = ic-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_init(&amp;is-&gt;subdec, avctx, &amp;is-&gt;subtitleq, is-&gt;continue_read_thread)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">      <span class="keyword">if</span> ((ret = decoder_start(&amp;is-&gt;subdec, subtitle_thread, <span class="string">&quot;subtitle_decoder&quot;</span>, is)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里我删除了音频滤镜的代码，因为滤镜只是改变了相关参数的值，在分析代码逻辑的时候暂时注释掉这部分代码比较不容易混淆。</p>
<p>从代码中我们很容易发现视频流和字幕流的处理逻辑是完全一致的，都是初始化一个Decoder然后开启解码线程，音频则要复杂的多，所以我们先从视频流和字幕流的处理开始分析，最后再分析音频流的处理。</p>
<p>我们暂时不需要关心Decoder的工作原理，只需要知道decoder_init函数用于初始化一个Decoder结构体变量，而Decoder是对AVCodecContext的封装，加入了一些其他参数。而decoder_start所做的工作就是开启流对应的PacketQueue，表示已经可以向队列中写入数据了。然后开启对应的解码线程，如视频流是video_thread，字幕流是subtitle_thread。各个流对应的解码线程执行的具体工作我们会在后面的章节中详细分析。</p>
<p>接着是音频流的处理，从代码中我们可以发现，音频流的处理与视频流和字幕流最大的不同是在执行decoder_init之前，先是调用了一个名为audio_open的函数，然后设置了VideoState中很多相应的音频参数。我们先来看audio_open函数做了什么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">audio_open</span><span class="params">(<span class="type">void</span> *opaque, <span class="type">int64_t</span> wanted_channel_layout, <span class="type">int</span> wanted_nb_channels, <span class="type">int</span> wanted_sample_rate, <span class="keyword">struct</span> AudioParams *audio_hw_params)</span></span><br><span class="line">&#123;</span><br><span class="line">  SDL_AudioSpec wanted_spec, spec;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *env;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> next_nb_channels[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> next_sample_rates[] = &#123;<span class="number">0</span>, <span class="number">44100</span>, <span class="number">48000</span>, <span class="number">96000</span>, <span class="number">192000</span>&#125;;</span><br><span class="line">  <span class="type">int</span> next_sample_rate_idx = FF_ARRAY_ELEMS(next_sample_rates) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  env = SDL_getenv(<span class="string">&quot;SDL_AUDIO_CHANNELS&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (env) &#123;</span><br><span class="line">    wanted_nb_channels = atoi(env);</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!wanted_channel_layout || wanted_nb_channels != av_get_channel_layout_nb_channels(wanted_channel_layout)) &#123;</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);</span><br><span class="line">    wanted_channel_layout &amp;= ~AV_CH_LAYOUT_STEREO_DOWNMIX;</span><br><span class="line">  &#125;</span><br><span class="line">  wanted_nb_channels = av_get_channel_layout_nb_channels(wanted_channel_layout);</span><br><span class="line">  wanted_spec.channels = wanted_nb_channels;</span><br><span class="line">  wanted_spec.freq = wanted_sample_rate;</span><br><span class="line">  <span class="keyword">if</span> (wanted_spec.freq &lt;= <span class="number">0</span> || wanted_spec.channels &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Invalid sample rate or channel count!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (next_sample_rate_idx &amp;&amp; next_sample_rates[next_sample_rate_idx] &gt;= wanted_spec.freq)</span><br><span class="line">    next_sample_rate_idx--;</span><br><span class="line">  wanted_spec.format = AUDIO_S16SYS;</span><br><span class="line">  wanted_spec.silence = <span class="number">0</span>;</span><br><span class="line">  wanted_spec.samples = FFMAX(SDL_AUDIO_MIN_BUFFER_SIZE, <span class="number">2</span> &lt;&lt; av_log2(wanted_spec.freq / SDL_AUDIO_MAX_CALLBACKS_PER_SEC));</span><br><span class="line">  wanted_spec.callback = sdl_audio_callback;</span><br><span class="line">  wanted_spec.userdata = opaque;</span><br><span class="line">  <span class="keyword">while</span> (!(audio_dev = SDL_OpenAudioDevice(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;wanted_spec, &amp;spec, SDL_AUDIO_ALLOW_FREQUENCY_CHANGE | SDL_AUDIO_ALLOW_CHANNELS_CHANGE))) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;SDL_OpenAudio (%d channels, %d Hz): %s\n&quot;</span>,</span><br><span class="line">           wanted_spec.channels, wanted_spec.freq, SDL_GetError());</span><br><span class="line">    wanted_spec.channels = next_nb_channels[FFMIN(<span class="number">7</span>, wanted_spec.channels)];</span><br><span class="line">    <span class="keyword">if</span> (!wanted_spec.channels) &#123;</span><br><span class="line">      wanted_spec.freq = next_sample_rates[next_sample_rate_idx--];</span><br><span class="line">      wanted_spec.channels = wanted_nb_channels;</span><br><span class="line">      <span class="keyword">if</span> (!wanted_spec.freq) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">&quot;No more combinations to try, audio open failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(wanted_spec.channels);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (spec.format != AUDIO_S16SYS) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">           <span class="string">&quot;SDL advised audio format %d is not supported!\n&quot;</span>, spec.format);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (spec.channels != wanted_spec.channels) &#123;</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(spec.channels);</span><br><span class="line">    <span class="keyword">if</span> (!wanted_channel_layout) &#123;</span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">             <span class="string">&quot;SDL advised channel count %d is not supported!\n&quot;</span>, spec.channels);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  audio_hw_params-&gt;fmt = AV_SAMPLE_FMT_S16;</span><br><span class="line">  audio_hw_params-&gt;freq = spec.freq;</span><br><span class="line">  audio_hw_params-&gt;channel_layout = wanted_channel_layout;</span><br><span class="line">  audio_hw_params-&gt;channels =  spec.channels;</span><br><span class="line">  audio_hw_params-&gt;frame_size = av_samples_get_buffer_size(<span class="literal">NULL</span>, audio_hw_params-&gt;channels, <span class="number">1</span>, audio_hw_params-&gt;fmt, <span class="number">1</span>);</span><br><span class="line">  audio_hw_params-&gt;bytes_per_sec = av_samples_get_buffer_size(<span class="literal">NULL</span>, audio_hw_params-&gt;channels, audio_hw_params-&gt;freq, audio_hw_params-&gt;fmt, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (audio_hw_params-&gt;bytes_per_sec &lt;= <span class="number">0</span> || audio_hw_params-&gt;frame_size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;av_samples_get_buffer_size failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> spec.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先从入参开始看，channel_layout, nb_channels, sample_rate都是从解码器对应的AVCodecContext中获取的，分别代表音频的通道布局，通道数和采样率，&amp;is-&gt;audio_tgt是一个AudioParams结构体变量的地址，该变量用于存储硬件支持的音频参数。</p>
<p>函数一开始先对传入的通道布局和通道数进行匹配，结合环境变量计算出合适的通道布局和通道数，然后根据传入的采样率算出一个不大于它的符合标准的采样率。</p>
<p>接下来使用SDL库函数SDL_OpenAudioDevice()打开音频设备。这里简单说一下这个函数的原理，函数的第一个参数类型为const char*，用来指定设备ID，这里设置为NULL,表示自动选择，第二个函数类型为int，为0时表示打开设备用于播放，非零时表示打开设备用于录音，第三个参数类型是 const SDL_AudioSpec*，存储用户指定的音频参数，第四个参数类型是SDL_AudioSpec*，存储函数执行成功后实际设置的音频参数，最后一个参数是标志位，用于指定那些参数可以被修改，这里我们设置的是允许修改频率和通道数。该函数返回0表示失败，大于0表示成功并且返回值为音频设备id。如果打开设备不成功，函数会修改通道数和采样率并尝试重新打开设备，当经过计算后的采样率为0时，函数返回-1。打开设备成功后，相应的音频参数会被赋给audio_tgt相应的字段，然后函数返回音频缓冲区的大小值。还有一个我们不能忽视的函数，作为第三个参数SDL_AudioSpec中callback成员传入的sdl_audio_callback函数。sdl音频输出的工作原理是这样的，当成功打开音频设备时，音频输出是暂停的，需要手动调用SDL_PauseAudioDevice()函数让音频设备开始工作，当音频设备开始工作的时候会间歇的调用SDL_AudioSpec中的callback函数来”拉取“音频数据写入音频设备，所以callback函数的作用就是提供音频数据。我们看一下ffplay的sdl_audio_callback函数是怎么写的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sdl_audio_callback</span><span class="params">(<span class="type">void</span> *opaque, Uint8 *stream, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  VideoState *is = opaque;</span><br><span class="line">  <span class="type">int</span> audio_size, len1;</span><br><span class="line"></span><br><span class="line">  audio_callback_time = av_gettime_relative();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;<span class="comment">//如果程序当前缓冲区中没有数据，就解析一帧数据</span></span><br><span class="line">      audio_size = audio_decode_frame(is);</span><br><span class="line">      <span class="keyword">if</span> (audio_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* if error, just output silence */</span></span><br><span class="line">        is-&gt;audio_buf = <span class="literal">NULL</span>;</span><br><span class="line">        is-&gt;audio_buf_size = SDL_AUDIO_MIN_BUFFER_SIZE / is-&gt;audio_tgt.frame_size * is-&gt;audio_tgt.frame_size;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;show_mode != SHOW_MODE_VIDEO)<span class="comment">//如果当前的显示模式不是视频模式，将音频数据进行图形化显示</span></span><br><span class="line">          update_sample_display(is, (<span class="type">int16_t</span> *)is-&gt;audio_buf, audio_size);</span><br><span class="line">        is-&gt;audio_buf_size = audio_size;</span><br><span class="line">      &#125;</span><br><span class="line">      is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<span class="comment">//计算写入数据的长度</span></span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len)</span><br><span class="line">      len1 = len;</span><br><span class="line">    <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf &amp;&amp; is-&gt;audio_volume == SDL_MIX_MAXVOLUME)<span class="comment">//当不静音且audio_buf有效时才输出数据，如果音量为SDL_MIX_MAXVOLUME，直接输出数据</span></span><br><span class="line">      <span class="built_in">memcpy</span>(stream, (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">memset</span>(stream, <span class="number">0</span>, len1);</span><br><span class="line">      <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf)<span class="comment">//否则混合音频数据以AUDIO_S16SYS格式输出</span></span><br><span class="line">        SDL_MixAudioFormat(stream, (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, AUDIO_S16SYS, len1, is-&gt;audio_volume);</span><br><span class="line">    &#125;</span><br><span class="line">    len -= len1;</span><br><span class="line">    stream += len1;</span><br><span class="line">    is-&gt;audio_buf_index += len1;</span><br><span class="line">  &#125;</span><br><span class="line">  is-&gt;audio_write_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">  <span class="comment">/* Let&#x27;s assume the audio driver that is used by SDL has two periods. */</span></span><br><span class="line">  <span class="keyword">if</span> (!isnan(is-&gt;audio_clock)) &#123;<span class="comment">//更新时钟</span></span><br><span class="line">    set_clock_at(&amp;is-&gt;audclk, is-&gt;audio_clock - (<span class="type">double</span>)(<span class="number">2</span> * is-&gt;audio_hw_buf_size + is-&gt;audio_write_buf_size) / is-&gt;audio_tgt.bytes_per_sec, is-&gt;audio_clock_serial, audio_callback_time / <span class="number">1000000.0</span>);</span><br><span class="line">    sync_clock_to_slave(&amp;is-&gt;extclk, &amp;is-&gt;audclk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>callback的函数签名是统一的，opaque是用户数据，本程序中我们设置的是VideoState，stream表示音频数据缓冲区，len表示缓冲区大小。从代码中我们可以看到由于sdl音频这种通过回调函数”拉取“数据的方式，程序需要在callback中提供音频数据，所以音频数据从FrameQueue中的读取从此时就开始了，这一点跟视频流和字幕流都不一样，后两者是在主循环中需要显示画面的时候才从FrameQueue中读取的，而且是在主线程中操作。</p>
<p>还有一个关键函数audio_decode_frame(),作用是从FrameQueue中读取一帧数据然后解析成音频数据。因为其中涉及到音视频同步，所以我准备在后面分析音视频同步的时候详细分析这部分代码，目前就只需要知道这个函数的功能就可以了。</p>
<p>audio_open分析完了，我们再来看音频流处理剩下的代码，之前我们提到过，SDL打开音频设备后，设备默认是暂停的，需要手动取消暂停设备才会开始通过callback函数获取数据播放音频。这样做的目的是为了打开音频设备后让程序有时间做一些数据的初始化工作的。接下来的代码就是做一些播放前的准备操作，包括一些参数的赋值或初始化以及开启音频解码线程。在做完这些操作后，调用SDL_PauseAudioDevice(audio_dev, 0)解除音频设备的静音状态，其中audio_dev是SDL_OpenAudioDevice函数的返回值。</p>
<p>stream_component_open函数到此就分析完了，read_thread剩下的代码是一个无限循环，主要工作就是使用av_read_frame()从流读取包再放入PacketQueue。我们看一下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*针对网络流的开启或关闭操作*/</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;seek_req) &#123;<span class="comment">//seek到指定位置，此操作会刷新PacketQueue，导致serial+1，并且如果是暂停状态下seek，seek完成后会更新一帧画面</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;queue_attachments_req) &#123;<span class="comment">//如果视频流保存的是附加数据，如专辑封面等，读取数据后放入队列，然后放入空包以此告诉解码器已经到达当前流结尾</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果队列已满，暂时不要读取更多数据，等待最长10ms，就开始下一个循环 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*播放完后判断是直接退出还是循环播放*/</span></span><br><span class="line">    ... </span><br><span class="line">    ret = av_read_frame(ic, pkt);<span class="comment">//读取一个AVPacket</span></span><br><span class="line">  	<span class="comment">/*如果读取失败，判断是到达了文件结尾还是io错误，如果到达了文件结尾，就往队列里放空包并设置标志位</span></span><br><span class="line"><span class="comment">  	如果是io错误，则选择退出程序或结束线程，否则就等待最长10ms，继续下一次循环*/</span>	</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 判断数据是否在用户指定的播放时间范围内，如果不在就丢弃 */</span></span><br><span class="line">		...</span><br><span class="line">    <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;audio_stream &amp;&amp; pkt_in_play_range) &#123;</span><br><span class="line">      packet_queue_put(&amp;is-&gt;audioq, pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;video_stream &amp;&amp; pkt_in_play_range</span><br><span class="line">        &amp;&amp; !(is-&gt;video_st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC)) &#123;</span><br><span class="line">      packet_queue_put(&amp;is-&gt;videoq, pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;subtitle_stream &amp;&amp; pkt_in_play_range) &#123;</span><br><span class="line">      packet_queue_put(&amp;is-&gt;subtitleq, pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      av_packet_unref(pkt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码经过精简，精简掉的代码功能已经通过注释写明，这里比较难理解的是判断数据是否在播放范围的判断条件，我们详细分析一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stream_start_time = ic-&gt;streams[pkt-&gt;stream_index]-&gt;start_time;</span><br><span class="line">    pkt_ts = pkt-&gt;pts == AV_NOPTS_VALUE ? pkt-&gt;dts : pkt-&gt;pts;</span><br><span class="line">    pkt_in_play_range = duration == AV_NOPTS_VALUE ||</span><br><span class="line">        (pkt_ts - (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : <span class="number">0</span>)) *</span><br><span class="line">            av_q2d(ic-&gt;streams[pkt-&gt;stream_index]-&gt;time_base) -</span><br><span class="line">            (<span class="type">double</span>)(start_time != AV_NOPTS_VALUE ? start_time : <span class="number">0</span>) / <span class="number">1000000</span></span><br><span class="line">            &lt;= ((<span class="type">double</span>)duration / <span class="number">1000000</span>);</span><br></pre></td></tr></table></figure>

<p>首先获取stream的开始时间stream_start_time，然后拿到该数据包的展示时间pkt_ts，如果pts不存在，就用解码时间dts代替。判断是否在播放范围是一个或操作，第一个条件很好理解，duration未定义时，一律认定在播放范围。第二个条件我们分开看，首先是展示时间pkt_ts减去流开始时间stream_start_time，这样我们可以认为我们获得了以stream_start_time为零点的一个时间点，我们用这个值减去start_time（start_time是用户设置的开始时间，这个时间也是一个以stream_start_time为零点的一个时间点）得到的结果是一个时间段，如果这个时间段的值小于duration，说明该数据展示的时间点早于start_time+duration得到的时间点，那么这个数据就在播放范围内，否则说明该数据展示的时间点晚于start_time+duration得到的时间点，我们并不需要播放这段数据，所以这段数据就被丢弃。那么有没有可能pkt_ts小于start_time呢？这样也能满足上述条件，但是这个数据也不在播放范围内。答案是不可能，因为这种情况发生的情况只会是发生了seek，seek操作的处理在读取数据之前已经完成，所以seek时间点之前的数据是不可能被读到的。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">wenxy</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://wxyfq.github.io/2022/12/01/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%AF%BB%E7%BA%BF%E7%A8%8B/">https://wxyfq.github.io/2022/12/01/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%AF%BB%E7%BA%BF%E7%A8%8B/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">wenxy</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/ffplay/">
                                    <span class="chip bg-color">ffplay</span>
                                </a>
                            
                                <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">
                                    <span class="chip bg-color">源码解析</span>
                                </a>
                            
                                <a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/">
                                    <span class="chip bg-color">音视频</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpeg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.JPG" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/12/02/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E8%A7%A3%E7%A0%81%E7%BA%BF%E7%A8%8B/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="ffplay源码解析（六）：解码线程">
                        
                        <span class="card-title">ffplay源码解析（六）：解码线程</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            解析ffplay源码中解码线程的实现原理
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-12-02
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-category">
                                    ffplay源码解析
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/ffplay/">
                        <span class="chip bg-color">ffplay</span>
                    </a>
                    
                    <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">
                        <span class="chip bg-color">源码解析</span>
                    </a>
                    
                    <a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/">
                        <span class="chip bg-color">音视频</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/11/30/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AFrameQueue/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/14.jpg" class="responsive-img" alt="ffplay源码解析（四）：FrameQueue">
                        
                        <span class="card-title">ffplay源码解析（四）：FrameQueue</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            解析ffplay源码中FrameQueue
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-11-30
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/ffplay%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-category">
                                    ffplay源码解析
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/ffplay/">
                        <span class="chip bg-color">ffplay</span>
                    </a>
                    
                    <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">
                        <span class="chip bg-color">源码解析</span>
                    </a>
                    
                    <a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/">
                        <span class="chip bg-color">音视频</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->


<!-- 代码块复制 -->


<!-- 代码块收缩 -->


    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">wenxy</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">46.4k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:919601977@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=919601977" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 919601977" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
